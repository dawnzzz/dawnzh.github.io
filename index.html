<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/03/08/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-KDS-Watchdog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/08/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-KDS-Watchdog/" class="post-title-link" itemprop="url">Kuma学习笔记 (8) KDS Watchdog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-08 10:59:20 / 修改时间：15:18:07" itemprop="dateCreated datePublished" datetime="2024-03-08T10:59:20+08:00">2024-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h1><h2 id="什么是-Watchdog"><a href="#什么是-Watchdog" class="headerlink" title="什么是 Watchdog"></a>什么是 Watchdog</h2><p>在 Kuma KDS 中，<strong>当 Zone CP 和 Global CP 建立 streaming 连接后</strong>，需要推送资源的一方在每一条连接开启一个 Watchdog。</p>
<p>Watchdog 用于收集变化的资源，并定期更新 xds-cache（xds-cache 的更新会引发 xds 推送），<strong>完成从 Global CP 与 Zone CP 之间的被更新资源的主动推送过程</strong>。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-KDS-Watchdog/image-20240308110246222.png" alt="image-20240308110246222"></p>
<h2 id="Watchdog-数据结构"><a href="#Watchdog-数据结构" class="headerlink" title="Watchdog 数据结构"></a>Watchdog 数据结构</h2><p>Watchdog 的数据结构如下：</p>
<ul>
<li>Node：表示一个 envoy 节点，这里是一个 Zone CP 节点。</li>
<li>EventBus：事件总线，Watchdog 通过事件总线订阅资源更新的事件。</li>
<li>Reconciler：调和器，用于重新计算配置资源，并更新 xds-cache。</li>
<li>ProvidedTypes：需要同步的所有资源类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventBasedWatchdog <span class="keyword">struct</span> &#123;</span><br><span class="line">   Ctx                 context.Context</span><br><span class="line">   Node                *envoy_core.Node</span><br><span class="line">   EventBus            events.EventBus</span><br><span class="line">   Reconciler          reconcile.Reconciler</span><br><span class="line">   ProvidedTypes       <span class="keyword">map</span>[model.ResourceType]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   Log                 logr.Logger</span><br><span class="line">   NewFlushTicker      <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">time</span>.<span class="title">Ticker</span></span></span><br><span class="line">   NewFullResyncTicker <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">time</span>.<span class="title">Ticker</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>在 Start 方法中定义了 Watchdog 的工作流程：</p>
<ol>
<li>首先，从事件总线中<strong>订阅 ResourceChangedEvent 资源更新事件</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listener := e.EventBus.Subscribe(<span class="function"><span class="keyword">func</span><span class="params">(event events.Event)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   resChange, ok := event.(events.ResourceChangedEvent)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> _, ok := e.ProvidedTypes[resChange.Type]; !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>changedTypes 记录已经修改的资源，<strong>第一次同步的是全量的资源</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for the first reconcile assign all types</span></span><br><span class="line">changedTypes := maps.Clone(e.ProvidedTypes)</span><br><span class="line">reasons := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;</span><br><span class="line">   ReasonResync: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启<strong>两个定时器 flushTicker 和 fullResyncTicker</strong>。flushTicker 用于<strong>定期向 xds-cache 中同步被修改的资源</strong>；fullResyncTicker 用于定期向 xds-cache 进行<strong>全量</strong>的资源同步。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">      <span class="keyword">if</span> err := e.Reconciler.Clear(e.Ctx, e.Node); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         e.Log.Error(err, <span class="string">&quot;reconcile clear failed&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      listener.Close()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-flushTicker.C:</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(changedTypes) == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      reason := strings.Join(util_maps.SortedKeys(reasons), <span class="string">&quot;_and_&quot;</span>)</span><br><span class="line">      e.Log.V(<span class="number">1</span>).Info(<span class="string">&quot;reconcile&quot;</span>, <span class="string">&quot;changedTypes&quot;</span>, changedTypes, <span class="string">&quot;reason&quot;</span>, reason)</span><br><span class="line">      err, _ := e.Reconciler.Reconcile(e.Ctx, e.Node, changedTypes, e.Log)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.Is(err, context.Canceled) &#123;</span><br><span class="line">         e.Log.Error(err, <span class="string">&quot;reconcile failed&quot;</span>, <span class="string">&quot;changedTypes&quot;</span>, changedTypes, <span class="string">&quot;reason&quot;</span>, reason)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         changedTypes = <span class="keyword">map</span>[model.ResourceType]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         reasons = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> &lt;-fullResyncTicker.C:</span><br><span class="line">      e.Log.V(<span class="number">1</span>).Info(<span class="string">&quot;schedule full resync&quot;</span>)</span><br><span class="line">      changedTypes = maps.Clone(e.ProvidedTypes)</span><br><span class="line">      reasons[ReasonResync] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">   <span class="keyword">case</span> event := &lt;-listener.Recv():</span><br><span class="line">      resChange := event.(events.ResourceChangedEvent)</span><br><span class="line">      e.Log.V(<span class="number">1</span>).Info(<span class="string">&quot;schedule sync for type&quot;</span>, <span class="string">&quot;typ&quot;</span>, resChange.Type)</span><br><span class="line">      changedTypes[resChange.Type] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      reasons[ReasonEvent] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reconciler-调和器"><a href="#Reconciler-调和器" class="headerlink" title="Reconciler 调和器"></a>Reconciler 调和器</h1><p>Reconciler 用于重新计算给定 node 的配置资源信息，并同步到 xds-cache 中，接口定义如下：</p>
<ul>
<li><strong>Reconcile 方法：</strong>调和已经修改的资源类型，从老的 Snapshot 中取未改变的资源，再重新查询已经改变的资源，并以此创建新的 Snapshot 并更新给 xds-cache。</li>
<li>Clear 方法：在 xds-cache 中清理 Snapshot，在 streaming 结束时调用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reconciler re-computes configuration for a given node.</span></span><br><span class="line"><span class="keyword">type</span> Reconciler <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// Reconcile reconciles state of node given changed resource types.</span></span><br><span class="line">   <span class="comment">// Returns error and bool which is true if any resource was changed.</span></span><br><span class="line">   Reconcile(context.Context, *envoy_core.Node, <span class="keyword">map</span>[model.ResourceType]<span class="keyword">struct</span>&#123;&#125;, logr.Logger) (error, <span class="keyword">bool</span>)</span><br><span class="line">   Clear(context.Context, *envoy_core.Node) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reconcile-方法"><a href="#Reconcile-方法" class="headerlink" title="Reconcile 方法"></a>Reconcile 方法</h2><p>Reconcile 方法调和已经修改的资源类型，从老的 Snapshot 中取未改变的资源，再重新查询已经改变的资源，并<strong>以此创建新的 Snapshot 并更新给 xds-cache</strong>。具体流程如下：</p>
<ol>
<li>首先从 xds-cache 中查询老的 Snapshot。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id := r.hasher.ID(node)</span><br><span class="line">old, _ := r.cache.GetSnapshot(id)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于<strong>未变更的资源</strong>，直接<strong>从老的 Snapshot 中获取</strong>。接着调用 <code>r.generator.GenerateSnapshot</code> 方法，<strong>重新查询已经修改的资源</strong>，并根据已变更和未变更的资源<strong>创建新的 Snapshot</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct builder with unchanged types from the old snapshot</span></span><br><span class="line">builder := cache.NewSnapshotBuilder()</span><br><span class="line"><span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, typ := <span class="keyword">range</span> util_dds.GetSupportedTypes() &#123;</span><br><span class="line">      resType := core_model.ResourceType(typ)</span><br><span class="line">      <span class="keyword">if</span> _, ok := changedTypes[resType]; ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      oldRes := old.GetResources(typ)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(oldRes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         builder = builder.With(resType, maps.Values(oldRes))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span>, err := r.generator.GenerateSnapshot(ctx, node, builder, changedTypes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.New(<span class="string">&quot;nil snapshot&quot;</span>), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>若新的 Snapshot 相比于老的<strong>发生了修改</strong>，则<strong>同步</strong>到 xds-cache 中。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>, changed := r.Version(<span class="built_in">new</span>, old)</span><br><span class="line"><span class="keyword">if</span> changed &#123;</span><br><span class="line">   r.logChanges(logger, <span class="built_in">new</span>, old, node)</span><br><span class="line">   r.meterConfigReadyForDelivery(<span class="built_in">new</span>, old, node.Id)</span><br><span class="line">   <span class="keyword">return</span> r.cache.SetSnapshot(ctx, id, <span class="built_in">new</span>), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/" class="post-title-link" itemprop="url">Pulsar消息队列(4)延迟消息投递</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-22 20:19:25" itemprop="dateCreated datePublished" datetime="2024-02-22T20:19:25+08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Pulsar消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="延迟消息投递"><a href="#延迟消息投递" class="headerlink" title="延迟消息投递"></a>延迟消息投递</h1><p>开源的 NSQ、RabbitMQ、ActiveMQ 和 Pulsar 也都内置了延迟消息的处理能力。虽然每个 MQ 项目的使用和实现方式不同，但核心实现思路都一样：<strong>Producer 将一个延迟消息发送到某个 Topic 中，Broker 将延迟消息放到临时存储进行暂存，延迟跟踪服务（Delayed Tracker Service）会检查消息是否到期，将到期的消息进行投递</strong>。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/640.png" alt="图片"></p>
<p>延迟消息投递是要暂缓对当前消息的处理，在未来的某个时间点再触发投递，实际的应用场景非常多，比如异常检测重试、订单超时取消、预约提醒等。</p>
<p>Pulsar 最早是在 2.4.0 引入了延迟消息投递的特性，在 Pulsar 中使用延迟消息，可以精确指定延迟投递的时间，有 deliverAfter 和 deliverAt 两种方式。其中 deliverAt 可以指定具体的时间戳；deliverAfter 可以指定在当前多长时间后执行。</p>
<p>在 Pulsar 中，可以支持跨度很大的延时消息，比方说一个月、半年；同时在一个 Topic 里，既支持延时消息，也支持非延时消息。下图展示了 Pulsar 中延迟消息的具体过程：</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/640-20240222202207636.png" alt="图片"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Pulsar 实现延迟消息投递的方式比较简单，<strong>Delayed Message Tracker 在堆外内存维护着一个 delayed index 优先级队列</strong>，根据延迟时间进行堆排序，延迟时间最短的会放在头上，时间越长越靠后。</p>
<p>Consumer 在消费时，会先去 Delayed Message Tracker 检查，是否有到期需要投递的消息，如果有到期的消息，则从 Tracker 中拿出对应的 index，找到对应的消息进行消费；如果没有到期的消息，则直接消费正常的消息。</p>
<p>如果集群出现 Broker 宕机，Pulsar 会重建 delayed index 队列，来保证延迟投递的消息能够正常工作。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/640.jpeg" alt="图片"></p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>从 Pulsar 的延迟消息投递实现原理可以看出，该方法简单高效，对 Pulsar 内核侵入性较小，可以支持到任意时间的延迟消息。但同时发现，Pulsar 的实现方案无法支持大规模使用延迟消息，主要有以下两个原因：</p>
<p><strong>1. delayed index队列受到内存限制</strong></p>
<p><strong>2. delayed index队列重建时间开销</strong></p>
<h2 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h2><p>Pulsar 目前的延迟消息投递方案简单高效，但处理大规模延迟消息时仍然存在风险。关于延迟消息投递，社区和数据平台部 MQ 团队下一步将聚焦在支持大规模延迟消息。目前讨论的方案是在 delayed index 队列加入时间分区，Broker 只加载当前较近的时间片 delayed index 到内存，其余时间片分区持久化磁盘，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Pulsar消息队列(3)订阅模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-22 20:12:02" itemprop="dateCreated datePublished" datetime="2024-02-22T20:12:02+08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Pulsar消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Consumer 订阅 Topic 的时候，通过<strong>订阅模式</strong>来控制消息的使用模式，指定如何将消息投递给一个组一个的或多个的 Consumer。Pulsar 支持 4 种订阅模式:</p>
<ul>
<li>exclusive（独占模式）</li>
<li>failover（故障转移模式，也叫灾备模式）</li>
<li>shared（共享模式）</li>
<li>key-shared（基于key的共享模式）</li>
</ul>
<h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><h2 id="exclusive"><a href="#exclusive" class="headerlink" title="exclusive"></a>exclusive</h2><p>独占模式，只能有一个 Consumer 绑定到订阅上。如果多于一个 Consumer 尝试以使用相同的订阅订阅 Topic，就会抛出异常且无法连接。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/pulsar-exclusive-subscriptions.png" alt="pulsar-exclusive-subscriptions.png"></p>
<h2 id="failover"><a href="#failover" class="headerlink" title="failover"></a>failover</h2><p>在灾备订阅模式中，多个 Consumer 可以绑定到同一个订阅上， Consumer 将会<strong>按字典顺序排序</strong>，<strong>第一个 Consumer 被初始化为唯一接受消息的消费者</strong>，被称为 Master Consumer。 当 Master Consumer 断开时，所有的未被确认和后续进入的消息将会被投递给下一个 Consumer。</p>
<blockquote>
<p>灾备模式提供了高可用性。</p>
</blockquote>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/pulsar-failover-subscriptions.png" alt="pulsar-failover-subscriptions.png"></p>
<h2 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h2><p>在共享模式中，多个 Consumer 可以绑定到同一个订阅上。 <strong>消息通过 round robin 轮询机制分发给不同的消费者</strong>，并且每个消息仅会被分发给一个消费者。 当一个消费者断开连接时，所有已经投递给它但还没有被确认的消息将被重新投递，分发给其它存活的消费者。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/pulsar-shared-subscriptions.png" alt="pulsar-shared-subscriptions.png"></p>
<h2 id="key-shared"><a href="#key-shared" class="headerlink" title="key-shared"></a>key-shared</h2><p>key-shared 模式是共享模式的一种特例，它也允许多个 Consumer 可以绑定到同一个订阅上，与共享模式中的 round robin 轮询消费消息不同，key-shared 模式增加了一个辅助 key，<strong>确保具有相同 key 的消息被交付给相同的消费者</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2-%E7%A7%9F%E6%88%B7-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-Topic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2-%E7%A7%9F%E6%88%B7-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-Topic/" class="post-title-link" itemprop="url">Pulsar消息队列(2)租户 命名空间 Topic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-22 20:02:09" itemprop="dateCreated datePublished" datetime="2024-02-22T20:02:09+08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Pulsar消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Pulsar 在逻辑上的层级，从上到下依次为租户、命名空间、Topic。</p>
<p>每个租户都可以有单独的认证和授权机制，可以针对租户设置存储配额、消息生存时间 TTL 和隔离策略。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2-%E7%A7%9F%E6%88%B7-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-Topic/pulsar-logical-arch2.png" alt="pulsar-logical-arch2.png"></p>
<p>默认情况下一个 Topic 中的消息只能由 Pulsar 服务层中的一个 Broker 提供服务，因此单个 Topic 的吞吐量受限于为其提供服务的 Broker 的计算能力。 </p>
<p>好在 Pulsar 还支持<strong>分区主题</strong>，这允许多个 Broker 提供服务，就可以将负载分布到多台机器上。在 Pulsar 内部，<strong>分区主题被实现为 N 个内部 Topic</strong>，N 是分区数量，分区跨 Broker 的分布<strong>由 Pulsar 自动管理</strong>，这对用户来说是完全透明的。 Pulsar 将分区主题实现为多个内部主题，这样就可以在需要增加分区数量的时候不必重新平衡整个主题，Pulsar 只需在其内部创建新的内部主题就能够立即接收新的消息，使客户端能在不中断的情况下对现有分区进行消息读写。</p>
<p>当生产者发布消息到分区主题时，不需要特意指定路由模式，默认以轮循的方式将消息均匀分布到各个分区。支持以下3种路由模式:</p>
<ul>
<li><strong>SinglePartition：</strong>如果没有消息 key 提供，生产者将会随机选择一个固定的分区来发布消息（同一个生产者生产在同一个分区中），可用于将来自特定生产者的消息分组在一起，以在没有键值时维护消息顺序。</li>
<li><strong>RoundRobinPartition：</strong>如果没有消息 key 提供，将以轮循的方式将消息均匀分布到各个分区。</li>
<li><strong>CustomPartition：</strong>定制实现路由模式，控制消息分发到 Topic 的分区中。</li>
</ul>
<p>如果提供了消息 key，<strong>会以 key 做 hash，然后分配消息到指定分区</strong>。因此分区中消息的顺序与路由模式和消息的key有关，所有拥有相同的 key 的消息有序，将会被发送到相同的分区</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Pulsar消息队列(1)简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-22 13:06:00" itemprop="dateCreated datePublished" datetime="2024-02-22T13:06:00+08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Pulsar消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Apache Pulsar是一个支持<strong>多租户的、高性能的、分布式</strong>的<strong>多租户</strong>消息系统，最初由雅虎开发，现在是Apache软件基金会的顶级项目。 Pulsar提供非常低的消息发布和端到端的延迟、保障消息可靠传递零丢失。</p>
<h1 id="分布式消息系统"><a href="#分布式消息系统" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h1><blockquote>
<p>Pulsar 是<strong>基于段</strong>的分布式消息队列。</p>
</blockquote>
<p>一般的消息系统在逻辑上都可分为<strong>服务层</strong>和存储层两层:</p>
<ul>
<li><strong>服务层：</strong>直接与消息的<strong>生产者和消费者交互</strong>，接收传入的消息并将消息路由到一个或多个目的地。服务层通过支持的消息协议进行通讯，例如AMQP。服务层在消息协议转换上依赖CPU，在通信上依赖网络带宽。</li>
<li><strong>存储层：</strong>负责消息的<strong>存储</strong>。存储层与服务层交互提供服务层请求的消息，存储层保持消息的正确顺序。存储层严重依赖硬盘来存储消息。</li>
</ul>
<blockquote>
<p>分布式消息系统与传统单点消息系统在架构上的主要<strong>差别</strong>在于<strong>存储层的设计方式</strong>。在<strong>分布式</strong>消息传递系统中，数据分布在集群中的多台机器上，允许在单个主题中保留超过单个机器存储容量的消息。分布式消息系统存储层的<strong>关键架构抽象是 write-ahead-log</strong>，它将<strong>存储的消息看成是单个仅追加的数据结构</strong>。 对于分布式消息系统，当新消息发布到主题时，从逻辑的角度来看，消息将被追加到日志的末尾；从物理的角度来看，消息可能写入集群中的任何服务器。</p>
</blockquote>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/partion-based-msg.png" alt="partion-based-msg.png"></p>
<p>分布式消息系统的好处是<strong>将负载分散到多台机器上</strong>，可以提高消息的生产和消费的吞吐量，每台服务器都有自己硬盘和写入路径，将提供更好的写入速率。 在分布式消息系统集群中分布消息数据时，有两种不同的方法: <strong>基于分区（Partion-based）和基于段（Segment-based）</strong>。</p>
<h2 id="基于分区"><a href="#基于分区" class="headerlink" title="基于分区"></a>基于分区</h2><blockquote>
<p> Kafka 采用的是基于分区的消息存储架构。</p>
</blockquote>
<p>在基于分区的消息存储结构中，<strong>Topic 被划分为固定数量的分区</strong>，发布到 Topic 中的数据均匀的分布在分区中，同时为了确保数据冗余，<strong>每个分区会被复制到不同的节点</strong>。</p>
<p>Topic 中消息的总存储量为 Topic 的分区数乘以分区的大小，如果达到这个限制，需要向集群添加更多的节点同时增加 Topic 的分区数量才能继续向分区中添加数据，增加分区的数量还需要执行重新平衡，这是一个十分复杂和耗时的过程。</p>
<p>在基于分区的消息存储结构的分布式消息系统中，一般在创建 Topic 的时候需要预先确定分区数量，但这样做有一些缺点，因为单个分区只会存储在集群中单个集群节点上，因此单个分区的大小就受限于该节点上的硬盘空间大小，由于 Topic 中的数据均匀分布在所有分区中，所以如果集群节点的硬盘容量不一样的话，<strong>那么 Topic 的每个分区的大小将限制为最小硬盘容量的节点</strong>。当 Topic 达到容量限制后，<strong>唯一能做的就是增加 Topic 的分区数量</strong>，但这个扩容的过程包括<strong>重新平衡整个 Topic</strong>，Topic 中的数据将被重新分布到该 Topic 的所有分区中，平衡数据的过程<strong>十分消耗网络带宽和磁盘 I/O</strong>。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/kafka-partitions.png" alt="kafka-partitions"></p>
<h2 id="基于段"><a href="#基于段" class="headerlink" title="基于段"></a>基于段</h2><blockquote>
<p>Pulsar 采用的是基于段的消息存储结构。</p>
<p>Pulsar 中服务层合存储层都是<strong>无状态</strong>的，可以任意的进行<strong>水平</strong>扩容。<strong>引入 Zookeeper 集群</strong>，用于集群级别的配置和协调，Zookeeper 中存储 Pulsar 集群的所有元数据（例如 Topic 元数据、Broker 负载数据等等)</p>
</blockquote>
<p><strong>Pulsar 依赖 Apache BookKeeper 项目来实现消息的持久存储</strong>，BookKeeper 的逻辑存储模型是基于无限流记录作为顺序日志存储的概念。</p>
<p>在BookKeeper中，<strong>每个日志被分解成更小的数据块</strong>，称为段（Segament），这些数据块又由多个日志条目组成。然后，为了实现冗余和扩展，这些段会在存储层中被称为 bookies 的多个节点上写入。可以<strong>将段放在集群节点具有足够硬盘容量的任何位置</strong>，当没有足够的空间用于存储新的段时，可以方便地添加节点并立即存储数据。基于段的存储架构的优点在于<strong>可以实现真正的水平伸缩</strong>，段可以被无限创建并存储在任何位置。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/pulsar-segaments.png" alt="pulsar-segaments"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/04/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-Resource-Manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-Resource-Manager/" class="post-title-link" itemprop="url">Kuma学习笔记 (7) Resource Manager</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-04 17:00:10" itemprop="dateCreated datePublished" datetime="2024-02-04T17:00:10+08:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma 将使用的对象抽象为各种资源（Resource），如 Zone，Ingress，Dataplain，RateLimit 等，<strong>由资源管理器（Resource Manager）对资源存储（Resource Store）进行增删改查等操作</strong>。</p>
<p><strong>Resource Store 向上屏蔽了底层存储的差异</strong>，在 Kuma 中使用两种存储模式，kubernetes API Server 和 PostgreSQL 数据库。而 <strong>Resource Manager 屏蔽了对于各个资源操作的差异</strong>。</p>
<h1 id="Resource-Store"><a href="#Resource-Store" class="headerlink" title="Resource Store"></a>Resource Store</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>ResourceStore 接口用于定义资源的底层存储，ResourceStore 需要实现 Create、Update、Delete、Get、List 操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(context.Context, model.Resource, ...CreateOptionsFunc) error</span><br><span class="line">    Update(context.Context, model.Resource, ...UpdateOptionsFunc) error</span><br><span class="line">    Delete(context.Context, model.Resource, ...DeleteOptionsFunc) error</span><br><span class="line">    Get(context.Context, model.Resource, ...GetOptionsFunc) error</span><br><span class="line">    List(context.Context, model.ResourceList, ...ListOptionsFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>在 Kuma 中，ResourceStore 接口由 k8s、memory、postgres、remote 实现。其中：</p>
<ul>
<li><strong>K8s：</strong>在 Kubernetes 模式下，以 Kubernetes API Server 存储资源。</li>
<li><strong>Postgres：</strong>在 Universal 模式下，以 PostgreSQL 作为底层数据库存储数据。</li>
<li>Memory：内存数据库，用于测试。</li>
<li>Remote：为 kuma-ctl 做资源存储，负责以 HTTP Restful API 的方式操作 kuma-cp。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── k8s</span><br><span class="line">├── memory</span><br><span class="line">├── postgres</span><br><span class="line">└── remote</span><br></pre></td></tr></table></figure>

<h2 id="CustomizableResourceStore"><a href="#CustomizableResourceStore" class="headerlink" title="CustomizableResourceStore"></a>CustomizableResourceStore</h2><p>Customizable Resource Store 为<strong>某一种具体的资源</strong>提供<strong>定制化</strong>的 Resource Store：</p>
<ul>
<li><strong>Customize 方法：</strong>为 model.ReourceType 类型的资源<strong>指定</strong>资源存储器。</li>
<li><strong>ResourceStore 方法：</strong>返回 model.ResourceType 类型的资源存储器，如果没有该类型，则会返回默认的资源存储器。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceStoreWrapper is a function that takes a ResourceStore and returns a wrapped ResourceStore.</span></span><br><span class="line"><span class="comment">// The wrapped ResourceStore can be used to modify or augment the behavior of the original ResourceStore.</span></span><br><span class="line"><span class="keyword">type</span> ResourceStoreWrapper = <span class="function"><span class="keyword">func</span><span class="params">(delegate ResourceStore)</span> <span class="title">ResourceStore</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomizableResourceStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    ResourceStore</span><br><span class="line">    ResourceStore(typ model.ResourceType) ResourceStore</span><br><span class="line">    DefaultResourceStore() ResourceStore</span><br><span class="line">    Customize(typ model.ResourceType, store ResourceStore)</span><br><span class="line">    WrapAll(wrapper ResourceStoreWrapper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Resource-Manager"><a href="#Resource-Manager" class="headerlink" title="Resource Manager"></a>Resource Manager</h1><h2 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h2><p>Resource Manager 用于对资源（Zone、Dataplain 等）进行操作，定义的方法与 Resource Store 差不多，都是增删改查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadOnlyResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(context.Context, model.Resource, ...store.GetOptionsFunc) error</span><br><span class="line">    List(context.Context, model.ResourceList, ...store.ListOptionsFunc) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadOnlyResourceManager</span><br><span class="line">    Create(context.Context, model.Resource, ...store.CreateOptionsFunc) error</span><br><span class="line">    Update(context.Context, model.Resource, ...store.UpdateOptionsFunc) error</span><br><span class="line">    Delete(context.Context, model.Resource, ...store.DeleteOptionsFunc) error</span><br><span class="line">    DeleteAll(context.Context, model.ResourceList, ...store.DeleteAllOptionsFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CustomizableResourceManager"><a href="#CustomizableResourceManager" class="headerlink" title="CustomizableResourceManager"></a>CustomizableResourceManager</h2><p>Customizable Resource Manager 为<strong>某一种具体的资源</strong>提供<strong>定制化</strong>的 Resource Manager：</p>
<ul>
<li><strong>Customize 方法：</strong>为 model.ReourceType 类型的资源<strong>指定</strong>资源管理器。</li>
<li><strong>ResourceManager 方法：</strong>返回 model.ResourceType 类型的资源管理器，如果没有该类型，则会返回默认的资源管理器。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceManagerWrapper = <span class="function"><span class="keyword">func</span><span class="params">(delegate ResourceManager)</span> <span class="title">ResourceManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomizableResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    ResourceManager</span><br><span class="line">    Customize(model.ResourceType, ResourceManager)</span><br><span class="line">    ResourceManager(model.ResourceType) ResourceManager</span><br><span class="line">    WrapAll(ResourceManagerWrapper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 kuma-cp 初始化 Resource Manager 时，会为<strong>每一种资源指定一种资源管理器</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeResourceManager</span><span class="params">(cfg kuma_cp.Config, builder *core_runtime.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    defaultManager := core_manager.NewResourceManager(builder.ResourceStore())</span><br><span class="line">    customizableManager := core_manager.NewCustomizableResourceManager(defaultManager, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.MeshType,</span><br><span class="line">       mesh_managers.NewMeshManager(</span><br><span class="line">          builder.ResourceStore(),</span><br><span class="line">          customizableManager,</span><br><span class="line">          builder.CaManagers(),</span><br><span class="line">          registry.Global(),</span><br><span class="line">          builder.ResourceValidators().Mesh,</span><br><span class="line">          cfg.Store.UnsafeDelete,</span><br><span class="line">          builder.Extensions(),</span><br><span class="line">       ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    rateLimitValidator := ratelimit_managers.RateLimitValidator&#123;</span><br><span class="line">       Store: builder.ResourceStore(),</span><br><span class="line">    &#125;</span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.RateLimitType,</span><br><span class="line">       ratelimit_managers.NewRateLimitManager(builder.ResourceStore(), rateLimitValidator),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    externalServiceValidator := externalservice_managers.ExternalServiceValidator&#123;</span><br><span class="line">       Store: builder.ResourceStore(),</span><br><span class="line">    &#125;</span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ExternalServiceType,</span><br><span class="line">       externalservice_managers.NewExternalServiceManager(builder.ResourceStore(), externalServiceValidator),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.DataplaneType,</span><br><span class="line">       dataplane.NewDataplaneManager(builder.ResourceStore(), builder.Config().Multizone.Zone.Name, builder.ResourceValidators().Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.DataplaneInsightType,</span><br><span class="line">       dataplaneinsight.NewDataplaneInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.ZoneType,</span><br><span class="line">       zone.NewZoneManager(builder.ResourceStore(), zone.Validator&#123;Store: builder.ResourceStore()&#125;, builder.Config().Store.UnsafeDelete),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.ZoneInsightType,</span><br><span class="line">       zoneinsight.NewZoneInsightManager(builder.ResourceStore(), builder.Config().Metrics.Zone),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ZoneIngressInsightType,</span><br><span class="line">       zoneingressinsight.NewZoneIngressInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ZoneEgressInsightType,</span><br><span class="line">       zoneegressinsight.NewZoneEgressInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cipher secret_cipher.Cipher</span><br><span class="line">    <span class="keyword">switch</span> cfg.Store.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> store.KubernetesStore:</span><br><span class="line">       cipher = secret_cipher.None() <span class="comment">// deliberately turn encryption off on Kubernetes</span></span><br><span class="line">    <span class="keyword">case</span> store.MemoryStore, store.PostgresStore:</span><br><span class="line">       cipher = secret_cipher.TODO() <span class="comment">// get back to encryption in universal case</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;unknown store type %s&quot;</span>, cfg.Store.Type)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> secretValidator secret_manager.SecretValidator</span><br><span class="line">    <span class="keyword">if</span> cfg.IsFederatedZoneCP() &#123;</span><br><span class="line">       secretValidator = secret_manager.ValidateDelete(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, secretName <span class="keyword">string</span>, secretMesh <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       secretValidator = secret_manager.NewSecretValidator(builder.CaManagers(), builder.ResourceStore())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.SecretType,</span><br><span class="line">       secret_manager.NewSecretManager(builder.SecretStore(), cipher, secretValidator, cfg.Store.UnsafeDelete),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.GlobalSecretType,</span><br><span class="line">       secret_manager.NewGlobalSecretManager(builder.SecretStore(), cipher),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    builder.WithResourceManager(customizableManager)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> builder.Config().Store.Cache.Enabled &#123;</span><br><span class="line">       cachedManager, err := core_manager.NewCachedManager(</span><br><span class="line">          customizableManager,</span><br><span class="line">          builder.Config().Store.Cache.ExpirationTime.Duration,</span><br><span class="line">          builder.Metrics(),</span><br><span class="line">          builder.Tenants(),</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       builder.WithReadOnlyResourceManager(cachedManager)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       builder.WithReadOnlyResourceManager(customizableManager)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cached-Manager"><a href="#Cached-Manager" class="headerlink" title="Cached Manager"></a>Cached Manager</h2><p>Cached Manager 实现了只读资源管理器 Read Only Resource Manager，为对资源的 Get 和 List 操作进行<strong>缓存</strong>（有过期时间）。</p>
<ul>
<li>delegate：底层 ReadOnlyResourceManager，若缓存未命中则会从底层只读资源管理器中读取数据，并记录在缓存中。</li>
<li><strong>cache：</strong>cached manager 的核心数据结构，用于缓存查询结果。key 为 <code>&lt;op&gt;:&lt;resource_type&gt;:&lt;ops.hashcode(resource_name+resource_mesh)&gt;:tenantID</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheKey := fmt.Sprintf(<span class="string">&quot;GET:%s:%s:%s&quot;</span>, res.Descriptor().Name, opts.HashCode(), tenantID)</span><br></pre></td></tr></table></figure>

<ul>
<li>mutexes：为每一个 key 单独加锁，保证每一个 k-v 都互斥访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cached version of the ReadOnlyResourceManager designed to be used only for use cases of eventual consistency.</span></span><br><span class="line"><span class="comment">// This cache is NOT consistent across instances of the control plane.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When retrieving elements from cache, they point to the same instances of the resources.</span></span><br><span class="line"><span class="comment">// We cannot do deep copies because it would consume lots of memory, therefore you need to be extra careful to NOT modify the resources.</span></span><br><span class="line"><span class="keyword">type</span> cachedManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    delegate ReadOnlyResourceManager</span><br><span class="line">    cache    *cache.Cache</span><br><span class="line">    metrics  *prometheus.CounterVec</span><br><span class="line"></span><br><span class="line">    mutexes  <span class="keyword">map</span>[<span class="keyword">string</span>]*sync.Mutex</span><br><span class="line">    mapMutex sync.Mutex <span class="comment">// guards &quot;mutexes&quot; field</span></span><br><span class="line">    tenants  multitenant.Tenants</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/" class="post-title-link" itemprop="url">Kuma学习笔记 (6) Inter CP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-30 16:40:46" itemprop="dateCreated datePublished" datetime="2024-01-30T16:40:46+08:00">2024-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma-cp 的 Intercp（Control Plane Intercommunication）组件用于 kuma 控制面之间的通信，旨在实现 kuma-cp 的<strong>水平扩展。</strong></p>
<p>kuma 的水平扩展包含三个方面：</p>
<ul>
<li><strong>Leader 选举机制：</strong>在 kuma 中，leader 选举机制非常简单，就是<strong>选择最新加入的 kuma-cp 节点作为 Leader</strong>。作为 Leader，会接收成员的心跳，并且定期监测超时的 kuma-cp 成员。</li>
<li><strong>心跳机制：</strong>作为成员，会定期向 Leader 发送心跳，表明自己还存活。</li>
<li><strong>EnvoyAdminServer：</strong>对于 Global Cp 的水平扩展多实例部署，会将 EnvoyAdmin 请求<strong>转发</strong>给 Leader Global Kuma-cp 执行。对于 Zone Cp 的水平扩展多实例部署，会在本实例执行对 envoy 发起 Admin 请求获取响应。</li>
</ul>
<blockquote>
<p>下文中的实例，表示 kuma-cp 水平扩展中的某一实例。</p>
</blockquote>
<blockquote>
<p>可以发现，kuma-cp 在水平扩展时，如果 leader 下线了<strong>没有自动故障切换机制</strong>，除非原来的 leader 再次上线或者有新的 kuma-cp 实例上线，leader 才会正常工作。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/29/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">Triple协议 (7) 应用级别的服务发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 19:52:09" itemprop="dateCreated datePublished" datetime="2024-01-29T19:52:09+08:00">2024-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/triple%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">triple协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在微服务架构中，如何感知后端服务实例的动态上下线，就是<strong>服务发现（Service Discovery）</strong>。业界比较有代表性的微服务框架如 SpringCloud、Dubbo 等都抽象了强大的动态地址发现能力，并且为了满足微服务业务场景的需求，绝大多数框架的地址发现都是基于自己设计的一套机制来实现。在 SpringCloud 中使用 Eureka 作为注册中心，Dubbo 通常采用 zookeeper 和 nacos 作为注册中心。注册中心不仅仅记录了 IP+Port，还包括微服务的元信息，如序列化类型，实例方法列表，各个方法级的定制化配置等。</p>
<p>服务发现包含三种角色：<strong>服务提供者（Provider）、服务消费者（Consumer）和注册中心（Registry）</strong>。不同框架之间的区别在于如何组织注册中心中的数据。</p>
<blockquote>
<p>dubbo中应用，服务和实例的概念区分：</p>
<p><strong>应用</strong>是一个独立的逻辑单元，一个应用可以包含多个<strong>服务</strong>，每个服务可以包含多个<strong>实例</strong>。</p>
</blockquote>
<h1 id="业界服务发现方式"><a href="#业界服务发现方式" class="headerlink" title="业界服务发现方式"></a>业界服务发现方式</h1><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 通过注册中心<strong>只同步了应用与实例地址</strong>，消费方可以基于实例地址与服务提供方建立链接，但是消费方对于如何发起 HTTP 调用（SpringCloud 基于 rest 通信）一无所知，比如对方有哪些 HTTP endpoint，需要传入哪些参数等。</p>
<p>RPC 服务这部分信息目前都是通过线下约定或离线的管理系统来协商的。这种架构的优缺点总结如下。</p>
<ul>
<li><strong>优势</strong>： 部署结构清晰、地址推送量小。</li>
<li><strong>缺点</strong>： 地址订阅需要指定应用名， provider 应用变更（拆分）需消费端感知；RPC 调用无法全自动同步。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/d6b81ecf9bf5b3d630cab1fb0059756f.png" alt="img"></p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo 通过注册中心<strong>同时同步了实例地址和 RPC 方法</strong>，因此其能实现 RPC 过程的自动同步，面向 RPC 编程、面向 RPC 治理，对后端应用的拆分消费端无感知，其缺点则是<strong>地址推送数量变大</strong>，和 RPC 方法成正比。</p>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/d4863add6a9031faa9dda73f23ff0fab.png" alt="img"></p>
<h2 id="Dubbo-Kubernetes"><a href="#Dubbo-Kubernetes" class="headerlink" title="Dubbo + Kubernetes"></a>Dubbo + Kubernetes</h2><p>Kubernetes Service 作为一个抽象概念，怎么映射到 Dubbo 是一个值得讨论的点。</p>
<ol>
<li><strong>Service Name - &gt; Application Name：</strong>Dubbo 应用和 Kubernetes 服务一一对应，对于微服务运维和建设环节透明，与开发阶段解耦（对应于应用服务发现）。</li>
<li><strong>Service Name - &gt; Dubbo RPC Service：</strong>维护的 Service 数量变多，一个 Dubbo 应用可以运行多个接口，即一个 Dubbo 应用可以创建多个 Kubernetes Service（如 dubbo-app-service-1，dubbo-app- service-2 等）。</li>
</ol>
<h1 id="Dubbo-3-服务发现"><a href="#Dubbo-3-服务发现" class="headerlink" title="Dubbo 3 服务发现"></a>Dubbo 3 服务发现</h1><h2 id="服务自省"><a href="#服务自省" class="headerlink" title="服务自省"></a>服务自省</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>以 Dubbo 之前的地址发现数据格式为例，它是“RPC 服务粒度”的，它是以 RPC 服务作为 key，以实例列表作为 value 来组织数据的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;RPC Service1&quot;</span>: [  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance1&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">1000</span>&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance2&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">2000</span>&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance3&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">3000</span>&#125;&#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;RPC Service2&quot;</span>: [Instance list of RPC Service2],</span><br><span class="line"><span class="string">&quot;RPC ServiceN&quot;</span>: [Instance list of RPC ServiceN]</span><br></pre></td></tr></table></figure>

<p>而 Dubbo 3 中的服务发现，<strong>是“应用粒度的服务发现”</strong>，它以<strong>应用名（Application）作为 key</strong>，以<strong>这个应用部署的一组实例（Instance）列表作为 value</strong>。这带来两点不同：</p>
<ol>
<li>数据映射关系变了，从 RPC Service -&gt; Instance 变为 Application -&gt; Instance。</li>
<li><strong>数据变少了</strong>，注册中心没有了 RPC Service 及其相关配置信息。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;application1&quot;</span>: [</span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance1&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance2&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instanceN&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Dubbo 之前的服务发现粒度更细，在注册中心产生的数据条目也会更多（与 RPC 服务成正比），同时也存在一定的<strong>数据冗余</strong>。</p>
<p>接着解释<strong>它为什么会被叫做“服务自省”？</strong>其实这还是得从它的工作原理说起，上面提到，应用粒度服务发现的数据模型有几个以下明显变化：数据中心的数据量少了，RPC 服务相关的数据在注册中心没有了，现在只有 application - instance 这两个层级的数据。</p>
<p><strong>为了保证这部分缺少的 RPC 服务数据仍然能被 Consumer 端正确的感知</strong>，我们在 Consumer 和 Provider 间建立了一条单独的通信通道：Consumer 和 Provider 两两之间<strong>通过特定端口交换信息</strong>，我们把这种 Provider 自己<strong>主动暴露自身信息的行为</strong>认为是一种内省机制，因此整个机制命名为：服务自省。</p>
<h3 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h3><p>为什么需要服务自省，这会带来以下优势：</p>
<ol>
<li><strong>与业界主流微服务模型对齐</strong>，比如 SpringCloud、Kubernetes Service 等。</li>
<li><strong>提升性能与可伸缩性</strong>。<ul>
<li>注册中心的数据减少了，<strong>大幅度的减轻注册中心的存储、推送压力</strong>，进而减少 Dubbo Consumer 侧的地址计算压力。</li>
<li><strong>服务发现的数据规模，以及集群规模</strong>也开始变得<strong>可预测、可评估</strong>（与 RPC 接口数量无关，只与实例部署规模相关）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>根据统计，平均情况下 Consumer 订阅的 3 个接口来自同一个 Provider 应用，如此计算下来，如果以应用粒度为地址通知和选址基本单位，则平均地址推送和计算量将下降 60% 还要多。而在极端情况下，也就是当 Consumer 端消费的接口更多的来自同一个应用时，这个地址推送与内存消耗的占用将会进一步得到降低，甚至可以超过 80% 以上。</p>
<p>典型的例子是 API 网关，可能一个 API 网关有几十个甚至上百个定义的服务。</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>以下是服务自省的一个完整工作流程图，详细描述了服务注册、服务发现、MetadataService、RPC 调用间的协作流程。</p>
<ul>
<li>服务提供者启动，首先解析应用<strong>定义的“普通服务”并依次注册为 RPC 服务</strong>，紧接着<strong>注册内建的 MetadataService 服务</strong>，最后打开 TCP 监听端口。</li>
<li>启动完成后，<strong>将实例信息注册到注册中心（仅限 ip、port 等实例相关数据）</strong>，提供者启动完成。</li>
<li>服务消费者启动，首先依据其要<strong>“消费的 provider 应用名”</strong>到注册中心查询地址列表，并完成<strong>订阅</strong>（以实现后续地址变更自动通知）。</li>
<li>消费端拿到地址列表后，紧接着<strong>对 MetadataService 发起调用</strong>，返回结果中包含了<strong>所有应用定义的“普通服务”及其相关配置信息</strong>。</li>
<li>至此，消费者可以接收外部流量，并对提供者<strong>发起 Dubbo RPC 调用</strong>。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/bf45f69f7a9fcb04e085be062481bba9.png" alt="img"></p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>接口级服务发现的好处是数据量小，但是<strong>接口粒度的服务治理能力还是要继续保留</strong>。这就需要两点设计原则：</p>
<ol>
<li>新的服务发现模型要实现对原有 Dubbo 消费端开发者的<strong>无感知迁移</strong>，即 Dubbo 继续面向 RPC 服务编程、面向 RPC 服务治理，做到对用户侧完全无感知。</li>
<li>建立 Consumer 与 Provider 间的<strong>自动化 RPC 服务元数据协调机制</strong>，解决传统微服务模型无法同步 RPC 级接口配置的缺点。</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><strong>注册中心的数据组织方式：</strong>以应用名为 key，实例列表为 value 组织数据。元数据只包含实例级别的元数据，不包含接口级别的元数据。注册中心的一个实例条目如下，仅仅包含实例地址，端口，实例级别的元数据信息等基本信息。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;provider-app-name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;192.168.0.102:20880&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.0.102&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;port&quot;</span>: <span class="number">20880</span>,</span><br><span class="line">  <span class="attr">&quot;sslPort&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;payload&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;provider-app-name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;metadataService&quot;</span>: <span class="string">&quot;&#123;\&quot;dubbo\&quot;:&#123;\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;dubbo\&quot;:\&quot;2.0.2\&quot;,\&quot;release\&quot;:\&quot;2.7.5\&quot;,\&quot;port\&quot;:\&quot;20881\&quot;&#125;&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;endpoints&quot;</span>: <span class="string">&quot;[&#123;\&quot;port\&quot;:20880,\&quot;protocol\&quot;:\&quot;dubbo\&quot;&#125;]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage-type&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;revision&quot;</span>: <span class="string">&quot;6785535733750099598&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registrationTimeUTC&quot;</span>: <span class="number">1583461240877</span>,</span><br><span class="line">  <span class="attr">&quot;serviceType&quot;</span>: <span class="string">&quot;DYNAMIC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;uriSpec&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>服务调用者和提供者自行协商 RPC 方法信息。</strong>在注册中心不再同步 RPC 服务信息后，服务自省在服务消费端和提供端之间建立了一条内置的 RPC 服务信息协商机制。<strong>服务端实例会暴露一个预定义的 MetadataService RPC 服务</strong>，消费端通过调用 MetadataService 获取每个实例 RPC 方法相关的配置信息。当前 MetadataService 返回的数据格式如下：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span>, </span><br><span class="line"> <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.HelloService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.WorldService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h2><h3 id="元数据同步机制"><a href="#元数据同步机制" class="headerlink" title="元数据同步机制"></a>元数据同步机制</h3><p>Client 与 Server 间在收到地址推送后的配置同步是服务自省的关键环节，目前针对元数据同步有两种具体的可选方案，分别是：</p>
<ul>
<li><strong>内建的 MetadataService 服务</strong>。</li>
<li><strong>独立的元数据中心</strong>，通过中心化的元数据集群协调数据。Provider 实例启动后，会尝试将内部的 RPC 服务组织成元数据的格式到元数据中心，而 consumer 则在每次收到注册中心推送更新后，主动查询元数据中心。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/cef0a9b33a8f710d00e048fc7868925a.png" alt="img"></p>
<h3 id="RPC-服务与应用之间的映射关系"><a href="#RPC-服务与应用之间的映射关系" class="headerlink" title="RPC 服务与应用之间的映射关系"></a>RPC 服务与应用之间的映射关系</h3><p><strong>从服务粒度到应用粒度</strong>，要想用户完全无感知必须<strong>知道 RPC 服务与应用名之间的映射关系</strong>。所以为了使整个开发流程对老的 Dubbo 用户更透明，同时避免指定 provider 对可扩展性带来的影响，设计了一套 RPC 服务到应用名的映射关系，以尝试在 consumer 自动完成 RPC 服务到 provider 应用名的转换。</p>
<ul>
<li>consumer 通过配置中心<strong>以服务名查询应用名</strong>。</li>
<li>consumer 得到应用名，就可以检索注册中心，进行应用级别的服务发现了。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/3ab172dd6153a031b4f65e034d9a03f0.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">用户增长 Marketing-API重构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 13:57:27" itemprop="dateCreated datePublished" datetime="2024-01-29T13:57:27+08:00">2024-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">用户增长体系</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          这是一篇加密文章，需要密码才能继续阅读
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Kuma学习笔记 (5) 网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-25 12:53:28" itemprop="dateCreated datePublished" datetime="2024-01-25T12:53:28+08:00">2024-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>本节介绍 kuma 如何处理 service mesh 中的服务发现问题，包括数据平面代理和控制平面之间的通信，控制平面代理间的通信。</p>
<h2 id="数据平面代理和控制平面之间的通信"><a href="#数据平面代理和控制平面之间的通信" class="headerlink" title="数据平面代理和控制平面之间的通信"></a>数据平面代理和控制平面之间的通信</h2><p>当数据平面代理连接到控制平面时，它会<strong>启动到控制平面的 gRPC 流连接（xDS）</strong>。它从控制平面<strong>检索最新的策略配置</strong>并向控制平面发送诊断信息。</p>
<ul>
<li>在<strong>独立部署</strong>下，kuma-dp 直接连接到 kuma-cp 实例。</li>
<li>在<strong>多区域部署</strong>下，<strong>kuma-dp 连接到 zone kuma-cp，zone kuma-cp 将通过 KDS 的 xDS API 扩展连接到 global kuma-cp</strong>。在多区域模式下，数据平面代理永远不会连接到全局控制平面，而仅连接到区域控制平面。</li>
</ul>
<blockquote>
<p><strong>数据平面和控制平面之间的连接不在服务请求的执行路径上</strong>，这意味着如果数据平面暂时失去与控制平面的连接，服务流量不会受到影响。</p>
</blockquote>
<h2 id="数据平面代理间的通信"><a href="#数据平面代理间的通信" class="headerlink" title="数据平面代理间的通信"></a>数据平面代理间的通信</h2><p>数据平面会<strong>通报每一个服务的 IP 地址：</strong></p>
<ul>
<li>在 Kubernetes 环境中，IP 地址<strong>为 Pod 的地址</strong>。</li>
<li>在 Universal 环境中，IP地址会<strong>检索 inbound listeners</strong>（用于配置控制平面代理的入站监听地址）。</li>
</ul>
<p>数据平面会通报 IP 地址到控制平面，这意味着在任何时间 kuma-cp 都知道每一个服务的每个副本关联的所有 IP 地址是什么。</p>
<p>Kuma 数据平面代理间的通信，在独立部署和多区域部署使用自己的 DNS：</p>
<ul>
<li>在<strong>独立部署</strong>模式下，直接<strong>使用 IP 地址</strong>进行通信。</li>
<li>在<strong>多区域部署</strong>模式下，Kuma 将自动<strong>解析域名</strong>，可以连接到在同一区域中运行的数据平面代理，或者通过 Egress（如果存在）和 另一个区域中的 Ingress 的地址 来实现跨区域连接。这意味着多区域部署模式下，<strong>服务之间可以跨集群</strong>（不管是 Kubernetes 还是 VM）连接。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>对于每一份服务，都会生成一个以 <code>.mesh</code> 结尾的域名：</p>
<ul>
<li><p>对于一个 Kubernetes Service 和关联的 Pod，Kuma 控制面会自动的生成一个注解 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc_&lt;port&gt;</code>，其中 name 和 namespace 还有 port 均来自 Service 信息。</p>
</li>
<li><p>某些情况下 Pods 不属于任何的 Service，仅仅是单纯的一个 Pod（或者在 Universal 下）。在这种情况下，Kuma 会自动生成的注解为 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc</code> ，其中 name 和 namespace 来自于 Pod 资源。</p>
</li>
</ul>
<p>服务的域名被定义为 <code>&lt;kuma.io/service的值&gt;.mesh</code>，默认端口为 80。</p>
<h1 id="非-mesh-流量"><a href="#非-mesh-流量" class="headerlink" title="非 mesh 流量"></a>非 mesh 流量</h1><h2 id="传入流量"><a href="#传入流量" class="headerlink" title="传入流量"></a>传入流量</h2><p>启用 mTLS 后，来自网格外部的客户端无法访问网格内部的应用程序。如果想允许外部客户端使用服务网格，可以使用 Permissive mTLS 模式（宽松的 mTLS，即允许 mTLS，也允许明文请求）。</p>
<p>所有域名查找均由数据平面代理在本地处理，而不是由控制平面处理。这种方法允许更稳健地处理名称解析，例如，当控制平面关闭时，数据平面代理仍然可以解析 DNS。</p>
<p>数据平面代理 DNS 包括：</p>
<ul>
<li>Envoy DNS 过滤器提供来自网格的 DNS 记录响应。</li>
<li>CoreDNS 用于 Envoy DNS 过滤器和原始主机 DNS 之间发送请求</li>
<li>iptable 规则将原始 DNS 流量重定向到本地 CoreDNS 实例。</li>
</ul>
<h2 id="穿出流量"><a href="#穿出流量" class="headerlink" title="穿出流量"></a>穿出流量</h2><p>在默认设置中，Kuma 允许任何非网状流量通过 Envoy，而无需应用任何策略。当 <code>networking.outbound.passthrough</code> 为 <code>false</code> 时，任何非网格资源的流量都不能离开网格。</p>
<p>使用 ProxyTemplate，可以设置非 mesh 流量的配置。如断路器，超时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">369</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
