<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/13/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-4-%E7%B4%A2%E5%BC%95%E5%92%8C%E5%85%B3%E7%B3%BB%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-4-%E7%B4%A2%E5%BC%95%E5%92%8C%E5%85%B3%E7%B3%BB%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">MongoDB学习 (4) 索引和关系引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 16:54:46" itemprop="dateCreated datePublished" datetime="2023-08-28T16:54:46+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MongoDB学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>MongoDB 支持建立索引，索引可以建立在一个或者多个字段上。并且由于索引是在内存中的，所以查询效率很高。但是在写操作时，由于还需要维护索引，所以写操作的效率会有所降低。</p>
<blockquote>
<p>MongoDB 索引的数据结构<strong>是 B 树</strong>。</p>
</blockquote>
<h2 id="索引覆盖查询"><a href="#索引覆盖查询" class="headerlink" title="索引覆盖查询"></a>索引覆盖查询</h2><p><strong>索引覆盖查询</strong>就是之间在索引上查询并返回结果，不需要在磁盘上扫描结果。索引覆盖查询需要满足以下条件：</p>
<ul>
<li>索引字段包含了查询条件中的所有字段。</li>
<li>查询条件中只包含索引字段，不包含其他字段。</li>
<li>查询结果只需要索引字段的值，不需要其他字段的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users有三个字段name，gender，email</span></span><br><span class="line"><span class="comment">// 在name和gender字段上建立索引</span></span><br><span class="line"><span class="comment">// 仅仅查询gender字段，没有排除_id，查询就不会被覆盖</span></span><br><span class="line">db.users.find(&#123;<span class="attr">gender</span>:<span class="string">&quot;M&quot;</span>&#125;,&#123;<span class="attr">user_name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于索引覆盖查询来说，不会去数据库文件中去查找，而是<strong>在索引中直接提取数据</strong>。</p>
</blockquote>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>在 MongoDB 中，可以表示一对一、一对多、多对一、多对多关系。</p>
<p>对于一对多关系，可以有两种方法：</p>
<ul>
<li><strong>嵌入完整的文档：</strong>在更新时需要非常的小心，需要同时更新所有嵌入的完整文档。同时冗余数据多，数据量不断变大，会影响读写性能。</li>
<li><strong>关系引用：</strong>通过引用文档的 _id 字段来建立关系。也就是说，MongoDB 支持在文档中引用其他文档。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在 MongoDB 中，数据库引用有两种方式：手动引用和DBRefs。</p>
<p>手动引用就是直接去在对应的字段中记录 _id 信息。</p>
<p>DBRefs 的形式为 <code>&#123; $ref : , $id : , $db :  &#125;</code>。三个字段表示的意义如下：</p>
<ul>
<li>$ref：集合名称。</li>
<li>$id：引用的 _id。</li>
<li>$db：引用的数据库名称，可选参数。</li>
</ul>
<blockquote>
<p>因为 DBRefs 可以指定引用的 id 和数据库名称，所以更加相比于手动引用更加规范和灵活。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-3-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-3-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/" class="post-title-link" itemprop="url">MongoDB学习 (3) 复制和分片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 15:57:24" itemprop="dateCreated datePublished" datetime="2023-08-28T15:57:24+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MongoDB学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>
<p>MongoDB 的数据复制至少需要两个节点，<strong>一个主节点，其余的节点为从节点（称为副本集）</strong>。主节点记录在其上的所有操作 oplog，<strong>从节点定期轮询</strong>主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<p><img src="/../images/MongoDB%E5%AD%A6%E4%B9%A0-3-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/replication.png" alt="MongoDB复制结构图"></p>
<p>在 MongoDB 中，副本集中所有的<strong>写操作都在主节点上进行</strong>，任何一个节点都可以称为主节点，并且可以<strong>自动故障转移</strong>和<strong>自动恢复</strong>。</p>
<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>在 MongoDB 中也可以进行分片，分片可以提高数据的吞吐量。一个分片集群结构如下，包含三个部分：</p>
<ul>
<li><strong>Shard：</strong>用于存储实际的数据块，实际生产环境中一个 shard server 角色可由几台机器组成个一个 replica set 承担，防止主机单点故障。</li>
<li><strong>Config Server：</strong>MongoDB服务器实例，存储了整个集群的元信息。</li>
<li><strong>Query Routers：</strong>客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</li>
</ul>
<p><img src="/../images/MongoDB%E5%AD%A6%E4%B9%A0-3-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/sharding.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-2-%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9B%86%E5%90%88-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-2-%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9B%86%E5%90%88-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">MongoDB学习 (2) 数据库 集合 文档操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 14:51:23" itemprop="dateCreated datePublished" datetime="2023-08-28T14:51:23+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MongoDB学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在 MongoDB 中，使用 use 命令并且插入一条数据，就可以完成创建一个数据库了。</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>使用 db.dropDatabase() 删除数据库。</p>
<h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>在 MongoDB 中，当插入文档时会<strong>自动</strong>的创建集合。</p>
<p>使用 createCollection 方法显式的创建集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(name, options)</span><br></pre></td></tr></table></figure>

<p>options 可以是如下参数：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">capped</td>
<td align="left">布尔</td>
<td align="left">（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 <strong>当该值为 true 时，必须指定 size 参数。</strong></td>
</tr>
<tr>
<td align="left">autoIndexId</td>
<td align="left">布尔</td>
<td align="left">3.2 之后不再支持该参数。（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">数值</td>
<td align="left">（可选）为固定集合指定一个最大值，即字节数。 <strong>如果 capped 为 true，也需要指定该字段。</strong></td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">数值</td>
<td align="left">（可选）指定固定集合中包含文档的最大数量。</td>
</tr>
</tbody></table>
<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>使用 db.COLLECTION_NAME.drop() 删除集合。</p>
<h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><p>MongoDB 针对文档，同样支持增删改查操作，这里特别说明一下查询文档。</p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>使用 db.COLLECTION_NAME.find 方法查询文档，find 内部可以填写查询条件。如果需要以易读的方式来读取数据，可以使用 pretty() 方法。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;</span><br><span class="line">	&quot;likes&quot;: &#123;$gt:50&#125;, </span><br><span class="line">	$or: [</span><br><span class="line">		&#123;&quot;by&quot;: &quot;xxx&quot;&#125;,</span><br><span class="line">		&#123;&quot;title&quot;: &quot;MongoDB学习&quot;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-2-%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9B%86%E5%90%88-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">MongoDB学习 (1) 基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 11:28:24" itemprop="dateCreated datePublished" datetime="2023-08-28T11:28:24+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MongoDB%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">MongoDB学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍-MongoDB"><a href="#介绍-MongoDB" class="headerlink" title="介绍 MongoDB"></a>介绍 MongoDB</h1><p>MongoDB 是一个由 C++ 编写的，<strong>分布式文档型数据库</strong>。在高负载的情况下，可以添加更多的节点，可以保证服务器性能。MongoDB 将数据存储为一个文档，数据结构由<strong>键值对</strong>构成，MongoDB 文档类似于 JSON 对象。字段值可以包含字面量，其他文档，数组及文档数组。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MongoDB 的特点是：</p>
<ul>
<li>支持索引，利用索引可以实现更快的排序。</li>
<li>支持数据分片和数据复制，也就是具备分布式能力。</li>
<li>支持 Map/Reduce，用于对数据进行批量的处理和聚合操作。</li>
<li>允许在服务器端执行 Javascript 脚本。</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在 mongodb 中，最基本的概念就是文档、集合、数据库。</p>
<table>
<thead>
<tr>
<th align="left">SQL术语/概念</th>
<th align="left">MongoDB术语/概念</th>
<th align="left">解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">database</td>
<td align="left">database</td>
<td align="left">数据库</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">collection</td>
<td align="left">数据库表/集合</td>
</tr>
<tr>
<td align="left">row</td>
<td align="left">document</td>
<td align="left">数据记录行/文档</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left">field</td>
<td align="left">数据字段/域</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">index</td>
<td align="left">索引</td>
</tr>
<tr>
<td align="left">table joins</td>
<td align="left"></td>
<td align="left">表连接，MongoDB不支持</td>
</tr>
<tr>
<td align="left">primary key</td>
<td align="left">primary key</td>
<td align="left">主键，MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/28/MongoDB%E5%AD%A6%E4%B9%A0-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/06/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">数据密集型应用系统设计 (5) 数据分区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-06 23:04:37" itemprop="dateCreated datePublished" datetime="2023-08-06T23:04:37+08:00">2023-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节首先会介绍数据集<strong>切分的方法</strong>，并讨论索引和分片的配合；然后将会讨论分片<strong>再平衡</strong>（rebalancing），集群节点增删会引起数据再平衡；最后，会探讨数据库如何将请求<strong>路由</strong>到相应的分片并执行。</p>
<h1 id="分片方法"><a href="#分片方法" class="headerlink" title="分片方法"></a>分片方法</h1><p>分片方法都是基于<strong>键值对</strong>的，键值对是数据的一种最通用、泛化的表示，其他种类数据库都可以转化为键值对表示：</p>
<ul>
<li>关系型数据库：primary key → row</li>
<li>文档型数据库：document id → document</li>
<li>图数据库：vertex id → vertex，edge id → edge</li>
</ul>
<p>所以数据分片的基本方法就是，首先<strong>将数据转化为键值对，然后进行分区</strong>。<strong>分片（Partition）</strong> 的本质是对数据集合的划分，可以分为两个步骤：</p>
<ul>
<li>对数据集进行<strong>逻辑</strong>划分。</li>
<li>将逻辑分片<strong>调度到物理节点</strong>上。</li>
</ul>
<p>本节介绍逻辑划分方法，分别是按照键范围分区和按键散列分区。</p>
<h2 id="按键范围分区"><a href="#按键范围分区" class="headerlink" title="按键范围分区"></a>按键范围分区</h2><p>将该连续的定义域进行切分，每个分区内可以按照关键字排序保存（SSLTable）。保存每个切分的上下界，在给出某个 Key 时，就能通过比较，定位其所在分区。</p>
<ul>
<li>按键范围分区<strong>好处</strong>在于可以进行<strong>快速的范围查询</strong>。</li>
<li><strong>坏处</strong>在于，数据分散<strong>不均匀</strong>，且容易造成<strong>热点</strong>。</li>
</ul>
<blockquote>
<p>比如关键字是时间戳，可能导致在近期的分区写入负载高，但是其他分区处于空闲状态。</p>
<p>解决方法就是使用除了时间戳以外的其他内容作为关键字的第一项，使用<strong>拼接主键</strong>的方式。</p>
</blockquote>
<h2 id="按键散列分区"><a href="#按键散列分区" class="headerlink" title="按键散列分区"></a>按键散列分区</h2><p>为了避免数据倾斜和读写热点，许多数据系统使用散列函数对键进行分区。</p>
<blockquote>
<p><strong>一致性哈希</strong>也是基于散列分区，它不仅解决了从键到分区的映射，也解决了分区到节点的映射。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/06/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/03/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-4-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/03/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-4-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">数据密集型应用系统设计 (4) 数据复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-03 11:16:25" itemprop="dateCreated datePublished" datetime="2023-08-03T11:16:25+08:00">2023-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节讨论主从复制、多主节点复制和无主节点复制。冗余复制有多个好处：</p>
<ul>
<li>降低延迟。</li>
<li>提高可用性。</li>
<li>提高读吞吐。</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote>
<p>主从复制需要注意因为读取不同从数据库、或者从数据库与主数据库的不同步，而造成的暂时不一致性。</p>
</blockquote>
<p>主从复制的原理如下：</p>
<ul>
<li><strong>指定某一个副本为主节点。</strong>当客户端写数据库时，必须将写请求发给主节点，主节点首先将新数据写入本地存储。</li>
<li><strong>其他副本为从节点。</strong>主节点将日志发送给所有的从节点，从节点收到日志后应用到本地存储。</li>
<li>客户端可以从主节点或者从节点中执行查询操作。</li>
</ul>
<blockquote>
<p>主从复制中，只有主节点是可写的，从节点仅可读。</p>
</blockquote>
<h2 id="同步复制-异步复制"><a href="#同步复制-异步复制" class="headerlink" title="同步复制 异步复制"></a>同步复制 异步复制</h2><p>复制分为同步复制和异步复制。</p>
<ul>
<li><strong>同步复制：</strong> 主节点发送消息，等待从节点响应。同步复制的优点是，从库保证有与主库一致的最新数据副本。缺点是，如果同步从库没有响应，主库就无法处理写入操作。</li>
<li><strong>异步复制：</strong>主节点发送消息，但不等待从节点的响应。异步复制的速度快、效率高，但是可能会出现数据丢失的情形。</li>
</ul>
<p>基于同步复制和异步复制的优缺点，所以通常情况下采用<strong>半同步复制</strong>。半同步复制就是有既有同步从节点（一个），又有异步从节点。当所有的同步从节点响应后完成写入操作。</p>
<h2 id="从节点的日志同步"><a href="#从节点的日志同步" class="headerlink" title="从节点的日志同步"></a>从节点的日志同步</h2><p>在新的从节点出现时，需要同步主节点中所有的数据。过程如下：</p>
<ul>
<li>在第一次同步时，主节点会给从节点发送某个时刻的一致性<strong>快照</strong>。</li>
<li>从节点同步快照后，此后的同步，就是<strong>增量</strong>拉取所有的数据变更。</li>
</ul>
<h2 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h2><p>在分布式系统中，任何节点都可能发生宕机。所以必须处理节点的宕机行为，保证集群的高可用。</p>
<h3 id="从库失效：追赶恢复"><a href="#从库失效：追赶恢复" class="headerlink" title="从库失效：追赶恢复"></a>从库失效：追赶恢复</h3><p>如果是从节点失效了，则恢复比较<strong>容易</strong>。从节点可以从日志中知道，在发生故障之前<strong>处理的最后一个事务</strong>。从库因此可以向主库请求<strong>同步之后的所有数据变更</strong>，直到追上主节点的数据。</p>
<h3 id="主库失效：故障切换"><a href="#主库失效：故障切换" class="headerlink" title="主库失效：故障切换"></a>主库失效：故障切换</h3><p>如果是主节点失效了，则恢复起来非常<strong>棘手</strong>。其中<strong>一个从库需要被提升为新的主库</strong>，并且需要重新配<strong>置客户端中主库的地址</strong>，其他从节点需要拉取新的主节点的数据变更，这个过程就是<strong>故障切换</strong>。</p>
<p>故障切换可以手动进行（通过数据库管理员），或者是自动进行。自动故障切换的过程如下：</p>
<ul>
<li><strong>确认主库失效。</strong>大多数系统只是简单使用 <strong>超时</strong>：节点频繁地相互来回传递<strong>心跳</strong>，并且如果一个节点在一段时间内没有响应，就认为它挂了。</li>
<li><strong>选择一个新的主库。</strong>通过<strong>选举过程</strong>（这是<strong>共识</strong>问题）来完成，或者可以由之前选定的<strong>控制器节点</strong>来指定新的主库。主库的<strong>最佳人选通常是拥有旧主库最新数据副本的从库</strong>。</li>
</ul>
<blockquote>
<p>故障切换回导致很多问题：</p>
<ul>
<li>如果采用<strong>异步复制</strong>，则可能出现写入操作<strong>丢失</strong>的情况。</li>
<li><strong>新老主节点数据冲突。</strong>新主副本在上位前没有同步完所有日志，旧主副本恢复后，可能会发现和新主副本数据冲突。</li>
<li>发生<strong>脑裂</strong>，集群内部出现多个主节点。</li>
<li><strong>超时阈值选取</strong>。如果超时阈值选取的过小，在不稳定的网络环境中可能会造成主副本频繁的切换。</li>
</ul>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/03/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-4-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/" class="post-title-link" itemprop="url">数据密集型应用系统设计 (3) 编码与演化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 20:37:15" itemprop="dateCreated datePublished" datetime="2023-08-02T20:37:15+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当数据 schema 发生变化时，意味着<strong>数据库</strong>和<strong>应用程序</strong>都会发生变化：</p>
<ul>
<li><strong>数据库：</strong>关系型数据库可以<strong>通过 ALTER 语句修改数据表结构</strong>。读时模式数据库不会强制模式，因此数据库可以包含在不同时间写入的<strong>新老数据格式的混合</strong>。</li>
<li><strong>应用程序：</strong>新旧版本的代码，以及新旧数据格式可能会在系统中同时共处。所以需要保持<strong>双向兼容性</strong>（后向兼容和前向兼容）。</li>
</ul>
<blockquote>
<p><strong>后向兼容通常不难实现：</strong>新代码的作者当然知道由旧代码使用的数据格式，因此可以显示地处理它。</p>
<p><strong>向前兼容性可能会更棘手</strong>，因为旧版的程序需要忽略新版数据格式中新增的部分。</p>
</blockquote>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>采用适当的编码（序列化和反序列化），可以应对新旧数据格式共存的情形。</p>
<h2 id="Json-和-XML"><a href="#Json-和-XML" class="headerlink" title="Json 和 XML"></a>Json 和 XML</h2><p>Json 和 XML 是文本格式的编码，具有人类可读性。但是因为其没有用 IDL 定义其格式、传输效率低等问题，而被人诟病。</p>
<blockquote>
<p>尽管可以对 Json（MessagePack、BSON 等）和 XML（WBXML、Fast Infoset 等）格式的数据进行<strong>二进制编码</strong>，但是相比于 Thrift 以及 Protobuf 等编码来说，节省的空间太小。</p>
</blockquote>
<h2 id="Thrift-和-ProtoBuf"><a href="#Thrift-和-ProtoBuf" class="headerlink" title="Thrift 和 ProtoBuf"></a>Thrift 和 ProtoBuf</h2><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p>Apache Thrift 需要用 IDL 进行定义：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span>       userName,</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> <span class="built_in">i64</span>          favoriteNumber,</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> list&lt;<span class="keyword">string</span>&gt; interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Thrift 有两种不同的二进制编码格式，分别称为BinaryProtocol 和 CompactProtocol</strong>，另外还有两种不同的基于 JSON 的编码格式。</p>
<p>在编码时与 Json 不同，<strong>不会记录字段名字只记录编号</strong>。</p>
<ul>
<li><strong>BinaryProtocol：</strong>每个字段都有一个类型注释，还可以根据需要指定长度。</li>
</ul>
<p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-2.png" alt="img"></p>
<ul>
<li><strong>CompactProtocol：</strong>在语义上等同于 BinaryProtocol，它通过将<strong>字段类型和标签号打包到单个字节中</strong>，并使用<strong>可变长度整数</strong>来实现（每个字节的最高位用来指示是否还有更多的字节来。）。</li>
</ul>
<p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/fig4-3.png" alt="img"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/" class="post-title-link" itemprop="url">数据密集型应用系统设计 (2) 存储与检索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 14:47:12" itemprop="dateCreated datePublished" datetime="2023-08-02T14:47:12+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>OLTP 数据库存储引擎的核心在于索引，所以介绍几种索引机制。</p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>假设我们的数据存储只是一个<strong>追加写入</strong>的文件（日志），最简单的索引策略就是：在内存中维护一个 hash map，记录键和文件偏移量的映射。</p>
<p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/fig3-1.png" alt="img"></p>
<h3 id="文件分段与压缩"><a href="#文件分段与压缩" class="headerlink" title="文件分段与压缩"></a>文件分段与压缩</h3><p>为了防止日志文件无限制的增长，可以采取<strong>文件分段</strong>和<strong>压缩</strong>的策略。</p>
<ul>
<li>将日志分为特定大小的段，当日志增长到特定大小时就关闭，开始写入一个新的段文件。</li>
<li>将段进行压缩，只保留每一个键最新的值。同样的，也可以把多个段的内容压缩合并到一起。</li>
</ul>
<p>每一个段都有自己的 hash map，将键映射到文件偏移量中。在查询时，从后向前检索每一个段的 hash map 即可。</p>
<blockquote>
<p>参考 Redis AOF 压缩的思路，在进行压缩时：</p>
<ul>
<li>首先<strong>记录位置</strong>，开启一个<strong>后台线程</strong>开始压缩位置<strong>之前</strong>的数据。</li>
<li>正常写入 AOF 文件，后台线程将压缩之后的数据写入一个<strong>新的 AOF 文件</strong>中。</li>
<li><strong>暂停写入</strong>，将开始压缩后写入的数据<strong>追加</strong>到新文件中，用新的 AOF 文件<strong>替换</strong>旧的 AOF 文件。</li>
</ul>
</blockquote>
<h3 id="崩溃恢复与并发控制"><a href="#崩溃恢复与并发控制" class="headerlink" title="崩溃恢复与并发控制"></a>崩溃恢复与并发控制</h3><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>数据库可能在追加写入文件时崩溃，所以需要包含<strong>校验和</strong>用于检测和忽略日志的损坏部分。</p>
<p>在数据库<strong>重新启动</strong>时，内存中的 hash map 将丢失。原则上需要重新顺序读取段文件来重新构建 hash map，但是如果段文件非常大这是十分耗时的。所以可以通过<strong>在磁盘上保存 hash map 的快照</strong>，用于快速加载到内存中。</p>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>由于写操作是以严格顺序的顺序附加到日志中的，所以常见的实现选择是<strong>只有一个写线程</strong>，但是可以有<strong>多个线程同时读取</strong>。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>哈希索引也有两个局限性：</p>
<ul>
<li><strong>哈希表必须全部放入内存</strong>。原则上可以在磁盘上维护哈希表，但是这样会有大量的<strong>随机 I/O</strong>，性能表现很难优秀。</li>
<li><strong>范围查询效率不高。</strong>范围查询必须顺序查找每一个键。</li>
</ul>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><h3 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h3><p>之前文件中的键值顺序为写入顺序，现在做出一个改变：键值对的顺序按照键进行排序，把这个格式称为<strong>排序字符串表（Sorted String Table，SSTable）</strong>。还要求每个键只在每个合并的段文件中出现<strong>一次</strong>（压缩过程已经保证）。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>SSTable 相比于哈希索引顺序写入的日志文件相比，有以下几个优势：</p>
<ul>
<li><strong>合并段是简单且高效的</strong>，即使文件大于可用内存。类似于<strong>归并</strong>算法，每一次合并只取几个段中的最小键值（遇到相同的键时只需要最新的，其他旧段中的丢弃）。</li>
<li><strong>不需要保存所有键的索引</strong>，因为键在文件中的存储是有序的，所以部分索引就可以知道键值对所在的区间。</li>
<li>对<strong>索引区间内的数据</strong>，在保存到磁盘之前可以进行<strong>压缩</strong>，这样节省了磁盘空间。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-1-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-1-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">数据密集型应用系统设计 (1) 数据模型与查询语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 10:42:06" itemprop="dateCreated datePublished" datetime="2023-08-02T10:42:06+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数据密集型应用系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常见数据模型"><a href="#常见数据模型" class="headerlink" title="常见数据模型"></a>常见数据模型</h1><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>关系模型是最常见，也是最著名的数据模型，SQL 就是基于关系模型的。</p>
<h3 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h3><p>关系型数据模型和编程语言对象之间是不匹配的，需要一个转换层，即对象关系映射（ORM）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库中的一个表 &lt;---&gt; 一个类</span><br><span class="line">表中的一条数据 &lt;---&gt; 类的一个对象</span><br><span class="line">表中的一个列 &lt;---&gt; 类中的一个字段（field）</span><br></pre></td></tr></table></figure>

<h3 id="一对多的关系"><a href="#一对多的关系" class="headerlink" title="一对多的关系"></a>一对多的关系</h3><p>在个人简历中，在工作经历一栏可能会有多个工作经历，并且可能有多段教育经历等<strong>一对多</strong>的关系。</p>
<p>这样的一对多关系，关系模型可以采用多种方式表示：</p>
<ul>
<li>在关系模型中，可以将工作经历、教育经历等放在<strong>单独的数据表</strong>中，并且使用<strong>外键</strong>引用。</li>
<li>如果<strong>关系型数据库支持</strong>结构化的 Json（MySQL、PostgreSQL）或者 XML（Oracle、SQL Server、PostgreSQL）数据格式，可以将这些多值数据存储在一个属性内，并且支持查询和索引。</li>
<li>将工作经历、教育经历<strong>编码为 Json 或者 XML 格式</strong>，存储在关系型数据库的<strong>文本列</strong>中，由<strong>应用程序解释</strong>其结构和内容。</li>
</ul>
<h2 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h2><p>使用文档型数据库，就可以天然的解决关系模型中的一对多问题。并且<strong>文档型</strong>数据库在<strong>读取一对多关系的数据</strong>上，具有更好的<strong>局部性</strong>。如果在<strong>关系模型</strong>中读取一份简历，要么执行<strong>多个查询</strong>，要么进行<strong>多表联结</strong>查询。而在<strong>文档型</strong>数据库中，所有的信息都在一个地方，<strong>一次查询</strong>就已经足够了。</p>
<p>但是，文档型数据库通常<strong>不支持数据联结</strong>操作，只能在应用层通过多次查询来模拟联结。</p>
<h3 id="多对一和多对多的关系"><a href="#多对一和多对多的关系" class="headerlink" title="多对一和多对多的关系"></a>多对一和多对多的关系</h3><p>在表示<strong>多对一</strong>和<strong>多对多</strong>的关系时，关系数据库和文档数据库的思想并<strong>没有根本的不同</strong>：相关项都由<strong>唯一的标识符引用</strong>。</p>
<ul>
<li>在<strong>关系</strong>模型中，这个唯一标识符为<strong>外键</strong>。</li>
<li>在<strong>文档</strong>模型中，被称为文档<strong>引用</strong>。</li>
</ul>
<blockquote>
<p>如果存在<strong>多对多</strong>关系，那么<strong>文档模型就不太适用</strong>了。</p>
<ul>
<li>可以通过<strong>反范式化来减少联结</strong>，但是需要在<strong>应用层做出额外的工作去保证数据的一致性</strong>。</li>
<li>也可以在<strong>应用层执行多次查询来模拟联结</strong>，但是这通常比数据库内的专用代码慢，使得文档型数据库<strong>应用程序代码复、性能差</strong>。</li>
</ul>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-1-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4-%E9%AB%98%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4-%E9%AB%98%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">软件架构设计读书笔记 (4) 高并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-29 14:07:32" itemprop="dateCreated datePublished" datetime="2023-06-29T14:07:32+08:00">2023-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">软件架构设计读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在高并发读的场景下，首先想到的就是加<strong>缓存</strong>。</p>
<ul>
<li><strong>本地缓存或者 Redis/Memcached 集中式缓存。</strong>在缓存时，注意缓存的一致性、以及缓存雪崩缓存击穿等问题。</li>
<li><strong>MySQL 的 Master/Slave。</strong>如果查询是多张表的联合查询结果，而不是 kv 对（当然也可以用 kv 来缓存，但缺点就是任何一张数据库表变化了，缓存都需要更新），可以采用 MySQL 的 Master/Slave 集群，<strong>通过 Slave 来分担读压力</strong>。</li>
<li><strong>CDN。</strong>对于<strong>静态文件</strong>，如图片、HTML、CSS、JS 等文件，可以采用 CDN 内容分发网络，CDN 的本质就是在<strong>传输链路上做就近缓存</strong>。</li>
</ul>
<h2 id="并发读"><a href="#并发读" class="headerlink" title="并发读"></a>并发读</h2><p>将串行操作改为<strong>并行</strong>操作是常用的优化策略。</p>
<ul>
<li><strong>异步 RPC。</strong>当查询的内容没有依赖关系时，可以采用异步 RPC 来减少查询时间。</li>
<li><strong>冗余请求。</strong>如果在集群中，每一个节点都可能以很小的概率出现调用延迟，可以对同一种请求<strong>发出多个冗余请求</strong>，取出最快的响应作为查询结果。</li>
</ul>
<h2 id="重写轻读"><a href="#重写轻读" class="headerlink" title="重写轻读"></a>重写轻读</h2><p>在查询数据时需要聚合数据的场景下，可以采用<strong>重写轻读</strong>的方式进行优化。重写轻读的思路，就是<strong>将聚合数据的操作，提前到写入数据时完成，查询的是已经聚合过的数据</strong>。</p>
<h3 id="推送-拉取"><a href="#推送-拉取" class="headerlink" title="推送 拉取"></a>推送 拉取</h3><p>比如某个用户需要获取他关注的人发的微博，可以分为两种获取方式：</p>
<ul>
<li><strong>推送：</strong>在用户发微博时，写入自己的数据库就成功返回。然后利用后台程序，把这条微博<strong>主动推送给所有粉丝的收件箱</strong>（可以采用 Redis 实现，收件箱可以是一个 list，记录被推送的微博）中。</li>
<li><strong>拉取：</strong>如果用户粉丝数量很大，那么推送给全部的粉丝这一操作本身就是十分耗时的。所以在查询时还可以<strong>主动的从数据库中拉取数据</strong>。</li>
</ul>
<blockquote>
<p>在实际应用中，可以采用<strong>推拉结合</strong>的方式。</p>
<p>对于<strong>粉丝数量少</strong>的用户，可以采用<strong>推送</strong>的方式。对于<strong>粉丝数量多</strong>的用户，只<strong>推送给在线粉丝</strong>，<strong>离线粉丝</strong>采用主动<strong>拉取</strong>的方式。</p>
<p>对于<strong>读取的一方</strong>，有的是推送给他的、有的是主动拉取的，返回查询结果时，需要把二者再<strong>聚合</strong>起来。</p>
</blockquote>
<h2 id="总结-CQRS"><a href="#总结-CQRS" class="headerlink" title="总结 - CQRS"></a>总结 - CQRS</h2><p>上述的方法本质上都是<strong>读写分离</strong>，也就是 CQRS（Command Query Responsibility Separation）。CQRS 的特点如下：</p>
<ul>
<li><strong>读写两侧可以采用不同的数据结构：</strong>在写入的一侧通常采用 MySQL 这类关系型数据库，可以采用分库分表缓解读压力。而在读的这一侧则根据业务需求选择合适的数据库。</li>
<li><strong>读和写的串联：</strong>可以在读写之间加入消息队列，来保证读写的<strong>最终一致性</strong>。</li>
</ul>
<p><img src="/../images/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4-%E9%AB%98%E5%B9%B6%E5%8F%91/image-20230629151531310.png" alt="image-20230629151531310"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4-%E9%AB%98%E5%B9%B6%E5%8F%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">415</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
