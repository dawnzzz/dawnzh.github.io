<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/13/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-7-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-7-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/" class="post-title-link" itemprop="url">Go语言高性能编程 (7) 编译优化——死码消除</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-27 21:27:25" itemprop="dateCreated datePublished" datetime="2023-03-27T21:27:25+08:00">2023-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="死码消除"><a href="#死码消除" class="headerlink" title="死码消除"></a>死码消除</h1><h2 id="什么是死码消除"><a href="#什么是死码消除" class="headerlink" title="什么是死码消除"></a>什么是死码消除</h2><p>死码消除（dead code elimination，DCE）是一种编译器优化技术，用处是<strong>在编译阶段去掉对程序运行结果没有任何影响的代码</strong>。</p>
<p>死码消除有很多<strong>好处</strong>：减小程序体积，程序运行过程中避免执行无用的指令，缩短运行时间。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="全局常量-vs-全局变量"><a href="#全局常量-vs-全局变量" class="headerlink" title="全局常量 vs 全局变量"></a>全局常量 vs 全局变量</h3><p>在某些情景下使用全局常量替换全局变量，性能可能会有很大的提升。</p>
<blockquote>
<p>在使用<strong>常量</strong>时，在某些情况下<strong>编译器可以直接得到计算结果</strong>，进而可以<strong>死码消除</strong>。</p>
<p>死码消除<strong>删除了不必要的分支和语句</strong>，不仅二编译后的<strong>二进制文件体积减小</strong>，而且因为可能<strong>少了一些判断分支的条件所以效率也会提升</strong>。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-7-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-6-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-6-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Go语言高性能编程 (6) 编译优化——逃逸分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-27 21:06:09" itemprop="dateCreated datePublished" datetime="2023-03-27T21:06:09+08:00">2023-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><p>Golang 程序会在两个地方分配内存：<strong>每一个 goroutine 的栈和全局堆</strong>。但是垃圾回收机制在栈和堆上的性能差异非常大：</p>
<ul>
<li><strong>在栈上分配时</strong>，函数执行<strong>结束时自动回收</strong>。在栈上分配和回收内存的<strong>开销很低</strong>，只需要 2 个 CPU 指令：PUSH 和 POP。</li>
<li><strong>在堆上分配时</strong>，在某个时间点上<strong>利用垃圾回收机制</strong>进行回收。在堆上分配内存，一个很大的额外开销则是垃圾回收，<strong>需要经过垃圾回收算法的计算才能回收堆上的对象</strong>。</li>
</ul>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>在函数内部声明变量时，需要知道这个变量分配在栈上还是堆上。</p>
<p>编译器决定内存分配位置的方式，就称之为<strong>逃逸分析</strong>。逃逸分析由编译器完成，作用于编译阶段。</p>
<h2 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h2><p>发生逃逸分析的场景：</p>
<ul>
<li>指针逃逸</li>
<li>interface{} 动态类型逃逸</li>
<li>栈空间不足</li>
<li>闭包</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-6-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Pool-Once-Cond/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Pool-Once-Cond/" class="post-title-link" itemprop="url">Go语言高性能编程 (5) 并发编程——Pool Once Cond</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-27 09:01:40" itemprop="dateCreated datePublished" datetime="2023-03-27T09:01:40+08:00">2023-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h1><p>sync.Pool 用于复用对象，sync.Pool 是<strong>可伸缩</strong>的，同时也是<strong>并发安全</strong>的，其大小仅受限于内存的大小。从 sync.Pool 中取出的值<strong>不一定每一次都会经过内存分配</strong>，可以<strong>复用之前已经创建过已有但是已经使用结束的对象</strong>。</p>
<blockquote>
<p>简单来说，就是<strong>保存和复用临时对象，减少内存分配，降低 GC 压力</strong>。</p>
</blockquote>
<p>sync.Pool 使用只需要知道三点即可：</p>
<ul>
<li>声明对象池时，需要<strong>指定 New 函数</strong>，对象池中没有对象时，将会调用 New 函数创建。</li>
<li>Get 用于从对象池中<strong>获取</strong>一个对象，Put 用于向对象池内<strong>放回</strong>一个对象。</li>
</ul>
<p>如果在需要频繁创建对象的场景下，sync.Pool 有两个<strong>优点</strong>：</p>
<ul>
<li><strong>节省了对象初始化的时间</strong>，因为每一次都不一定是新的对象所以可以在一定程度上节省对象初始化时间，提升了效率。</li>
<li><strong>节省内存分配</strong>，对象是可重用的，不必每一次都分配内存。</li>
</ul>
<h1 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h1><p>sync.Once 保证了<strong>只执行一次函数</strong>，常常用于<strong>单例模式</strong>，在前文中也可以用于关闭管道。sync.Once 仅提供了一个方法 Do，参数 f 是对象初始化函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h2><p>从 sync.Once 的功能可以想到，用于实现它需要两个部分：</p>
<ul>
<li><strong>一个标志判断是否已经执行了 Do</strong>，如果没有执行过 Do 则执行对象初始化函数。</li>
<li>线程安全，并发的判断是否已经执行了，如果没有则执行 Do 中定义的函数，所以需要<strong>互斥锁</strong>来实现。</li>
</ul>
<p>以下是 sync.Once 的源码实现，其中 Once 结构体包含两个字段：</p>
<ul>
<li>done 字段用于标记是否已经执行过。</li>
<li>m 字段为互斥锁。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/27/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Pool-Once-Cond/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/26/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93/" class="post-title-link" itemprop="url">Go语言高性能编程 (4) 并发编程——关闭通道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-26 22:00:21" itemprop="dateCreated datePublished" datetime="2023-03-26T22:00:21+08:00">2023-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>channel 的三种状态和操作结果：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">空值(nil)</th>
<th align="left">非空已关闭</th>
<th align="left">非空未关闭</th>
</tr>
</thead>
<tbody><tr>
<td align="left">关闭</td>
<td align="left">panic</td>
<td align="left">panic</td>
<td align="left">成功关闭</td>
</tr>
<tr>
<td align="left">发送数据</td>
<td align="left">永久阻塞</td>
<td align="left">panic</td>
<td align="left">阻塞或成功发送</td>
</tr>
<tr>
<td align="left">接收数据</td>
<td align="left">永久阻塞</td>
<td align="left">永不阻塞</td>
<td align="left">阻塞或者成功接收</td>
</tr>
</tbody></table>
<blockquote>
<p>在 select 中，如果<strong>其中的全部通道都被关闭</strong>，则<strong>一定不</strong>会执行 defaul 而是随机选择其中一个被关闭的 case 去执行。</p>
</blockquote>
<h1 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h1><blockquote>
<p><strong>通道关闭原则：</strong></p>
<p>一个常用的使用 Go 通道的原则是<strong>不要在数据接收方或者在有多个发送者的情况下关闭通道</strong>。换句话说，我们<strong>只应该让一个通道唯一的发送者关闭此通道</strong>。</p>
</blockquote>
<p>关闭 channel 的方法有以下几种方法。</p>
<h2 id="粗鲁的方法"><a href="#粗鲁的方法" class="headerlink" title="粗鲁的方法"></a>粗鲁的方法</h2><p>如果关闭已经关闭的通道，则会触发 panic，可以<strong>用 recover 使得程序回复正常</strong>。</p>
<p>这种方法违反了通道关闭原则，因为这种方法使得多个协程都可以关闭通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 一个函数的返回结果可以在defer调用中修改。</span></span><br><span class="line">			justClosed = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设ch != nil。</span></span><br><span class="line">	<span class="built_in">close</span>(ch)   <span class="comment">// 如果 ch 已关闭，将 panic</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="礼貌的方式"><a href="#礼貌的方式" class="headerlink" title="礼貌的方式"></a>礼貌的方式</h2><p><strong>使用 sync.Once 或者互斥锁</strong>来保证 channel 只被关闭一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">	C    <span class="keyword">chan</span> T</span><br><span class="line">	once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(mc.C)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 sync.Mutex 来关闭通道，维护一个布尔值来表示通道是否已经被关闭（需要用 sync.Mutex 保证互斥访问）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">	C      <span class="keyword">chan</span> T</span><br><span class="line">	closed <span class="keyword">bool</span></span><br><span class="line">	mutex  sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优雅的方式"><a href="#优雅的方式" class="headerlink" title="优雅的方式"></a>优雅的方式</h2><ul>
<li>情形一：<strong>M 个接收者和一个发送者</strong>，发送者通过关闭用来传输数据的通道来传递发送结束信号。</li>
<li>情形二：<strong>一个接收者和 N 个发送者</strong>，此唯一接收者通过关闭一个额外的信号通道来通知发送者不要再发送数据了。</li>
<li>情形三：<strong>M 个接收者和 N 个发送者</strong>，它们中的任何协程都可以让一个中间调解协程帮忙发出停止数据传送的信号。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/26/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">Go语言高性能编程 (3) 常用数据结构——空结构体和内存对齐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-23 11:46:05" itemprop="dateCreated datePublished" datetime="2023-03-23T11:46:05+08:00">2023-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h1><p>在 Golang 中<strong>空结构体不占据内存空间</strong>。因此可以有以下使用方法：</p>
<ul>
<li><strong>实现集合：</strong>map[string]struct{} 可以实现集合。</li>
<li><strong>用作通知 channel：</strong>当 channel 只用于进程同步（通知），不用做传递消息时，可以使用 chan struct{}。</li>
<li><strong>仅包含方法的结构体：</strong>结构体只包含方法，不包含任何的字段时（使用 int 或者 bool 都会浪费额外的内存）。</li>
</ul>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。<strong>内存对齐可以减少 CPU 的访存次数</strong>。</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/memory_alignment.png" alt="memory alignment"></p>
<h2 id="Golang-中的对齐"><a href="#Golang-中的对齐" class="headerlink" title="Golang 中的对齐"></a>Golang 中的对齐</h2><p>在 Golang 中，<code>unsafe</code> 标准库提供了 <code>Alignof</code> 方法，可以返回一个类型的对齐值（对齐倍数或者对齐数）。</p>
<p><strong>规定如下：</strong></p>
<ul>
<li>对于<strong>任意类型</strong>的变量 x，unsafe.Alignof(x) 至少为 1。</li>
<li>对于<strong>结构体</strong>变量 x，计算每一个字段 f 的对齐值，unsafe.Alignof(x) 为其中<strong>每一个字段对齐值的最大值</strong>。</li>
<li>对于<strong>数组型</strong>变量 x，unsafe.Alignof(x) 等于<strong>构成数组的元素类型的对齐值</strong>。</li>
<li><strong>空结构体</strong>占据空间为 0。</li>
</ul>
<h3 id="字段顺序影响占用空间"><a href="#字段顺序影响占用空间" class="headerlink" title="字段顺序影响占用空间"></a>字段顺序影响占用空间</h3><blockquote>
<p>在对内存特别敏感的结构体的设计上，可以<strong>通过调整字段的顺序，减少内存的占用</strong>。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-2-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94for-range%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-2-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94for-range%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">Go语言高性能编程 (2) 常用数据结构——for range的性能与反射的性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-23 09:06:10" itemprop="dateCreated datePublished" datetime="2023-03-23T09:06:10+08:00">2023-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="for-range-性能"><a href="#for-range-性能" class="headerlink" title="for range 性能"></a>for range 性能</h1><blockquote>
<p><strong>range 会拷贝遍历对象。</strong></p>
</blockquote>
<h2 id="range-实现原理"><a href="#range-实现原理" class="headerlink" title="range 实现原理"></a>range 实现原理</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><strong>遍历 slice 前</strong>会先<strong>获取 slice 的长度 len_temp 作为循环次数。获取被遍历对象的拷贝，作为 for_temp</strong>。</p>
<p>循环体中，每次循环会先获取元素值 value_temp，以及下标 index_temp 进行赋值。</p>
<blockquote>
<p>注意，在循环开始前就已经<strong>确定了循环次数</strong>、并且已经<strong>将遍历对象保存了下来</strong>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The loop we generate:</span></span><br><span class="line"><span class="comment">//   for_temp := range</span></span><br><span class="line"><span class="comment">//   len_temp := len(for_temp)</span></span><br><span class="line"><span class="comment">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span></span><br><span class="line"><span class="comment">//           value_temp = for_temp[index_temp]</span></span><br><span class="line"><span class="comment">//           index = index_temp</span></span><br><span class="line"><span class="comment">//           value = value_temp</span></span><br><span class="line"><span class="comment">//           original body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>遍历 map 时没有指定循环次数，只是<strong>移动遍历指针 hiter</strong>，当遍历指针的 key 为 nil 时则停止循环。</p>
<blockquote>
<p>map 底层使用 hash 表实现，<strong>插入数据位置是随机的</strong>，所以遍历过程中新插入的数据不能保证遍历到。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The loop we generate:</span></span><br><span class="line"><span class="comment">//   var hiter map_iteration_struct</span></span><br><span class="line"><span class="comment">//   for mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;</span></span><br><span class="line"><span class="comment">//           index_temp = *hiter.key</span></span><br><span class="line"><span class="comment">//           value_temp = *hiter.val</span></span><br><span class="line"><span class="comment">//           index = index_temp</span></span><br><span class="line"><span class="comment">//           value = value_temp</span></span><br><span class="line"><span class="comment">//           original body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channe l遍历是依次从 channel 中读取数据，读取前是不知道里面有多少个元素的。</p>
<p>如果 channel 中没有元素，则会阻塞等待，如果 channel 已被关闭，则会解除阻塞并退出循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The loop we generate:</span></span><br><span class="line"><span class="comment">//   for &#123;</span></span><br><span class="line"><span class="comment">//           index_temp, ok_temp = &lt;-range</span></span><br><span class="line"><span class="comment">//           if !ok_temp &#123;</span></span><br><span class="line"><span class="comment">//                   break</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//           index = index_temp</span></span><br><span class="line"><span class="comment">//           original body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>因为 range 会拷贝遍历对象，所以 for 和 range 的性能比较如下：</p>
<ul>
<li>每次迭代的元素的<strong>内存占用很低</strong>，<strong>那么 for 和 range 的性能几乎是一样</strong>。</li>
<li>如果迭代的元素<strong>内存占用较高</strong>，<strong>那么 for 的性能将显著地高于 range</strong>，因为 range 会拷贝迭代对象。可以考虑<strong>只迭代下标</strong>，这样和 for 的性能是<strong>一样</strong>的。</li>
<li>如果想使用 range 同时迭代<strong>下标和值</strong>，则可以将<strong>迭代元素修改为指针</strong>。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/23/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-2-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94for-range%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%A7%E8%83%BD/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/22/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-1-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%92%8Cslice%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-1-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%92%8Cslice%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">Go语言高性能编程 (1) 常用数据结构——字符串拼接和slice性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 17:27:56" itemprop="dateCreated datePublished" datetime="2023-03-22T17:27:56+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go语言高性能编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><h2 id="常见拼接方式"><a href="#常见拼接方式" class="headerlink" title="常见拼接方式"></a>常见拼接方式</h2><p>在 Golang 中，字符串拼接有以下几种拼接方式：</p>
<ul>
<li><strong>+：</strong>使用 + 直接对两个字符串进行拼接操作。</li>
<li><strong>fmt.Sprintf：</strong>使用 <code>fmt.Sprintf(&quot;&quot;%v%v&quot;, s1, s2)</code> 进行字符串的拼接。</li>
<li><strong>strings.Builder：</strong>使用 strings.Builder.WriteString  方法进行拼接。</li>
<li><strong>bytes.Buffer：</strong>使用 bytes.Bufer.WriteString 方法进行拼接。</li>
<li><strong>[]byte：</strong>使用 []byte，利用 append 函数进行拼接（可以预先分配空间）。</li>
</ul>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>利用 benchmark 基准测试进行性能比较，结果如下：</p>
<ul>
<li><code>+</code> 和 <code>fmt.Sprintf</code> 的<strong>效率是最低</strong>的，和其余的方式相比，性能相差约 1000 倍，而且消耗了超过 1000 倍的内存。</li>
<li><code>strings.Builder</code>、<code>bytes.Buffer</code> 和 <code>[]byte</code> 的性能<strong>差距不大</strong>，而且消耗的内存也十分接近，性能最好且消耗内存最小的是 <code>preByteConcat</code>，这种方式预分配了内存，在字符串拼接的过程中，不需要进行字符串的拷贝，也不需要分配新的内存，因此性能最好，且内存消耗最小。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkPlusConcat-8         19      56 ms/op   530 MB/op   10026 allocs/op</span><br><span class="line">BenchmarkSprintfConcat-8      10     112 ms/op   835 MB/op   37435 allocs/op</span><br><span class="line">BenchmarkBuilderConcat-8    8901    0.13 ms/op   0.5 MB/op      23 allocs/op</span><br><span class="line">BenchmarkBufferConcat-8     8130    0.14 ms/op   0.4 MB/op      13 allocs/op</span><br><span class="line">BenchmarkByteConcat-8       8984    0.12 ms/op   0.6 MB/op      24 allocs/op</span><br><span class="line">BenchmarkPreByteConcat-8   17379    0.07 ms/op   0.2 MB/op       2 allocs/op</span><br></pre></td></tr></table></figure>

<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>在进行字符串拼接时，推荐使用 strings.Builder 进行拼接字符串，<strong>并且 strings.Builder 也提供了预分配内存的方法 Grow</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">builderConcat</span><span class="params">(n <span class="keyword">int</span>, str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> builder strings.Builder</span><br><span class="line">	builder.Grow(n * <span class="built_in">len</span>(str))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		builder.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/22/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-1-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%92%8Cslice%E6%80%A7%E8%83%BD/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/22/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87-A-Unified-Multi-Task-Learning-Framework-for-Joint-Extraction-of-Entities-and-Relations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87-A-Unified-Multi-Task-Learning-Framework-for-Joint-Extraction-of-Entities-and-Relations/" class="post-title-link" itemprop="url">关系抽取论文 A Unified Multi-Task Learning Framework for Joint Extraction of Entities and Relations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 10:22:22" itemprop="dateCreated datePublished" datetime="2023-03-22T10:22:22+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">关系抽取论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>A Unified Multi-Task Learning Framework for Joint Extraction of Entities and Relations</strong></p>
<p>来源：AAAI 2021</p>
<p>作者：Tianyang Zhao, Zhao Yan, Yunbo Cao, Zhoujun Li</p>
<p>机构：State Key Lab of Software Development Environment, Beihang University, Beijing, China</p>
</blockquote>
<p>作者根据提取三元组的顺序将关系抽取模型分成了三类：</p>
<ul>
<li><strong>relation-last：</strong>可以被总结为先抽取出实体，然后对任意两个实体进行关系分类。这种方法的<strong>缺点</strong>就是需要枚举出所有的实体对进行关系判断，并且由非常多的负例影响了关系分类器。</li>
<li><strong>relation-first：</strong>首先检测出句子中可能包含的关系，然后在句子中选择关系对应的 subject 和 object。这种方法首先通过预测关系，过滤掉了不相关的关系，减轻了无用关系造成的负面影响，大大避免了数据不平衡的问题。</li>
<li><strong>relation-middle：</strong>首先提取出 subject，然后根据 subject 提取出 relation，最后提取出 object（典型的比如多轮次 QA，CasRel也属于这个方法）。在多轮次 QA 中，基于模板进行提问的，这样做的好处是：<ul>
<li>查询问题明确地提供了关于类型信息的先验知识。</li>
<li>基于 QA 结构，增强了查询与文本之间的交互作用。</li>
<li>它提供了一种处理重叠实体和关系的自然方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>但是，基于 QA 的方法由以下<strong>问题</strong>：</p>
<ul>
<li>严重依赖于手工设计的模板，这使得模型难以迁移。</li>
<li>目前主流的方法无法在非实体上识别出关系，严重依赖于 NER。</li>
<li>现有的方法无法处理非预定义的关系。</li>
</ul>
</blockquote>
<p>文章提出了一个实体关系联合抽取框架，将任务划分为了三个子任务：the type-attentional subject extraction，the subject-aware relation prediction（SRP），the QA-based object extraction。</p>
<ul>
<li>为了<strong>缓解模板依赖</strong>的问题，提出了 type-attention，为 subject 提取任务中提供明确的实体类型信息。</li>
<li>论文引入了 subject-aware relation prediction 任务，利用全局和局部语义获得了给定主体的关系子集。</li>
<li>论文提出了一种 question generation（QG）策略，以自动得到在 object 提取任务中的多种查询语句。这个子任务根据之前的类型信息和查询，在句子中选择文本跨度，而<strong>不依赖于 NER</strong>。此外，论文还提出了一种模糊问题回答方法，来<strong>解决非预定义的关系检测问题</strong>。</li>
</ul>
<p><img src="/../images/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87-A-Unified-Multi-Task-Learning-Framework-for-Joint-Extraction-of-Entities-and-Relations/image-20230322144531225.png" alt="image-20230322144531225"></p>
<h2 id="模型方法"><a href="#模型方法" class="headerlink" title="模型方法"></a>模型方法</h2><p>为了整合任务之间的相互作用，采用多任务学习的方式来提高整体的性能。基于 relation-middle 的方式，模型由三个部分组成：</p>
<ul>
<li><strong>type-attentional subject extraction：</strong>显式的提供类型信息，来从句子中预测 subject。</li>
<li><strong>subject-aware relation prediction：</strong>给定 subject，选择可能与 subject 相关关系的多分类问题。</li>
<li><strong>QA-based object extraction：</strong>使用自动生成的问题从句子中选择 object。</li>
</ul>
<p><img src="/../images/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87-A-Unified-Multi-Task-Learning-Framework-for-Joint-Extraction-of-Entities-and-Relations/image-20230322144550841.png" alt="image-20230322144550841"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/22/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E8%AE%BA%E6%96%87-A-Unified-Multi-Task-Learning-Framework-for-Joint-Extraction-of-Entities-and-Relations/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/21/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8BTimer%E5%92%8CTicker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/21/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8BTimer%E5%92%8CTicker/" class="post-title-link" itemprop="url">GO专家编程读书笔记 (6) 定时器之Timer和Ticker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-21 21:49:42" itemprop="dateCreated datePublished" datetime="2023-03-21T21:49:42+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go专家编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>Timer 指定一段时间后，通过本身提供的一个 channel 通知触发一个事件，Timer 只执行一次就结束。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Timer-1"><a href="#Timer-1" class="headerlink" title="Timer"></a>Timer</h3><p>Timer 有两个成员：</p>
<ul>
<li><strong>C：</strong>一个 channel，用于<strong>通知</strong>时间已经到达。</li>
<li><strong>r：</strong>runtime 定时器，该定时器即<strong>系统管理的定时器</strong>，对上层应用不可见。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123; <span class="comment">// Timer代表一次定时，时间到来后仅发生一个事件。</span></span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtimeTimer"><a href="#runtimeTimer" class="headerlink" title="runtimeTimer"></a>runtimeTimer</h3><p>创建一个 Timer 实质上是<strong>把一个定时任务交给专门的协程进行监控</strong>，这个任务的载体便是 runtimeTimer。<strong>创建一个 Timer 就是创建一个 runtimeTimer，把它交给系统进行监控</strong>，当 runtimeTimer 到期后像 Timer.C 管道中发送一个消息。</p>
<p>runtimeTimer 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> runtimeTimer <span class="keyword">struct</span> &#123;</span><br><span class="line">    tb <span class="keyword">uintptr</span>                          <span class="comment">// 存储当前定时器的数组地址</span></span><br><span class="line">    i  <span class="keyword">int</span>                              <span class="comment">// 存储当前定时器的数组下标</span></span><br><span class="line"></span><br><span class="line">    when   <span class="keyword">int64</span>                        <span class="comment">// 当前定时器触发时间</span></span><br><span class="line">    period <span class="keyword">int64</span>                        <span class="comment">// 当前定时器周期触发间隔</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span>   // 定时器触发时执行的函数</span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;                  <span class="comment">// 定时器触发时执行函数传递的参数一</span></span><br><span class="line">    seq    <span class="keyword">uintptr</span>                      <span class="comment">// 定时器触发时执行函数传递的参数二(该参数只在网络收发场景下使用)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>所有 Timer 中的 runtimeTimer 由统一的底层协程进行管理，这个协程是系统协程。</p>
<p><strong>系统协程把 runtimeTimer 存放在数组！！中</strong>，并按照 runtimeTimer.when 进行<strong>堆排序</strong>，定时器触发时<strong>执行预定义的函数 runtimeTimer.f</strong>，即完成了一次定时任务。</p>
<h3 id="创建-Timer"><a href="#创建-Timer" class="headerlink" title="创建 Timer"></a>创建 Timer</h3><p>创建 Timer 的过程：</p>
<ul>
<li>首先会<strong>初始化一个管道 C</strong>，用于通知上层应用。</li>
<li>接着会<strong>创建一个 runtimeTimer</strong>，并且调用 startTimer 启动定时器（由系统协程维护）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)  <span class="comment">// 创建一个管道</span></span><br><span class="line">    t := &amp;Timer&#123; <span class="comment">// 构造Timer数据结构</span></span><br><span class="line">        C: c,               <span class="comment">// 新创建的管道</span></span><br><span class="line">        r: runtimeTimer&#123;</span><br><span class="line">            when: when(d),  <span class="comment">// 触发时间</span></span><br><span class="line">            f:    sendTime, <span class="comment">// 触发后执行函数sendTime</span></span><br><span class="line">            arg:  c,        <span class="comment">// 触发后执行函数sendTime时附带的参数</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    startTimer(&amp;t.r) <span class="comment">// 此处启动定时器，只是把runtimeTimer放到系统协程的堆中，由系统协程维护</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when 方法用于计算下一次定时器触发的绝对时间，即当前时间 + d。</p>
<p>sendTime 方法用于定时器触发时，向管道 C 中发送当前时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTime</span><span class="params">(c <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.(<span class="keyword">chan</span> Time) &lt;- Now():</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 Timer 创建时，初始化了一个缓冲区长度为 1 的管道（<code>make(chan Time, 1)</code>），所以 Timer 触发时向管道写入时间永远不会阻塞，<strong>sendTime 写完即退出</strong>。</p>
<p><strong>之所以 sendTime 使用 select 并搭配一个空的 default 分支，是因为 Ticker 也复用 sendTime</strong>。Ticker 触发时也会向管道中写入时间，但无法保证之前的数据已被取走，所以使用 select 并搭配一个空的 default 分支，<strong>确保 sendTime 不会阻塞</strong>。Ticker 触发时，<strong>如果管道中还有值，则本次不再向管道中写入时间</strong>，本次触发的事件直接丢弃。</p>
</blockquote>
<p>startTimer 函数的主要作用就是<strong>将 runtimeTimer 写入到系统协程的数组中</strong>，并启动系统协程（如果系统协程还未开始运行的话）。</p>
<p><img src="/../images/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8BTimer%E5%92%8CTicker/m_9b30d59765c6121152602b693e73d48d_r.png" alt="img"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/21/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8BTimer%E5%92%8CTicker/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2023/03/19/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5-%E5%B8%B8%E8%A7%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/19/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5-%E5%B8%B8%E8%A7%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BContext/" class="post-title-link" itemprop="url">GO专家编程读书笔记 (5) 常见控制结构实现原理之Context</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-19 10:39:55" itemprop="dateCreated datePublished" datetime="2023-03-19T10:39:55+08:00">2023-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go专家编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Golang 中 Context 与 WaitGroup 最大的不同在于，<strong>Context 可以控制树形结构的 goroutine</strong>，每一个 goroutine 具有相同的上下文。</p>
<blockquote>
<p>由于 goroutine 派生出子 goroutine，而子 goroutine 又继续派生新的 goroutine。这种情况下使用 WaitGroup 就不太容易，因为<strong>子 goroutine 个数不容易确定</strong>，而使用 context 就可以很容易实现。</p>
</blockquote>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h2><p>Context 是一个接口，它定义了四个方法：</p>
<ul>
<li><strong>Deadline() (deadline time.Time, ok bool)：</strong>返回一个 deadline，和一个是否已经设置 deadline 的布尔值。</li>
<li><strong>Done() &lt;-chan struct{}：</strong>当 Context 被关闭后，返回的是一个被关闭的 channel；而没有关闭时，返回的是 nil。</li>
<li><strong>Err() error：</strong>当 Context 被关闭时，返回描述 Context 被关闭的原因；否则返回 nil。</li>
<li><strong>Value(key interface{}) interface{}：</strong>根据 key 查询 key 对应的 value，用于实现 ValueContext。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 context 包中，定义了一个空的 Context 用于作为其他 Context 父节点或者全局的根节点。并且还实现了四种不同类型的 Context：</p>
<ul>
<li><strong>Cancel Context：</strong>通过 WithCancel 创建。</li>
<li><strong>Deadline Context：</strong>通过 WithDeadline 创建。</li>
<li><strong>Timeout Context：</strong>通过 WithTimeout 创建。</li>
<li><strong>Value Context：</strong>通过 WithValue 创建。</li>
</ul>
<blockquote>
<p>context 包中，有<strong>四</strong>个结构体实现了 Context 接口：<strong>emptyCtx、cancelCtx、timerCtx、valueCtx</strong>。关系如下：</p>
<p><img src="/../images/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5-%E5%B8%B8%E8%A7%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BContext/m_f41adc85deafd7243fc1eb3e6c553ced_r.png" alt="img"></p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/19/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5-%E5%B8%B8%E8%A7%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BContext/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">369</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
