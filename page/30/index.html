<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/30/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/30/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/22/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-3-%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/22/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-3-%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">从零实现一个Web框架 (3) 前缀树路由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-22 22:04:16" itemprop="dateCreated datePublished" datetime="2022-05-22T22:04:16+08:00">2022-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--trie.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>利用前缀树（Trie 树）实现动态路由解析，并且支持 <code>:name</code> 和    <code>*filename</code> 两种模式。</p>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello, you are %v, URL path = %v&quot;</span>, name, c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/file/*filename&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		filename := c.Param(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">		c.JSON(http.StatusOK, dain.H&#123;</span><br><span class="line">			<span class="string">&quot;filename&quot;</span>: filename,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h1><p><code>dain/trie.go</code></p>
<p>在之前的版本种，使用了 map 来存储路由与处理函数的映射，但是这不能支持动态路由。</p>
<p>Trie 树（前缀树）可以实现动态路由，一个节点的所有子节点都有相同的前缀。</p>
<p><code>/:user/info</code>、<code>/:user/doc</code>、<code>/p/video</code>、<code>/p/book</code>、<code>/file/*filepath</code> 对应的前缀树如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                      /</span><br><span class="line">       _______________|______________</span><br><span class="line">      |               |              |</span><br><span class="line">    :user             p            file</span><br><span class="line">   ___|___         ___|___           |</span><br><span class="line">  |       |       |       |          |</span><br><span class="line">info     doc    video    book    *filepath		</span><br></pre></td></tr></table></figure>

<h2 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h2><p>首先需要知道前缀树的节点的结构。</p>
<p>其中，<code>matchChild</code> 匹配第一个节点，用于将剩余路由信息插入到匹配的节点之下。<code>matchChildren</code> 用于匹配所有的节点，用于查找请求的路径信息是否匹配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern  <span class="keyword">string</span>  <span class="comment">// 待匹配的路由，只在pattern定义的最后一个节点存储</span></span><br><span class="line">	part     <span class="keyword">string</span>  <span class="comment">// 路由中的一部分</span></span><br><span class="line">	children []*node <span class="comment">// 叶子节点</span></span><br><span class="line">	isWild   <span class="keyword">bool</span>    <span class="comment">// 若不是精确匹配则为 true；否则为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchChild 匹配第一个节点，用于插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChild</span><span class="params">(part <span class="keyword">string</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			<span class="keyword">return</span> child</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchChildren 匹配所有的节点，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChildren</span><span class="params">(part <span class="keyword">string</span>)</span> []*<span class="title">node</span></span> &#123;</span><br><span class="line">	children := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			children = <span class="built_in">append</span>(children, child)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入和搜索"><a href="#插入和搜索" class="headerlink" title="插入和搜索"></a>插入和搜索</h2><p>在<strong>添加路由</strong>时，需要在前缀树中<strong>插入</strong>节点。</p>
<p>在<strong>匹配路由</strong>时，需要<strong>查找</strong>当前请求的路径是否能匹配到节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insert</span><span class="params">(pattern <span class="keyword">string</span>, parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">		<span class="comment">// 到达叶子节点</span></span><br><span class="line">		<span class="comment">// 仅仅在pattern定义的最后一个节点存储</span></span><br><span class="line">		n.pattern = pattern</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	child := n.matchChild(part)</span><br><span class="line">	<span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 若当前层没有匹配，新建一个节点，并插入到孩子节点中</span></span><br><span class="line">		child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">		n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向下一层继续插入</span></span><br><span class="line">	child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search 查找节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">search</span><span class="params">(parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">// 到达叶子节点 或者 匹配到“*”</span></span><br><span class="line">		<span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">		<span class="comment">// 在下一层中继续查找</span></span><br><span class="line">		result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到节点</span></span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器 Router"></a>路由器 Router</h1><p><code>dain/router.go</code></p>
<h2 id="router-结构"><a href="#router-结构" class="headerlink" title="router 结构"></a>router 结构</h2><p>在 router 中记录前缀树的<strong>根节点 roots</strong>，用于记录和匹配路由；<strong>handlers</strong> 用于记录 pattern 和 HandlerFunc 的映射关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	roots    <span class="keyword">map</span>[<span class="keyword">string</span>]*node       <span class="comment">// 保存 trie 树的根，key为 Method，value为树根</span></span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc <span class="comment">// 保存 pattern 与 HandlerFunc 的映射关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*node),</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><p>因为增加了前缀树用来保存路由 pattern，所以需要在<strong>添加路由</strong>的同时在前缀树中<strong>插入</strong>节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parsePattern 解析 pattern，返回对应的 parts（路由中的一部分）</span></span><br><span class="line"><span class="comment">// 如 pattern 为 /hello/world，那么对应的 parts 为 []&#123;&quot;hello&quot;, &quot;world&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	parts := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(vs))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="comment">// 不为空，加入到 parts 中</span></span><br><span class="line">			parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line">			<span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="comment">// 遇到通配符直接退出</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Router %v - %v\n&quot;</span>, method, pattern)</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line"></span><br><span class="line">	_, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parts := parsePattern(pattern)</span><br><span class="line">	r.roots[method].insert(pattern, parts, <span class="number">0</span>) <span class="comment">// 插入到前缀树中</span></span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>添加一个函数 <strong>getRouter</strong> 用于查找对应的叶子节点和路由参数，并且重新实现 <strong>handle</strong> 路由功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getRoute 根据请求的 method 和 path，找到对应的前缀树叶子节点和路由参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">getRoute</span><span class="params">(method, path <span class="keyword">string</span>)</span> <span class="params">(*node, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	searchParts := parsePattern(path) <span class="comment">// 查找的 parts</span></span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	root, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 方法没有定义路由，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := root.search(searchParts, <span class="number">0</span>) <span class="comment">// 查找叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 可以找到</span></span><br><span class="line">		parts := parsePattern(n.pattern)</span><br><span class="line">		<span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> n, params</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle 实现路由功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在前缀树种查找路由，获取路由参数</span></span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 匹配路由</span></span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		c.Params = params</span><br><span class="line">		r.handlers[key](c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(c.Writer, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><code>dain/context.go</code></p>
<h2 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h2><p>为了访问到路由参数，所以需要修改 Context 结构体，向其中添加 <strong>Params</strong>，用来记录路由参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// HTTP 请求 响应</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// 请求信息</span></span><br><span class="line">	Path   <span class="keyword">string</span>            <span class="comment">// 请求路径</span></span><br><span class="line">	Method <span class="keyword">string</span>            <span class="comment">// 请求方法</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 路由参数，如 /hello/:user 匹配 /hello/dawn，则 Params[&quot;user&quot;]=dawn</span></span><br><span class="line">	<span class="comment">// 响应信息</span></span><br><span class="line">	StatusCode <span class="keyword">int</span> <span class="comment">// 响应码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取路由参数"><a href="#获取路由参数" class="headerlink" title="获取路由参数"></a>获取路由参数</h2><p>增加可以用过键值获取相应路由参数的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Param 获取路由参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Param</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	value, _ := c.Params[key]</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/21/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-2-%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-2-%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">从零实现一个Web框架 (2) 上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-21 21:45:27" itemprop="dateCreated datePublished" datetime="2022-05-21T21:45:27+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>最终实现得效果如下，此时更加接近于 GIN：</p>
<ul>
<li>Handler 得参数变为 <strong>dain.Context</strong>，同时提供了对表单和 URL 的查询 <code>PostForm/Query</code></li>
<li>dain.Context 同 GIN 一样，封装了 <code>HTML/String/JSON/Data</code> 函数，快速构建 HTTP 响应。</li>
</ul>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Dawn&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello World, URL path = %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Post(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, dain.H&#123;</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">			<span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建上下文"><a href="#构建上下文" class="headerlink" title="构建上下文"></a>构建上下文</h1><p><code>dain/context.go</code></p>
<p>上下文 Context 即一个请求的上下文，它随着每一个请求的出现而产生，响应的结束而销毁。</p>
<h2 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h2><p>Context 可以对一些代码进行封装，使用起来更加简便。首先看 Context 的结构：</p>
<ul>
<li>dain.H 同 gin.H 的作用一样，是 <code>map[string]interface&#123;&#125;</code> 的简便写法。</li>
<li>在 Context 中，保存了一次HTTP的请求 <code>Req</code> 和响应 <code>Writer</code>，同时保存了一些请求和响应信息。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// HTTP 请求 响应</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// 请求信息</span></span><br><span class="line">	Path   <span class="keyword">string</span> <span class="comment">// 请求路径</span></span><br><span class="line">	Method <span class="keyword">string</span> <span class="comment">// 请求方法</span></span><br><span class="line">	<span class="comment">// 响应信息</span></span><br><span class="line">	StatusCode <span class="keyword">int</span> <span class="comment">// 响应码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Writer: w,</span><br><span class="line">		Req:    r,</span><br><span class="line">		Path:   r.URL.Path,</span><br><span class="line">		Method: r.Method,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h2><p>封装关于<strong>获取请求数据</strong>的函数 <code>PostForm/Query</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostForm 根据 key 获取第一个表单数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">PostForm</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query 根据 key 获取请求的 query 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Query</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改变-HTTP-响应头"><a href="#改变-HTTP-响应头" class="headerlink" title="改变 HTTP 响应头"></a>改变 HTTP 响应头</h2><p>封装<strong>改变 HTTP 响应</strong>的函数 <code>Status/SetHeader</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status 设置响应状态码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Status</span><span class="params">(code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c.StatusCode = code</span><br><span class="line">	c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetHeader 设置响应头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetHeader</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速响应"><a href="#快速响应" class="headerlink" title="快速响应"></a>快速响应</h2><p>封装<strong>快速响应</strong>的函数 <code>String/JSON/Data/HTML</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">String</span><span class="params">(code <span class="keyword">int</span>, format <span class="keyword">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write([]<span class="keyword">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	encoder := json.NewEncoder(c.Writer)</span><br><span class="line">	<span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Data</span><span class="params">(code <span class="keyword">int</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write(data)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">HTML</span><span class="params">(code <span class="keyword">int</span>, html <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write([]<span class="keyword">byte</span>(html))</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p><code>dain/router.go</code></p>
<h2 id="router-结构"><a href="#router-结构" class="headerlink" title="router 结构"></a>router 结构</h2><p>于此同时，将路由器从 <code>dain/dain.go</code> 中分离出来。路由器的结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>需要稍微更改路由注册和路由功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Router %v - %v\n&quot;</span>, method, pattern)</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle 实现路由功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	key := c.Method + <span class="string">&quot;-&quot;</span> + c.Path</span><br><span class="line">	<span class="keyword">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class="line">		handler(c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(c.Writer, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h1><p><code>dain/dain.go</code></p>
<p>与此同时，也要更改框架入口。</p>
<p>首先需要将 <strong>HandlerFunc</strong> 的参数改变为 Context：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc handler 函数类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span></span><br></pre></td></tr></table></figure>

<p>改变 Engine 的内部结构，使之内嵌 <strong>router 结构体</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 路由器</span></span><br><span class="line">	router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个 Engine 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;</span><br><span class="line">		router: NewRouter(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改<strong>路由注册</strong>的内部逻辑为，调用 router 的路由注册：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.router.addRouter(method, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，需要<strong>更改 http.Handler 接口函数 ServeHTTP</strong> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 http.Handler 接口，自定义路由器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	c := NewContext(w, r)</span><br><span class="line">	e.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/20/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-1-%E5%8E%9F%E5%9E%8B%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/20/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-1-%E5%8E%9F%E5%9E%8B%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">从零实现一个Web框架 (1) 原型框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-20 22:18:23" itemprop="dateCreated datePublished" datetime="2022-05-20T22:18:23+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本系列参考于 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee.html">极客兔兔-7天用Go从零实现Web框架Gee教程</a>，将从零开始实现一个简易的仿 GIN 的框架，称为 Dawn’s Gin 简称 <strong>dain</strong>。</p>
<p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>我们最终的实现效果如下，可以看到自实现的框架与 GIN 十分相似：</p>
<ul>
<li>通过 <code>e.GET</code> 和 <code>e.POST</code> 注册路由</li>
<li>最后调用 <code>e.RUN</code> 运行 Web 服务器。</li>
</ul>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello World, URL path = %v&quot;</span>, r.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Post(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">			fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p><code>dain/dain.go</code></p>
<p>在 GIN 中，添加路由等的操作都是通过引擎 Engine 完成的，所以自定义 Engine。</p>
<p>其中 <strong>Engine.router</strong> 是一个<strong>路由器</strong>，类型为 map。key 记录路由注册时的 pattern，value 则为相应的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc handler 函数类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 路由器</span></span><br><span class="line">	router <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个 Engine 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;</span><br><span class="line">		router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态路由注册"><a href="#静态路由注册" class="headerlink" title="静态路由注册"></a>静态路由注册</h2><p>我们需要实现通过 POST 和 GET 注册静态路由，首先编写同一的路由注册入口，将路由注册到 Engine.router 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">AddRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	e.router[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加对外暴露的与 HTTP Method 相关的路由注册方法，共实现了 GET 和 POST 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 路由注册 GET 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.AddRouter(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 路由注册 POST 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.AddRouter(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-http-Handler-接口"><a href="#实现-http-Handler-接口" class="headerlink" title="实现 http.Handler 接口"></a>实现 http.Handler 接口</h2><p>需要使得自定义的路由器工作，首先需要实现 <strong>http.Handler</strong> 接口，接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只需要实现 <strong>ServeHTTP</strong> 方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 http.Handler 接口，自定义路由器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	key := r.Method + <span class="string">&quot;-&quot;</span> + r.URL.Path</span><br><span class="line">	<span class="keyword">if</span> handler, ok := e.router[key]; ok &#123;</span><br><span class="line">		handler(w, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，包装一层执行函数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run 运行服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Run</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/20/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/20/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (8) 日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-20 12:49:08" itemprop="dateCreated datePublished" datetime="2022-05-20T12:49:08+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go 语言中可以使用第三方日志系统：<strong>logrus 和 seelog</strong>，它们实现了很强大的日志功能。</p>
<h1 id="logrus"><a href="#logrus" class="headerlink" title="logrus"></a>logrus</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>logrus 是用 Go 语言实现的一个日志系统，安装 logrus：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/sirupsen/logrus</span><br></pre></td></tr></table></figure>

<p>六个<strong>日志等级</strong>（从低到高）：</p>
<ul>
<li>Debug</li>
<li>Info</li>
<li>Warn</li>
<li>Error</li>
<li>Fatal，随后触发 <code>os.Exit(1)</code></li>
<li>Panic，随后触发 <code>panic()</code></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="设置-logrus-参数"><a href="#设置-logrus-参数" class="headerlink" title="设置 logrus 参数"></a>设置 logrus 参数</h3><p>可以设置 logrus 的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 日志格式化为 JSON，而不是默认的 ASCII</span></span><br><span class="line">	logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出 stdout 而不是默认的 stderr，也可以是一个文件</span></span><br><span class="line">	logrus.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只记录 Warn 以及以上的错误等级</span></span><br><span class="line">	logrus.SetLevel(logrus.WarnLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Feilds"><a href="#Feilds" class="headerlink" title="Feilds"></a>Feilds</h3><p>可以添加 Fields 来自定义输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span>:  <span class="number">23</span>,</span><br><span class="line">&#125;).Warn(<span class="string">&quot;This is a warn level log.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// &#123;&quot;age&quot;:23,&quot;level&quot;:&quot;warning&quot;,&quot;msg&quot;:&quot;This is a warn level log.&quot;,&quot;name&quot;:&quot;zh&quot;,&quot;time&quot;:&quot;2022-05-20T13:11:48+08:00&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>有时候我们需要固定的 Fields，只需要生成一个 <strong>log.Entry</strong> 就可以<strong>复用 Fields</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 log.Entry 复用 Feilds</span></span><br><span class="line">contextLogger := logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">	<span class="string">&quot;common&quot;</span>: <span class="string">&quot;this is a common field&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">contextLogger.Info(<span class="string">&quot;I&#x27;ll be logged with common and other field&quot;</span>)</span><br><span class="line">contextLogger.Info(<span class="string">&quot;Me too&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>如果想在一个应用里面向多个地方记录日志，可以创建 <strong>Logger</strong>实例，Logger 结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Out io.Writer</span><br><span class="line">    Hooks LevelHooks</span><br><span class="line">    Formatter Formatter</span><br><span class="line">    <span class="comment">//最小级别</span></span><br><span class="line">    Level Level</span><br><span class="line">    <span class="comment">//被用来同步写入，比如两个地方同时log.默认是被锁住的</span></span><br><span class="line">    mu MutexWrap</span><br><span class="line">    <span class="comment">// Reusable empty entry</span></span><br><span class="line">    entryPool sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以创建很多instance</span></span><br><span class="line"><span class="keyword">var</span> log = logrus.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;logrus.log&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Out = file</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Info(<span class="string">&quot;Failed to log to file, using default stderr&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  log.WithFields(logrus.Fields&#123;</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;123.txt&quot;</span>,</span><br><span class="line">  &#125;).Info(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="seelog"><a href="#seelog" class="headerlink" title="seelog"></a>seelog</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>seelog 主要有以下特性：</p>
<ul>
<li>XML 的<strong>动态配置</strong>，支持动态改变配置而不需要重新启动应用。</li>
<li>支持<strong>多输出流</strong>，能够同时把日志输出到多种流中、例如文件流、网络流等。</li>
<li>日志级别：trace、debug、info、warn、error、critical、off</li>
</ul>
<p>安装 seelog：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/cihub/seelog</span><br></pre></td></tr></table></figure>

<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    log <span class="string">&quot;github.com/cihub/seelog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> log.Flush()</span><br><span class="line">    log.Info(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>seelog 的配置文件通过 XML 进行配置，其说明如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1. type: 日志输出类型，有4中类型，分别是：sync，asyncloop(default)，asynctimer，adaptive</span></span><br><span class="line"><span class="comment">   type=“sync”：在同一个go中处理日志消息，仅当调用日志函数时才被执行。</span></span><br><span class="line"><span class="comment">   type=“asyncloop”：在单独的go中独自处理日志消息，循环从日志队列中读取日志并消费(输出到控制台或者文件)。</span></span><br><span class="line"><span class="comment">   type=&quot;asynctimer&quot;：在单独的go中独自处理日志消息，在指定时间间隔去读取日志队列消息，所以该类型还需要配置一个间隔时间(纳秒)。</span></span><br><span class="line"><span class="comment">   type=&quot;adaptive&quot;：在单独的go中独自处理日志消息，但是不是固定的每隔指定时间去读取日志消息，间隔时间与队列剩余的日志量有关，如果剩余日志量多，则间隔时间短，反之亦然</span></span><br><span class="line"><span class="comment">2. minlevel: 全局最低输出日志级别</span></span><br><span class="line"><span class="comment">3. maxlevel: 全局最高输出日志级别</span></span><br><span class="line"><span class="comment">4. exceptions: 日志的特殊处理情况，可根据指定文件或者函数进行日志输出</span></span><br><span class="line"><span class="comment">5. formatid: 输出格式标签，可以在formats中找到对应的标签</span></span><br><span class="line"><span class="comment">6. console: 将日志输出到控制台</span></span><br><span class="line"><span class="comment">7. splitter: 用于细分outputs日志格式，支持: file(文件), rollingfile(滚动文件), buffered(缓存到内存再输出到文件), smtp(发送日志邮件), con(网络转发)</span></span><br><span class="line"><span class="comment">8. rollingfile: 滚动文件，可基于日期(type=&quot;date&quot;)或者文件大小(type=&quot;size&quot;)进行日志切割，maxsize: 单个日志文件最大size，如果设置为100M，则maxsize=100*1024*1024，maxrolls: 最大文件数量，超出的日志文件数量会被滚动删除</span></span><br><span class="line"><span class="comment">9. buffered: 将日志先存在内存中，定期写入文件，适合日志并发量较大或 IO 比较紧张的场合，size:缓存大小, flushperiod:缓存时间</span></span><br><span class="line"><span class="comment">10. filter: 单独处理某级别的日志</span></span><br><span class="line"><span class="comment">11. formats: 日志输出格式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p>seelog 支持自定义日志处理，可以通过配置文件进行配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    seelog <span class="string">&quot;github.com/cihub/seelog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Logger seelog.LoggerInterface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadAppConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    appConfig := <span class="string">`</span></span><br><span class="line"><span class="string">&lt;seelog minlevel=&quot;warn&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;outputs formatid=&quot;common&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rollingfile type=&quot;size&quot; filename=&quot;/data/logs/roll.log&quot; maxsize=&quot;100000&quot; maxrolls=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;filter levels=&quot;critical&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;file path=&quot;/data/logs/critical.log&quot; formatid=&quot;critical&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;smtp formatid=&quot;criticalemail&quot; senderaddress=&quot;astaxie@gmail.com&quot; sendername=&quot;ShortUrl API&quot; hostname=&quot;smtp.gmail.com&quot; hostport=&quot;587&quot; username=&quot;mailusername&quot; password=&quot;mailpassword&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;recipient address=&quot;xiemengjun@gmail.com&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;/smtp&gt;</span></span><br><span class="line"><span class="string">        &lt;/filter&gt;</span></span><br><span class="line"><span class="string">    &lt;/outputs&gt;</span></span><br><span class="line"><span class="string">    &lt;formats&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;common&quot; format=&quot;%Date/%Time [%LEV] %Msg%n&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;critical&quot; format=&quot;%File %FullPath %Func %Msg%n&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;criticalemail&quot; format=&quot;Critical error on our server!\n    %Time %Date %RelFile %Func %Msg \nSent by Seelog&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/formats&gt;</span></span><br><span class="line"><span class="string">&lt;/seelog&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    logger, err := seelog.LoggerFromConfigAsBytes([]<span class="keyword">byte</span>(appConfig))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    UseLogger(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DisableLog()</span><br><span class="line">    loadAppConfig()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DisableLog disables all library log output</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DisableLog</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Logger = seelog.Disabled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseLogger uses a specified seelog.LoggerInterface to output library log.</span></span><br><span class="line"><span class="comment">// Use this func if you are using Seelog logging system in your app.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseLogger</span><span class="params">(newLogger seelog.LoggerInterface)</span></span> &#123;</span><br><span class="line">    Logger = newLogger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实现了三个函数：</p>
<ul>
<li><code>DisableLog</code> 函数：初始化全局变量 Logger 为 seelog 的禁用状态，主要为了<strong>防止 Logger 被多次初始化</strong>。</li>
<li><code>loadAppConfig</code> 函数：根据配置文件初始化 seelog 的配置信息，配置文件说明如下：<ul>
<li>seelog：minlevel 参数可选，如果被配置，高于或等于此级别的日志会被记录，同理 maxlevel。</li>
<li>outputs：输出信息的目的地，这里分成了两份数据，一份记录到 log rotate 文件里面。另一份设置了 filter，如果这个错误级别是 critical，那么将发送报警邮件。</li>
<li>formats：定义了日志的格式。</li>
</ul>
</li>
<li><code>UseLogger</code> 函数：设置当前的日志器为相应的日志处理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/19/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (7) 错误处理和测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 20:58:01" itemprop="dateCreated datePublished" datetime="2022-05-19T20:58:01+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在 Go 语言中，定义了 <strong>error 类型</strong>，来显示的表达错误，错误作为函数的返回值进行返回。</p>
<h2 id="Error-类型"><a href="#Error-类型" class="headerlink" title="Error 类型"></a>Error 类型</h2><p><strong>error 类型</strong>是一个接口类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <strong>errors.New</strong> 把一个字符串转化为 errorString，以得到一个 error 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-Error"><a href="#自定义-Error" class="headerlink" title="自定义 Error"></a>自定义 Error</h2><p>error 因为是一个接口，所以可以通过实现 error 接口，自定义错误类型。如 <strong>json.SyntaxError</strong> 类型，除了错误描述外，还定义了错误发生的位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="keyword">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="keyword">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p>再如 <strong>net.Error</strong> 类型，定义了更复杂的错误处理，判断是否超时、或者临时性错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    error</span><br><span class="line">    Timeout() <span class="keyword">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="keyword">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<strong>类型断言</strong>，获取自定义的错误类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serr, ok := err.(*json.SyntaxError)</span><br><span class="line"></span><br><span class="line">nerr, ok := err.(net.Error)</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Go 语言中，将<strong>异常与错误区分</strong>开来：</p>
<ul>
<li>错误指可以预期的错误，这时可以将错误当作函数返回值返回。</li>
<li>异常指无法预期、无法继续执行的严重程序错误，如数组地址越界。</li>
</ul>
<h2 id="异常恢复机制"><a href="#异常恢复机制" class="headerlink" title="异常恢复机制"></a>异常恢复机制</h2><p>Go 语言中可以使用 <code>recover</code> 机制来恢复异常：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发生了异常</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>测试文件必须遵循如下原则：</p>
<ul>
<li>文件名必须是 <code>_test.go</code> 结尾的。</li>
<li>必须 <code>import testing</code>。</li>
<li>所有的测试函数的格式为 <code>func TestXxx (t *testing.T)</code>。</li>
<li>通过调用 <code>testing.T</code> 的 <code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code> 方法，说明测试不通过，调用 <code>Log</code> 方法用来记录测试的信息。</li>
</ul>
<p>如编写 go 文件 <code>gotest.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;被除数不为0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写相应的测试文件 <code>gotest_test.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivide_1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i, e := Divide(<span class="number">6</span>, <span class="number">2</span>); i != <span class="number">3</span> || e != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;除法函数测试没通过&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(<span class="string">&quot;第一个测试通过&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivide_2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, e := Divide(<span class="number">6</span>, <span class="number">0</span>); e == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;除数为0测试未通过&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(<span class="string">&quot;第二个测试通过&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试文件可以得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestDivide_1</span><br><span class="line">    gotest_test.go:9: 第一个测试通过</span><br><span class="line">--- PASS: TestDivide_1 (0.00s)</span><br><span class="line">=== RUN   TestDivide_2</span><br><span class="line">    gotest_test.go:16: 第二个测试通过</span><br><span class="line">--- PASS: TestDivide_2 (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>

<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>压力测试用来测试函数的性能，需要注意：</p>
<ul>
<li>压力测试函数的格式为 <code> func BenchmarkXXX(b *testing.B)</code>。</li>
<li><code>go test</code> 不会默认执行压力测试的函数，如果要执行压力测试需要带上参数 <code>-test.bench</code>，语法: <code>-test.bench=&quot;test_name_regex&quot;</code>。</li>
</ul>
<p>对上述编写的除法函数进行压力测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDivide</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.StopTimer() <span class="comment">// 调用该函数停止压力测试的时间计数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做一些初始化的工作,例如读取文件数据,数据库连接之类的,</span></span><br><span class="line">	<span class="comment">// 这样这些时间不影响我们测试函数本身的性能</span></span><br><span class="line"></span><br><span class="line">	b.StartTimer() <span class="comment">// 重新开始时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Divide(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过调用 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code> 暂停和开始时间计数。执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-web-demo/ch11/gotest</span><br><span class="line">cpu: Intel(R) Pentium(R) CPU G4560 @ 3.50GHz</span><br><span class="line">BenchmarkDivide</span><br><span class="line">BenchmarkDivide-4       1000000000               0.4220 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/18/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (6) 安全和加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-18 09:52:22" itemprop="dateCreated datePublished" datetime="2022-05-18T09:52:22+08:00">2022-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h2><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，可以伪装为受害者的身份，向服务器发送各种请求。原理如下：</p>
<ul>
<li><strong>受害者登录受信任网站 A，并在本地生成 Cookie</strong>。</li>
<li><strong>在不退出 A 的情况下，访问危险网站 B</strong>。此时访问 B 时会发送请求给受信任网站 A 并且会附上 Cookie 信息。</li>
</ul>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/9.1.csrf.png" alt="img"></p>
<h2 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h2><p>在服务器端防御 CSRF，主要有两个方面：</p>
<ul>
<li>正确使用 GET、POST 请求。</li>
<li>在非 GET 请求中增验证。</li>
</ul>
<h3 id="正确使用-GET-POST-请求"><a href="#正确使用-GET-POST-请求" class="headerlink" title="正确使用 GET POST 请求"></a>正确使用 GET POST 请求</h3><p>使用 <strong>REST 方式</strong>可以限制请求的类型：</p>
<ul>
<li><p>GET 常用在查看，列举，展示等不需要改变资源属性的时候。</p>
</li>
<li><p>POST 常用在改变一个资源的属性或者状态。</p>
</li>
</ul>
<h3 id="增加验证"><a href="#增加验证" class="headerlink" title="增加验证"></a>增加验证</h3><p>在非 GET 请求中增加验证，可以有三个思路：</p>
<ul>
<li><p>为每个用户生成一个<strong>唯一的 token</strong>，所有表单都包含同一个伪随机值。这种方法最简单，因为攻击者（理论上）不能获取到第三方的 Cookie，所以表单中的数据也就构造失败，但是 XSS 可以窃取到第三方 Cookie，所以这个方案在没有 XSS 时是安全的。</p>
</li>
<li><p>为每一个请求使用<strong>验证码</strong>，用户体验很差。</p>
</li>
<li><p>每个用户生成的 <strong>token 随时更新</strong>，实现如下：</p>
<ul>
<li>生成随机 token：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h := md5.New()</span><br><span class="line">io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">io.WriteString(h, <span class="string">&quot;salt&quot;</span>)</span><br><span class="line">token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">t, _ := template.ParseFiles(<span class="string">&quot;xxx.gtpl&quot;</span>)</span><br><span class="line">t.Execute(w, token)</span><br></pre></td></tr></table></figure>

<ul>
<li>表单中的 token：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>验证 token：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r.ParseForm()</span><br><span class="line">token := r.Form.Get(<span class="string">&quot;token&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> token != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 验证 token 的合法性</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不存在 token 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>XSS（Cross-Site Scripting）<strong>跨站脚本攻击</strong>，原理是一段恶意的 JavaScript 代码在用户客户端上被执行，导致信息泄露（ Cookie 泄露）。XSS 主要用于攻击用户端的。</p>
<p>主要分为两类：</p>
<ul>
<li><strong>存储型 XSS</strong>：恶意 XSS 代码被服务器存储到了服务器中，应用程序从数据库中查询出来并在客户端中显示，造成 XSS 攻击。</li>
<li><strong>反射型 XSS</strong>：将恶意 XSS 代码加入到 URL 的请求参数中，请求参数在页面上直接输出。</li>
</ul>
<h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><p>XSS防御可以有如下方式：</p>
<ul>
<li><strong>过滤特殊字符</strong>：text/template 包下面的 <strong>HTMLEscapeString、JSEscapeString</strong> 等函数可以对敏感字符进行转义。</li>
<li><strong>输入内容长度控制</strong>：对于不受信任的输入，都应该限定一个合理的长度，这样可以增加攻击难度。</li>
<li><strong>HTTP-Only</strong>：禁止从客户端脚本中读取 Cookie 信息，使得攻击者无法窃取 Cookie。</li>
<li>等一系列防御手段。。。</li>
</ul>
<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><h2 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h2><p>SQL 注入的原理就是因为用户输入的数据被当作 SQL 语句执行。</p>
<h2 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h2><p>SQL 注入可以有如下防御方式：</p>
<ul>
<li><p>限制 Web 应用数据库的操作权限，给予用户最低的操作权限。</p>
</li>
<li><p>检查输入的数据，对进入数据库的字符进行转义、过滤。html/template 包的 HTMLEscapeString 函数可以对字符串进行转义处理。</p>
</li>
<li><p>所有的查询语句建议使用数据库提供的参数化查询接口，避免直接拼接 SQL 语句。</p>
</li>
</ul>
<h1 id="存储密码"><a href="#存储密码" class="headerlink" title="存储密码"></a>存储密码</h1><h2 id="普通方案：哈希"><a href="#普通方案：哈希" class="headerlink" title="普通方案：哈希"></a>普通方案：哈希</h2><p>目前利用最多的方案就是对明文密码进行哈希之后，进行存储。常用的单向哈希算法包括 <strong>SHA-256, SHA-1, MD5</strong> 等。</p>
<p><strong>缺点：</strong>考虑到多数人所使用的密码为常见的组合，攻击者可以将所有密码的常见组合进行单向哈希，得到一个摘要组合（<strong>彩虹表</strong>），然后与数据库中的摘要进行比对即可获得对应的密码。</p>
<h2 id="进阶方案：哈希-盐"><a href="#进阶方案：哈希-盐" class="headerlink" title="进阶方案：哈希+盐"></a>进阶方案：哈希+盐</h2><p>可以采用加盐的方式来存储密码，常用的方式：</p>
<ul>
<li>对用户的明文密码进行一次<strong>哈希运算</strong>。</li>
<li>将得到的摘要<strong>加上随机串（盐）</strong>，这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>再进行一次<strong>哈希运算</strong>后，放入数据库中存储起来。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户名 abc，密码 123456</span></span><br><span class="line">h := md5.New()</span><br><span class="line">io.WriteString(h, <span class="string">&quot;需要加密的密码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pwmd5 等于 e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line">pwmd5 :=fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定两个 salt： salt1 = @#$%   salt2 = ^&amp;*()</span></span><br><span class="line">salt1 := <span class="string">&quot;@#$%&quot;</span></span><br><span class="line">salt2 := <span class="string">&quot;^&amp;*()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// salt1 + 用户名 + salt2 + MD5 拼接</span></span><br><span class="line">io.WriteString(h, salt1)</span><br><span class="line">io.WriteString(h, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">io.WriteString(h, salt2)</span><br><span class="line">io.WriteString(h, pwmd5)</span><br><span class="line"></span><br><span class="line">last :=fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<h2 id="专家方案：Scrypt"><a href="#专家方案：Scrypt" class="headerlink" title="专家方案：Scrypt"></a>专家方案：Scrypt</h2><p>故意增加密码计算所需耗费的资源和时间，使得任何人都不可获得足够的资源建立所需的 <code>rainbow table</code>。</p>
<p><strong>Scrypt 算法</strong>使得并行计算多个摘要异常困难，因此利用rainbow table（彩虹表）进行暴力攻击的难度增加。</p>
<p>在 Go 的 golang.org/x/crypto/scrypt 包中支持 scrypt：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/crypto/scrypt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// DO NOT use this salt value; generate your own random salt. 8 bytes is</span></span><br><span class="line">	<span class="comment">// a good length.</span></span><br><span class="line">	salt := []<span class="keyword">byte</span>&#123;<span class="number">0xc8</span>, <span class="number">0x28</span>, <span class="number">0xf2</span>, <span class="number">0x58</span>, <span class="number">0xa7</span>, <span class="number">0x6a</span>, <span class="number">0xad</span>, <span class="number">0x7b</span>&#125;</span><br><span class="line"></span><br><span class="line">	dk, err := scrypt.Key([]<span class="keyword">byte</span>(<span class="string">&quot;some password&quot;</span>), salt, <span class="number">1</span>&lt;&lt;<span class="number">15</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(base64.StdEncoding.EncodeToString(dk))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="加密和解密数据"><a href="#加密和解密数据" class="headerlink" title="加密和解密数据"></a>加密和解密数据</h1><p>Go 语言中 crypto 及其子包提供了多种加密算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/17/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (5) Web服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 20:41:56" itemprop="dateCreated datePublished" datetime="2022-05-17T20:41:56+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h1><p>常用的 Socket 有两种类型：</p>
<ul>
<li><p><strong>流式 Socket（SOCK_STREAM）</strong>：一种<strong>面向连接</strong>的 Socket，针对于面向连接的 <strong>TCP</strong> 服务应用。</p>
</li>
<li><p><strong>数据包式 Socket （SOCK_DGRAM）</strong>：<strong>无连接</strong>的 Socket，对应于无连接的 <strong>UDP</strong> 服务应用。</p>
</li>
</ul>
<p>对于在网络上的应用程序来说，<strong>（协议类型，IP 地址，端口号）</strong>这个三元组可以唯一确定一个进程。</p>
<p>在 Go 的 net 包中，定义了 IP 地址类型，net 包的函数都可以接收 <strong>IPv4 和 IPv6</strong> 的 IP 地址作为输入。其中 <code>ParseIP(s string) IP</code> 函数会把一个 IPv4 或者 IPv6 的地址转化成 IP 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIP</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">IP</span></span></span><br></pre></td></tr></table></figure>

<h2 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h2><p>在 net 包中，有一个类型为 TCPConn，它用来作为客户端和服务器端交互的通道，主要有两个函数，分别可以读写数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>另外，还有一个 TCPAddr 类型，用于表示 TCP 的地址信息，通过 <code>ResolveTCPAddr</code> 函数可以获取一个 TCPAddr：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPAddr <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP IP</span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Zone <span class="keyword">string</span> <span class="comment">// IPv6 scoped addressing zone</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResolveTCPAddr</span><span class="params">(net, addr <span class="keyword">string</span>)</span> <span class="params">(*TCPAddr, os.Error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>net 参数<strong>是 “tcp4”、”tcp6”或”tcp” 中的任意一个</strong>，分别表示 TCP (IPv4-only), TCP (IPv6-only) 或者 TCP (IPv4, IPv6 的任意一个)。</li>
<li>addr 表示<strong>域名或者 IP 地址</strong>。</li>
</ul>
<h3 id="TCP-client"><a href="#TCP-client" class="headerlink" title="TCP client"></a>TCP client</h3><p>客户端通过 net 包中的 <code>DialTCP</code> 函数来建立一个 TCP 连接，并返回一个 <code>TCPConn</code> 类型的对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTCP</span><span class="params">(network <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>net 必须是**”tcp”、”tcp4”、”tcp6”**。</li>
<li>laddr 为<strong>本地地址</strong>，如果 laddr 不是 nil，将使用它作为本地地址，否则自动选择一个本地地址。<strong>通常为 nil</strong>。</li>
<li>raddr 为<strong>远程的服务器地址</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器远程地址</span></span><br><span class="line">serviceAddr = <span class="string">&quot;127.0.0.1:9617&quot;</span></span><br><span class="line">raddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, serviceAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与服务器建立连接</span></span><br><span class="line">conn, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>, <span class="literal">nil</span>, raddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务器端发送数据</span></span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">result, err := ioutil.ReadAll(conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP-server"><a href="#TCP-server" class="headerlink" title="TCP server"></a>TCP server</h3><p>服务器端需要：</p>
<ul>
<li>绑定服务到指定的非激活端口，并<strong>监听</strong>此端口。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenTCP</span><span class="params">(network <span class="keyword">string</span>, laddr *TCPAddr)</span> <span class="params">(*TCPListener, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当有客户端请求到达的时候可以<strong>接收</strong>到来自客户端连接的请求。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<p>当 Accept 之后，为<strong>每一个 conn 开启一个 goroutine</strong> 来处理与客户端的通信，这样可以支持多并发：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启协程，支持多并发</span></span><br><span class="line">    <span class="keyword">go</span> handleClient(conn)</span><br><span class="line">&#125;d</span><br></pre></td></tr></table></figure>

<h3 id="控制-TCP-连接"><a href="#控制-TCP-连接" class="headerlink" title="控制 TCP 连接"></a>控制 TCP 连接</h3><p>TCP 有很多连接控制函数，常用如下：</p>
<ul>
<li>设置<strong>建立连接的超时时间</strong>，当超过设置时间时，连接自动关闭。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(net, addr <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <strong>写入 / 读取 一个连接的超时时间</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetReadDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetWriteDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <strong>keepAlive 属性</strong>，操作系统在 TCP 上没有数据和 ACK 时，会间隔性的发送 keepalive 包，以此判断这个 TCP 连接是否已经断开。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlive</span><span class="params">(keepalive <span class="keyword">bool</span>)</span> <span class="title">os</span>.<span class="title">Error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h2><p>UDP Socket 在服务器端<strong>没有 Accept 函数</strong>，其他几乎一样。</p>
<h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><p>在 WebSocket 出现之前，为了实现即时通信，采用的技术都是 “”轮询”，即在特定的时间间隔内，由浏览器对服务器发出 HTTP Request，服务器在收到请求后，返回最新的数据给浏览器刷新，“轮询” 使得浏览器需要对服务器不断发出请求，这样会占用大量带宽。</p>
<p>Web Socket 采用了特殊的报头，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道。URI 以 ws 或者 wss（SSL） 开头。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Web Socket 协议本质上是一个基于 <strong>TCP</strong> 的协议。Web Socket 的大致流程如下：</p>
<ul>
<li><p><strong>握手过程：</strong>为了建立一个 Web Socket 连接，客户端浏览器首先要向服务器<strong>发起一个 HTTP 请求</strong>，这个请求和通常的 HTTP 请求不同，包含了一些<strong>附加头</strong>信息，其中附加头信息 <strong>Upgrade: WebSocket</strong> 表明这是一个<strong>申请协议升级</strong>的 HTTP 请求，服务器端解析这些附加的头信息然后<strong>产生应答信息返回给客户端</strong>，客户端和服务器端的 WebSocket 连接就建立起来了。</p>
</li>
<li><p><strong>数据传输：</strong>双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
</li>
</ul>
<p>Web Socket在<strong>第一次握手之后</strong>，连接便建立成功，其后的通讯数据都是以 <strong>\x00 开头</strong>，以 <strong>\xFF 结尾</strong>。在上层应用中，这是透明的，Web Socket 组件会自动的去掉头部和尾部。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Go 语言官方标准库中没有对于 Web Socket 的支持，但是可以通过以下命令获取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/net/websocket</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端示例如下，并且客户端绑定了4个事件：</p>
<ul>
<li><strong>onopen</strong> 建立连接后触发。</li>
<li><strong>onmessage</strong> 收到消息后触发。</li>
<li><strong>onerror</strong> 发生错误时触发。</li>
<li><strong>onclose</strong> 关闭连接时触发。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sock = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> wsuri = <span class="string">&quot;ws://127.0.0.1:9617&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;onload&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock = <span class="keyword">new</span> WebSocket(wsuri);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;connection closed (&quot;</span> + e.code + <span class="string">&quot;)&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;message received: &quot;</span> + e.data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;message&#x27;</span>).value;</span></span><br><span class="line"><span class="javascript">        sock.send(msg);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket Echo Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Message: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send();&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	t, _ := template.ParseFiles(<span class="string">&quot;demo.html&quot;</span>)</span><br><span class="line">	t.Execute(w, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Echo</span><span class="params">(ws *websocket.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Can&#x27;t receive&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;Received back from client: &quot;</span> + reply)</span><br><span class="line"></span><br><span class="line">		msg := <span class="string">&quot;Received:  &quot;</span> + reply</span><br><span class="line">		fmt.Println(<span class="string">&quot;Sending to client: &quot;</span> + msg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = websocket.Message.Send(ws, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Can&#x27;t send&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, Index)</span><br><span class="line">	http.Handle(<span class="string">&quot;/ws&quot;</span>, websocket.Handler(Echo))</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:9617&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>REST ( REpresentatianal State Transfer ) 表现层状态转化。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>要理解什么是 REST，需要理解以下几个概念：</p>
<ul>
<li><strong>资源（Resource）</strong>：REST 是 表现层状态转化，实际上 表现层指的是 <strong>资源的表现层</strong>。平常上网访问的一张图片、一个文档、一个视频等就是资源。这些资源我们通过 URI 来定位，也就是一个 URI 表示一个资源。</li>
<li><strong>表现层（Representation）</strong>：把资源实体<strong>展现出来的方式</strong>，就是表现层。比如一段文本信息，可以输出为 HTML，JSON，XML 等。URI 确定一个资源，但是<strong>如何确定它的具体表现形式呢？</strong>应该在 HTTP 请求的头信息中用 <strong>Accept</strong> 和 <strong>Content-Type</strong> 字段指定，这两个字段才是对 “表现层” 的描述。</li>
<li><strong>状态转换（State Transfer）</strong>：在访问服务器的过程中，服务器与客户端进行交互，这就涉及到了数据和状态的变化。HTTP 中四个方法 <strong>GET、POST、PUT、DELETE</strong>，分别对应于<strong>四种基本操作</strong>：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</li>
</ul>
<h2 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h2><p>RESTful 架构就是：</p>
<ul>
<li>每一个 URI 代表一种<strong>资源</strong>。</li>
<li>客户端和服务器之间，传递这种资源的<strong>某种表现层</strong>。</li>
<li>客户端通过<strong>四个 HTTP 动词</strong>，对服务器端资源进行操作，实现 <strong>表现层状态转化</strong>。</li>
</ul>
<p>Web 应用要满足 REST 最重要的原则是：<strong>客户端和服务器之间的交互在请求之间是无状态的</strong>，即从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外此<strong>请求可以由任何可用服务器回答</strong>，这十分适合云计算之类的环境。因为是无状态的，所以客户端可以缓存数据以改进性能。</p>
<p>另一个重要的 REST 原则是：<strong>系统分层</strong>，这表示组件无法了解除了与它直接交互的层次以外的组件。</p>
<p>REST 架构图：</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/8.3.rest2.png" alt="img"></p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>见文章 <a href="./GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-2-RPC">GO语言杂谈 2 RPC</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (4) 文本处理-XML JSON 模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 21:16:10" itemprop="dateCreated datePublished" datetime="2022-05-16T21:16:10+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web 开发中需要对输入、输出进行处理。</p>
<h1 id="XML-处理"><a href="#XML-处理" class="headerlink" title="XML 处理"></a>XML 处理</h1><p>示例 XML 文件如下： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span> <span class="attr">version</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Shanghai_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Beijing_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.2<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="读取-XML"><a href="#读取-XML" class="headerlink" title="读取 XML"></a>读取 XML</h2><p>读取 XML 选择 <strong>xml.Unmarshal</strong> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>将 XML 写入结构体为例，上述 XML 文件 对应的结构体为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开 XML 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.xml&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 读取文件内容</span></span><br><span class="line">	data, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 XML 转为结构体</span></span><br><span class="line">	v := Servers&#123;&#125;</span><br><span class="line">	err = xml.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;] </span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="输出-XML"><a href="#输出-XML" class="headerlink" title="输出 XML"></a>输出 XML</h2><p>xml 包提供了两个函数 Marshal 和 MarshalIndent 来输出 XML，二者的区别在于 MarshalIndent 会增加前缀和缩进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>构建结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析结构体并输出 XML ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建结构体</span></span><br><span class="line">	v := Servers&#123;Version: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Shanghai_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Beijing_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 转为 XML 数据</span></span><br><span class="line">	data, err := xml.MarshalIndent(&amp;v, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Stdout.Write([]<span class="keyword">byte</span>(xml.Header))</span><br><span class="line">	os.Stdout.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>之所以会有 <code>os.Stdout.Write([]byte(xml.Header))</code> 这句代码的出现，是因为 <code>xml.MarshalIndent</code> 或者 <code>xml.Marshal</code> 输出的信息都是<strong>不带 XML 头</strong>的，为了生成正确的 xml 文件，我们使用了 xml 包预定义的 Header 变量。</p>
<h1 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h1><p>示例 JSON 格式数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;servers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Shanghai_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Beijing_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析-JSON"><a href="#解析-JSON" class="headerlink" title="解析 JSON"></a>解析 JSON</h2><p>json 包中有如下函数可以解析 JSON 数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="解析到结构体"><a href="#解析到结构体" class="headerlink" title="解析到结构体"></a>解析到结构体</h3><p>上述 JSON 数据对应的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServerName <span class="keyword">string</span> <span class="string">`json:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span> <span class="string">`json:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	Servers []Server <span class="string">`json:&quot;servers&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 JSON 数据到结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取内容</span></span><br><span class="line">	data, _ := ioutil.ReadAll(file)</span><br><span class="line">	<span class="comment">// 解析 JSON</span></span><br><span class="line">	v := ServerSlice&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析到-interface"><a href="#解析到-interface" class="headerlink" title="解析到 interface"></a>解析到 interface</h3><p>如果知道 JSON 数据的格式，可以解析到结构体中。如果<strong>不知道 JSON 数据格式</strong>，可以利用 <strong>map [string] interface {}</strong> 和 <strong>[] interface {}</strong> 结构来存储任意的 JSON 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure>

<p>此时，空接口 f 实际上是一个 map[string] interface{}，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;servers&quot;</span>:[]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Shanghai_VPN&quot;</span>&#125;, </span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.2&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Beijing_VPN&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过类型断言将**空接口转为 map[string] interface{}**，接着就可以利用 <strong>for range</strong> 对 map 进行遍历了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>目前，<code>simplejson</code> 包可以更加容易的处理未知结构的 JSON 数据，其 github 地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/bitly/go-simplejson">github.com/bitly/go-simplejson</a></p>
<hr>
<h2 id="生成-JSON"><a href="#生成-JSON" class="headerlink" title="生成 JSON"></a>生成 JSON</h2><p>json 包提供了生成 JSON 数据的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>这里不再举例说明具体操作。</p>
<h1 id="模板处理"><a href="#模板处理" class="headerlink" title="模板处理"></a>模板处理</h1><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><h3 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h3><p>html/template 包中有两个函数可以解析模板：</p>
<ul>
<li><strong>ParseFiles 函数</strong>创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ParseGlob 函数</strong>创建一个模板并解析匹配 pattern 的文件里的模板定义。返回的模板的名字是第一个匹配的文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseGlob</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="模板执行"><a href="#模板执行" class="headerlink" title="模板执行"></a>模板执行</h3><p>html/template 包中有两个函数可以执行模板：</p>
<ul>
<li><strong>Execute 方法</strong>将解析好的模板应用到 data 上，并将输出写入 wr。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">Execute</span><span class="params">(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ExecuteTemplate 方法</strong>类似 Execute，但是使用名为 nam e的 t 关联的模板产生输出。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">ExecuteTemplate</span><span class="params">(wr io.Writer, name <span class="keyword">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="模板中插入数据"><a href="#模板中插入数据" class="headerlink" title="模板中插入数据"></a>模板中插入数据</h2><ul>
<li><p><strong>字段操作</strong>：<code>&#123;&#123;.&#125;&#125;</code> 代表<strong>当前对象</strong>，可以通过 <code>&#123;&#123;.FieldName&#125;&#125;</code> 访问当前对象的<strong>字段</strong>。</p>
</li>
<li><p><strong>输出嵌套字段</strong>：</p>
<ul>
<li><code>&#123;&#123;with …&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 可以指定当前对象的值，如子结构体。</li>
<li><code>&#123;&#123;range …&#125;&#125;&#123;&#123;end&#125;&#125;</code> 可以循环操作数据。</li>
</ul>
</li>
<li><p><strong>条件判断</strong>：<code>&#123;&#123;if …&#125;&#125;…&#123;&#123;else if …&#125;&#125;…&#123;&#123;else&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 语句可以进行条件判断。</p>
</li>
<li><p><strong>pipelines</strong>：在 <code>&#123;&#123;&#125;&#125;</code> 中的都是 pipeline，如 <code>&#123;&#123;. | html&#125;&#125;</code> 可以将当前对象进行 HTML 转义，变为 HTML 实体。</p>
</li>
<li><p><strong>模板变量</strong>：可以通过 <code>$variable := pipeline</code> 方式声明模板局部变量。</p>
</li>
<li><p><strong>模板嵌套</strong>：</p>
<ul>
<li>声明：<code>&#123;&#123;define "子模板名称"&#125;&#125;内容&#123;&#123;end&#125;&#125;</code></li>
<li>调用：<code>&#123;&#123;template "子模板名称"&#125;&#125;</code></li>
</ul>
</li>
<li><p><strong>模板函数</strong>：</p>
<ul>
<li>每一个模板函数都有一个唯一的名字，可以与一个 Go 函数相关联。<strong>FuncMap</strong> 类型定义了函数名字符串到函数的映射，每个函数都必须<strong>有 1 到 2 个返回值</strong>，如果有 2 个则<strong>后一个必须是 error 接口类型</strong>；如果有 2 个返回值的方法返回的 error 非 nil ，模板执行会中断并返回给调用者该错误。：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>t.Funcs</code> 函数在模板中注册函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = t.Funcs(template.FuncMap&#123;<span class="string">&quot;TmplFuncName&quot;</span>: FuncName&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在模板包内部已经有内置的实现函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builtins = FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;and&quot;</span>:      and,</span><br><span class="line">    <span class="string">&quot;call&quot;</span>:     call,</span><br><span class="line">    <span class="string">&quot;html&quot;</span>:     HTMLEscaper,</span><br><span class="line">    <span class="string">&quot;index&quot;</span>:    index,</span><br><span class="line">    <span class="string">&quot;js&quot;</span>:       JSEscaper,</span><br><span class="line">    <span class="string">&quot;len&quot;</span>:      length,</span><br><span class="line">    <span class="string">&quot;not&quot;</span>:      not,</span><br><span class="line">    <span class="string">&quot;or&quot;</span>:       or,</span><br><span class="line">    <span class="string">&quot;print&quot;</span>:    fmt.Sprint,</span><br><span class="line">    <span class="string">&quot;printf&quot;</span>:   fmt.Sprintf,</span><br><span class="line">    <span class="string">&quot;println&quot;</span>:  fmt.Sprintln,</span><br><span class="line">    <span class="string">&quot;urlquery&quot;</span>: URLQueryEscaper,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Must-操作"><a href="#Must-操作" class="headerlink" title="Must 操作"></a>Must 操作</h2><p>Must 函数用来检查模板是否正确：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Must</span><span class="params">(t *Template, err error)</span> *<span class="title">Template</span></span></span><br></pre></td></tr></table></figure>

<p>一般用于变量初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;html&quot;</span>))</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (3) Session和数据存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 09:06:46" itemprop="dateCreated datePublished" datetime="2022-05-16T09:06:46+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是由<strong>浏览器</strong>维持的，保存在<strong>客户端</strong>的一段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。通过 Cookie，服务器就可以验证 Cookie 信息、记录用户状态。</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/6.1.cookie2.png" alt="img"></p>
<p>Cookie 是有时间限制的，根据生命周期不同分为会话 Cookie 和持久 Cookie：</p>
<ul>
<li><strong>会话 Cookie</strong>：不设置生命周期的默认值，表示这个 Cookie 的生命周期到<strong>浏览器关闭为止</strong>，会话 Cookie 一般保存在<strong>内存</strong>中。</li>
<li><strong>持久 Cookie</strong>：设置了过期时间时，浏览器就会将 Cookie 保存在<strong>硬盘</strong>上，有效期直到超过了过期时间。</li>
</ul>
<h3 id="Go-设置-Cookie"><a href="#Go-设置-Cookie" class="headerlink" title="Go 设置 Cookie"></a>Go 设置 Cookie</h3><p>Go 语言中，通过 net/http 包中的 <strong>SetCookie</strong> 来设置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure>

<p>Cookie 结构体结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span></span><br><span class="line">    Value      <span class="keyword">string</span></span><br><span class="line">    Path       <span class="keyword">string</span></span><br><span class="line">    Domain     <span class="keyword">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于&quot;Max-Age: 0&quot;</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="keyword">int</span></span><br><span class="line">    Secure   <span class="keyword">bool</span></span><br><span class="line">    HttpOnly <span class="keyword">bool</span></span><br><span class="line">    Raw      <span class="keyword">string</span></span><br><span class="line">    Unparsed []<span class="keyword">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 Cookie 例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">expiration := time.Now()</span><br><span class="line">expiration = expiration.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 实例化 Cookie对象</span></span><br><span class="line">cookie := &amp;http.Cookie&#123;</span><br><span class="line">    Name: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">    Value: <span class="string">&quot;dawn&quot;</span>,</span><br><span class="line">    Expires: expiration,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入 HTTP 响应</span></span><br><span class="line">http.SetCookie(w, cookie)</span><br></pre></td></tr></table></figure>

<h3 id="Go-读取-Cookie"><a href="#Go-读取-Cookie" class="headerlink" title="Go 读取 Cookie"></a>Go 读取 Cookie</h3><p>Go 语言中，使用 <strong>r.Cookie</strong> 根据 name 读取 Cookie：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span></span></span><br></pre></td></tr></table></figure>

<p>还可以通过 <strong>r.Cookies</strong> 一次性得到所有的 Cookie 信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是一种<strong>服务器端</strong>的机制，服务器使用一种类似于散列表的结构来保存信息。服务器使用 <strong>Session id</strong> 来标识 Session 信息，它由服务器端产生，相当于一个密钥。可以借助 <strong>Cookie</strong> 或者 <strong>GET 请求</strong>方式传输 Session id。</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/6.1.session.png" alt="img"></p>
<hr>
<p><strong>总结</strong>：</p>
<ul>
<li>Session 和 Cookie 机制都是为了克服 HTTP 协议的无状态缺陷，用于记录用户状态。</li>
<li>Session 依托 Cookie 实现，将 Session id 保存在 Cookie 中。</li>
<li>Cookie 因为将所有信息都保存在客户端中，发起请求时会携带这些信息，所以有一定的安全隐患。</li>
</ul>
<hr>
<h1 id="Go-实现-Session"><a href="#Go-实现-Session" class="headerlink" title="Go 实现 Session"></a>Go 实现 Session</h1><h2 id="Session-创建过程"><a href="#Session-创建过程" class="headerlink" title="Session 创建过程"></a>Session 创建过程</h2><p>服务器端在创建 Session 时会分为三个步骤：</p>
<ul>
<li>生成一个<strong>全局唯一</strong>的标识符 <strong>Session id</strong>。</li>
<li><strong>开辟数据存储空间</strong>来存储 Session 信息：<ul>
<li><strong>内存</strong>：速度快，系统一旦掉电，所有的会话数据就会丢失。</li>
<li><strong>文件或者数据库</strong>：增加 I/O 开销，但是可以实现某种程度上的 Session 持久化，以及 Session 的共享。</li>
</ul>
</li>
<li>将 Session id <strong>发送给客户端</strong>：<ul>
<li><strong>Cookie</strong>：服务端通过设置 Set-cookie 头就可以将 Session id 发送给客户端，而客户端此后的每一次请求都会带上这个 Session id。一般情况下，会将包含 Session id 的 Cookie 的过期时间设置为 0。</li>
<li><strong>URL 重写</strong>：返回给用户的页面里的所有的 URL 后面追加 Session id，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上 Session id。如果客户端禁用了 Cookie，这种方案就是首选。</li>
</ul>
</li>
</ul>
<h2 id="Go-实现-Session-管理"><a href="#Go-实现-Session-管理" class="headerlink" title="Go 实现 Session 管理"></a>Go 实现 Session 管理</h2><p>目前 Go 标准包没有为 Session 提供任何支持，下面手动实现 Session 的管理和创建。</p>
<h3 id="Session-管理器"><a href="#Session-管理器" class="headerlink" title="Session 管理器"></a>Session 管理器</h3><p>定义一个全局的 Session 管理器，用于 Session 的管理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	cookieName  <span class="keyword">string</span></span><br><span class="line">	lock        sync.Mutex</span><br><span class="line">	provider    Provider</span><br><span class="line">	maxLifeTime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(provideName, cookieName <span class="keyword">string</span>, maxLifeTime <span class="keyword">int64</span>)</span> <span class="params">(*Manager, error)</span></span> &#123;</span><br><span class="line">	provider, ok := provides[provideName]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;session: unknown provide %q (forgotten import?)&quot;</span>, provideName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Manager&#123;</span><br><span class="line">		cookieName:  cookieName,</span><br><span class="line">		provider:    provider,</span><br><span class="line">		maxLifeTime: maxLifeTime,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session 是保存在服务器端的数据，它可以以任何的方式存储，比如存储在内存、数据库或者文件中。因此我们抽象出一个 <strong>Provider 接口</strong>，用以表征 Session 管理器<strong>底层存储结构</strong>：</p>
<ul>
<li><code>SessionInit</code> 实现 Session 的初始化。</li>
<li><code>SessionRead</code> 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量。</li>
<li><code>SessionDestroy</code> 销毁 sid 对应的 Session 变量。</li>
<li><code>SessionGC</code> 根据 maxLifeTime 来删除过期的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Provider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// SessionInit 实现 Session 的初始化</span></span><br><span class="line">	SessionInit(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">	<span class="comment">// SessionRead 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量</span></span><br><span class="line">	SessionRead(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">	<span class="comment">// SessionDestroy 销毁 sid 对应的 Session 变量</span></span><br><span class="line">	SessionDestroy(sid <span class="keyword">string</span>) error</span><br><span class="line">	<span class="comment">// SessionGC 根据 maxLifeTime 来删除过期的数据</span></span><br><span class="line">	SessionGC(maxLifeTime <span class="keyword">int64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Session 的处理基本上就是设置值、读取值、删除值、获取当前 Session id 四种操作，所以 <strong>Session 接口</strong>定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(key, value <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// set session value</span></span><br><span class="line">	Get(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// get session value</span></span><br><span class="line">	Delete(key <span class="keyword">interface</span>&#123;&#125;) error     <span class="comment">// delete session value</span></span><br><span class="line">	SessionID() <span class="keyword">string</span>                <span class="comment">// back current sessionID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局唯一的-Session-id"><a href="#全局唯一的-Session-id" class="headerlink" title="全局唯一的 Session id"></a>全局唯一的 Session id</h3><p>Session id 用来标识每一个用户以及对应的 Session，所以必须是全局唯一的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局唯一的 session id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">sessionId</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> _, err := rand.Read(b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-的创建"><a href="#Session-的创建" class="headerlink" title="Session 的创建"></a>Session 的创建</h3><p><code>SessionStart</code> 用来检测是否已经有某个 Session 与当前来访用户发生了关联，如果没有则创建之</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SessionStart 用来检测是否已经有某个 Session 与当前来访用户发生了关联，如果没有则创建之</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionStart</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="params">(session Session)</span></span> &#123;</span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 没有 Session，创建</span></span><br><span class="line">		sid := manager.sessionId()</span><br><span class="line">		session, _ = manager.provider.SessionInit(sid)</span><br><span class="line">		cookie := &amp;http.Cookie&#123;</span><br><span class="line">			Name:     manager.cookieName,</span><br><span class="line">			Value:    url.QueryEscape(sid),</span><br><span class="line">			Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">			HttpOnly: <span class="literal">true</span>,</span><br><span class="line">			MaxAge:   <span class="keyword">int</span>(manager.maxLifeTime),</span><br><span class="line">		&#125;</span><br><span class="line">		http.SetCookie(w, cookie)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发生了关联</span></span><br><span class="line">		sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class="line">		session, _ = manager.provider.SessionRead(sid)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-销毁"><a href="#Session-销毁" class="headerlink" title="Session 销毁"></a>Session 销毁</h3><p>在销毁 Session 时，除了从存储结构中删除 Session 信息之外，还需要设置 Cookie过期。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionDestroy</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 上锁</span></span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	<span class="comment">// 从存储结构中删除</span></span><br><span class="line">	manager.provider.SessionDestroy(cookie.Value)</span><br><span class="line">	<span class="comment">// 设置 Cookie</span></span><br><span class="line">	expiration := time.Now()</span><br><span class="line">	cookie = &amp;http.Cookie&#123;</span><br><span class="line">		Name:     manager.cookieName,</span><br><span class="line">		Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">		HttpOnly: <span class="literal">true</span>,</span><br><span class="line">		Expires:  expiration,</span><br><span class="line">		MaxAge:   <span class="number">-1</span>, <span class="comment">// 立即删除session</span></span><br><span class="line">	&#125;</span><br><span class="line">	http.SetCookie(w, cookie)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过期-Session-清理"><a href="#过期-Session-清理" class="headerlink" title="过期 Session 清理"></a>过期 Session 清理</h3><p>GC 利用了 <strong>time 包的定时器功能</strong>，当超时之后调用 GC 清理过期数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC 删除过期数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	manager.provider.SessionGC(manager.maxLifeTime)</span><br><span class="line">	time.AfterFunc(time.Duration(manager.maxLifeTime), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		manager.GC()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-实现-Session-存储"><a href="#Go-实现-Session-存储" class="headerlink" title="Go 实现 Session 存储"></a>Go 实现 Session 存储</h2><p>在上一节中，定义了 Session 管理器 <strong>session.Manager</strong>，以及两个接口 <strong>session.Provider</strong> 和 <strong>session.Session</strong>，这两个接口用于存储 Session 数据。本节将实现一个基于内存的 Session 存储方式。</p>
<h3 id="Provider-接口实现"><a href="#Provider-接口实现" class="headerlink" title="Provider 接口实现"></a>Provider 接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock     sync.Mutex               <span class="comment">// 用来锁</span></span><br><span class="line">	sessions <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element <span class="comment">// 用来存储在内存</span></span><br><span class="line">	list     *list.List               <span class="comment">// 用来做 gc，按照 SessionStore.timeAccessed 最近访问时间排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provider 实现 session.Session 接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionInit 实现 Session 的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionInit</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">	v := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	newSess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class="line">	element := p.list.PushFront(newSess)</span><br><span class="line">	p.sessions[sid] = element</span><br><span class="line">	<span class="keyword">return</span> newSess, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionRead 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionRead</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		<span class="comment">// 已存在 Session</span></span><br><span class="line">		<span class="keyword">return</span> element.Value.(*SessionStore), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 未存在，新建Session</span></span><br><span class="line">	sess, err := p.SessionInit(sid)</span><br><span class="line">	<span class="keyword">return</span> sess, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionDestroy 销毁 sid 对应的 Session 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionDestroy</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		<span class="comment">// Session 已存在</span></span><br><span class="line">		<span class="comment">// 从字典中删除</span></span><br><span class="line">		<span class="built_in">delete</span>(p.sessions, sid)</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		p.list.Remove(element)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionGC 根据 maxLifeTime 来删除过期的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionGC</span><span class="params">(maxLifeTime <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		element := p.list.Back()</span><br><span class="line">		<span class="keyword">if</span> element.Value.(*SessionStore).timeAccessed.Unix()+maxLifeTime &lt; time.Now().Unix() &#123;</span><br><span class="line">			<span class="comment">// 超时，清理 Session</span></span><br><span class="line">			<span class="comment">// 从字典中删除</span></span><br><span class="line">			<span class="built_in">delete</span>(p.sessions, element.Value.(*SessionStore).sid)</span><br><span class="line">			<span class="comment">// 从链表中删除</span></span><br><span class="line">			p.list.Remove(element)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionUpdate 用于更新最近访问时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionUpdate</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class="line">		p.list.MoveToFront(element)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-接口实现"><a href="#Session-接口实现" class="headerlink" title="Session 接口实现"></a>Session 接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SessionStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	sid          <span class="keyword">string</span>                      <span class="comment">// session id</span></span><br><span class="line">	timeAccessed time.Time                   <span class="comment">// 最后访问的时间</span></span><br><span class="line">	value        <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// session 存储的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	p = &amp;Provider&#123;list: list.New()&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 设置值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	st.value[key] = value</span><br><span class="line">	<span class="keyword">return</span> p.SessionUpdate(st.sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	p.SessionUpdate(st.sid)</span><br><span class="line">	<span class="keyword">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 删除值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(st.value, key)</span><br><span class="line">	<span class="keyword">return</span> p.SessionUpdate(st.sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionID 获取 sid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">SessionID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> st.sid</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化以及注册-Provider"><a href="#初始化以及注册-Provider" class="headerlink" title="初始化以及注册 Provider"></a>初始化以及注册 Provider</h3><p>初始化以及在 <strong>session.Manager</strong> 中<strong>注册</strong>该基于内存的 Provider。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element, <span class="number">0</span>)</span><br><span class="line">	session.Register(<span class="string">&quot;memory&quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>当 import 的时候已经执行了 memory 函数里面的 init 函数，这样就已经注册到 session 管理器中，我们就可以使用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">	_ <span class="string">&quot;go-web-demo/ch6/session/providers/memory&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	globalSessions, _ = session.NewManager(<span class="string">&quot;memory&quot;</span>, <span class="string">&quot;gosessionid&quot;</span>, <span class="number">3600</span>)</span><br><span class="line">    <span class="comment">// 开一个线程启动 GC</span></span><br><span class="line">	<span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防范-Session-劫持"><a href="#防范-Session-劫持" class="headerlink" title="防范 Session 劫持"></a>防范 Session 劫持</h1><h2 id="httponly-和-token"><a href="#httponly-和-token" class="headerlink" title="httponly 和 token"></a>httponly 和 token</h2><p>第一种方案通过 <strong>httponly + token</strong> 来预防 Session 劫持：</p>
<ul>
<li>可以设置 Session id 的值只能由 Cookie 进行设置，同时设置 <strong>httponly</strong> 为 true，这个属性可以防止通过客户端脚本访问到 Cookie，进而防止攻击者读取到 Cookie 中的 Session id。</li>
<li>在每个请求里面加上 token，然后每一次验证 token，从而保证用户的请求都是唯一性。</li>
</ul>
<h2 id="间隔生成新的-Sesseion-id"><a href="#间隔生成新的-Sesseion-id" class="headerlink" title="间隔生成新的 Sesseion id"></a>间隔生成新的 Sesseion id</h2><p>第二种方案是给 Session 额外设置一个<strong>创建时间</strong>的值，一旦过了一定的时间，就销毁这个 Session id，重新生成 Session。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过期时间 60s</span></span><br><span class="line">expires := <span class="number">60</span></span><br><span class="line"></span><br><span class="line">createTime := sess.Get(<span class="string">&quot;createtime&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> createTime == <span class="literal">nil</span> &#123;</span><br><span class="line">    sess.Set(<span class="string">&quot;createtime&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> createTime.(<span class="keyword">int64</span>) + expires &lt; time.Now().Unix() &#123;</span><br><span class="line">    <span class="comment">// 当前 Session 过期，重新分配 Session</span></span><br><span class="line">    globalSessions.SessionDestroy(w, r)</span><br><span class="line">    sess = globalSessions.SessionStart(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为 Session 设置了一个值，用于记录生成 Session id 的时间。每次请求都判断是否过期，如果过期，则分配新的 Session id。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面两个手段的组合可以在实践中消除 session 劫持的风险：</p>
<ul>
<li><p><strong>Session id 的频繁改变</strong>，使得攻击者很难获取到有效的 Session id。</p>
</li>
<li><p>Session 只在 Cookie 中传递，并且设置了 <strong>httponly</strong> 选项，可以有效阻止通过客户端脚本访问到 Cookie，也可以预防 XSS 攻击获取 Cookie。</p>
</li>
<li><p>还可以设置 <strong>MaxAge=0</strong>，这样 Cookie 就不会存储在浏览器的记录中，随着浏览器关闭 Cookie 也随机消失。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/14/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E8%A1%A8%E5%8D%95%E5%92%8C%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/14/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E8%A1%A8%E5%8D%95%E5%92%8C%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (2) 表单和访问数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-14 14:31:48" itemprop="dateCreated datePublished" datetime="2022-05-14T14:31:48+08:00">2022-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="处理表单输入"><a href="#处理表单输入" class="headerlink" title="处理表单输入"></a>处理表单输入</h2><p>编写 <code>login.gtpl</code> 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>处理登录的逻辑，其中 <code>r.ParseForm()</code> 方法用于<strong>解析参数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &#123;</span><br><span class="line">		<span class="comment">// 如果是 GET 请求</span></span><br><span class="line">		t, _ := template.ParseFiles(<span class="string">&quot;./login.gtpl&quot;</span>)</span><br><span class="line">		log.Println(t.Execute(w, <span class="literal">nil</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是 POST 请求</span></span><br><span class="line">		err := r.ParseForm()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;ParseForm error:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;username:&quot;</span>, r.Form[<span class="string">&quot;username&quot;</span>])</span><br><span class="line">		fmt.Println(<span class="string">&quot;password:&quot;</span>, r.Form[<span class="string">&quot;password&quot;</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/login&quot;</span>, login)         <span class="comment">// 设置访问的路由</span></span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>r.Form</strong> 里面包含了所有请求的参数，比如 URL 中 <strong>query-string</strong>、<strong>POST 的数据</strong>、<strong>PUT 的数据</strong>，所以当你在 URL 中的 query-string 字段和 POST 冲突时，会保存成一个 <strong>slice</strong>，里面存储了多个值。</p>
<p><strong>r.From</strong> 是一个 <strong>url.Values</strong> 类型的值，可以对其进行一些操作（ <strong>Get、Set、Add、Del、Has</strong> ）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key.</span></span><br><span class="line"><span class="comment">// If there are no values associated with the key, Get returns</span></span><br><span class="line"><span class="comment">// the empty string. To access multiple values, use the map</span></span><br><span class="line"><span class="comment">// directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	vs := v[key]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(vs) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the key to value. It replaces any existing</span></span><br><span class="line"><span class="comment">// values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	v[key] = []<span class="keyword">string</span>&#123;value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the value to key. It appends to any existing</span></span><br><span class="line"><span class="comment">// values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	v[key] = <span class="built_in">append</span>(v[key], value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del deletes the values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(v, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has checks whether a given key is set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Has</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	_, ok := v[key]</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>在处理表单的逻辑事，不要忘了对<strong>表单的输入的验证</strong>，不能信任用户输入的任何信息。</p>
<hr>
<h2 id="预防跨站脚本"><a href="#预防跨站脚本" class="headerlink" title="预防跨站脚本"></a>预防跨站脚本</h2><p>对 XSS 的防护主要在于两方面：</p>
<ul>
<li>对<strong>输入</strong>的验证，检测攻击。</li>
<li>对所有<strong>输出</strong>数据进行适当的处理，以防止任何已成功注入的脚本在浏览器端运行。</li>
</ul>
<p>对于对输出数据的处理，Go 的 <strong>html/template</strong> 里面带有下面几个函数可以<strong>转义</strong>：</p>
<ul>
<li><code>func HTMLEscape (w io.Writer, b [] byte)</code>：把 b 进行转义之后写到 w 中。</li>
<li><code>func HTMLEscapeString (s string) string</code>：转义 s 之后返回结果字符串。</li>
<li><code>func HTMLEscaper (args ...interface &#123;&#125;) string</code>：支持多个参数一起转义，返回结果字符串</li>
</ul>
<p>如果需要输出 HTML 标签，可以使用 <strong>template.HTML</strong> 类型，它用于封装一个<strong>已知安全的 HTML 文档片段</strong>。它不应被第三方使用，也不能用于含有未闭合的标签或注释的 HTML 文本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;html/template&quot;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">t, err := template.New(<span class="string">&quot;foo&quot;</span>).Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">&quot;T&quot;</span>, template.HTML(<span class="string">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="防止多次提交表单"><a href="#防止多次提交表单" class="headerlink" title="防止多次提交表单"></a>防止多次提交表单</h2><p>解决方案是在表单中添加一个<strong>带有唯一值的隐藏字段</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在验证表单时，先<strong>检查带有该唯一值（ 如 MD5(时间戳) ）的表单</strong>是否已经递交过了：</p>
<ul>
<li>如果是，拒绝再次递交。</li>
<li>如果不是，则处理表单进行逻辑处理。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">&quot;GET&quot;</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        <span class="comment">// 通过 md5(时间戳) 构造token</span></span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">&quot;login.gtpl&quot;</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">        r.ParseForm()</span><br><span class="line">        token := r.Form.Get(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 验证 token 的合法性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不存在 token 报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;username length:&quot;</span>, <span class="built_in">len</span>(r.Form[<span class="string">&quot;username&quot;</span>][<span class="number">0</span>]))</span><br><span class="line">        fmt.Println(<span class="string">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到服务器端</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;password&quot;</span>)))</span><br><span class="line">        template.HTMLEscape(w, []<span class="keyword">byte</span>(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h2><h3 id="form-的-enctype-属性"><a href="#form-的-enctype-属性" class="headerlink" title="form 的 enctype 属性"></a>form 的 enctype 属性</h3><p>form 表单的 enctype 属性指明了发送到服务器时时浏览器使用的编码类型，有三种取值：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code> ：<strong>默认</strong>编码类型，在发送前编码所有的字符。</li>
<li><code>multipart/form-data</code> ：不对字符进行编码，指定传输的数据为<strong>二进制</strong>类型，所以可以用于文件上传。</li>
<li><code>text/plain</code> ：空格转换为 “+” 加号，但不对特殊字符编码。</li>
</ul>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>创建名为 <code>upload.gtpl</code> 的模板文件用于文件上传：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadfile&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写服务器文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &#123;</span><br><span class="line">		<span class="comment">// 若是 GET 请求</span></span><br><span class="line">		curTime := time.Now().Unix() <span class="comment">// 获取当前时间的时间戳</span></span><br><span class="line">		h := md5.New()</span><br><span class="line">		_, err := io.WriteString(h, strconv.FormatInt(curTime, <span class="number">10</span>)) <span class="comment">// 将时间戳进行 md5 加密</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 渲染页面</span></span><br><span class="line">		t, _ := template.ParseFiles(<span class="string">&quot;upload.gtpl&quot;</span>)</span><br><span class="line">		t.Execute(w, token)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// POST 请求</span></span><br><span class="line">		r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">		file, handler, err := r.FormFile(<span class="string">&quot;uploadfile&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;%v&quot;</span>, handler.Header)</span><br><span class="line">		f, err := os.OpenFile(<span class="string">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>) <span class="comment">// 此处假设当前目录下已存在test目录</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">		io.Copy(f, file)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/upload&quot;</span>, upload)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理文件上传需要调用 <code>r.ParseMultipartForm( maxMemory )</code> 函数，其中 <code>maxMemroy</code> 表示文件存储在内存中的大小，如果文件大小超过了该值，则剩余的部分将存储在系统的临时文件中。使用 <code>r.FormFile</code> 函数可以获取文件句柄以及文件属性。</p>
<p>其中，文件 handler 的类型为 *<strong>multipart.FileHeader</strong>，结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileHeader describes a file part of a multipart request.</span></span><br><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Filename <span class="keyword">string</span></span><br><span class="line">	Header   textproto.MIMEHeader</span><br><span class="line">	Size     <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 非导出字段</span></span><br><span class="line">	content []<span class="keyword">byte</span></span><br><span class="line">	tmpfile <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><h2 id="database-sql-接口"><a href="#database-sql-接口" class="headerlink" title="database/sql 接口"></a>database/sql 接口</h2><p>Go 定义了了一些标准的接口，开发者可以根据定义的接口来开发相应的数据库驱动。</p>
<h3 id="sql-Register"><a href="#sql-Register" class="headerlink" title="sql.Register"></a>sql.Register</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span></span><br></pre></td></tr></table></figure>

<p>Register <strong>注册并命名</strong>一个数据库，可以在 Open 函数中使用该命名启用该驱动。</p>
<p>mymysql、sqlite3的驱动通过 <code>init()</code> 函数注册自己的数据库驱动名称以及相应的 driver 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/mattn/go-sqlite3 驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sql.Register(<span class="string">&quot;sqlite3&quot;</span>, &amp;SQLiteDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/mikespook/mymysql 驱动</span></span><br><span class="line"><span class="comment">// Driver automatically registered in database/sql</span></span><br><span class="line"><span class="keyword">var</span> d = Driver&#123;proto: <span class="string">&quot;tcp&quot;</span>, raddr: <span class="string">&quot;127.0.0.1:3306&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Register(<span class="string">&quot;SET NAMES utf8&quot;</span>)</span><br><span class="line">    sql.Register(<span class="string">&quot;mymysql&quot;</span>, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 database/sql 内部，通过一个 <strong>map</strong> 来存储用户定义的驱动，所以可以通过注册函数 Register 同时注册多个数据库驱动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drivers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</span><br></pre></td></tr></table></figure>

<h3 id="sql-DB"><a href="#sql-DB" class="headerlink" title="sql.DB"></a>sql.DB</h3><p>DB 中 freeConn 是一个简易的<strong>连接池</strong>，它的实现相当的简单：</p>
<ul>
<li>当执行 <code>db.prepare</code> -&gt; <code>db.prepareDC</code> 的时候会 <code>defer dc.releaseConn</code>。</li>
<li>调用<code>db.putConn</code>，也就是把这个连接放入连接池。</li>
<li>每次调用 <code>db.conn</code> 的时候会先判断 freeConn 的长度是否大于 0，大于 0 说明有可以复用的 conn，直接拿出来用就是了，如果不大于 0，则创建一个 conn，然后再返回之。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    driver   driver.Driver</span><br><span class="line">    dsn      <span class="keyword">string</span></span><br><span class="line">    mu       sync.Mutex <span class="comment">// protects freeConn and closed</span></span><br><span class="line">    freeConn []driver.Conn</span><br><span class="line">    closed   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-Driver"><a href="#driver-Driver" class="headerlink" title="driver.Driver"></a>driver.Driver</h3><p>Driver 是一个数据库驱动接口，它定义了一个方法 <strong>Open</strong>，这个方法返回一个数据库 <strong>Conn</strong> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Open返回一个新的与数据库的连接，参数name的格式是驱动特定的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open可能返回一个缓存的连接（之前关闭的连接），但这么做是不必要的；</span></span><br><span class="line">    <span class="comment">// sql包会维护闲置连接池以便有效的重用连接。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回的连接同一时间只会被一个go程使用。</span></span><br><span class="line">    Open(name <span class="keyword">string</span>) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，返回的 Conn 连接同一时间只能被一个 goroutine 使用。</p>
<h3 id="driver-Conn"><a href="#driver-Conn" class="headerlink" title="driver.Conn"></a>driver.Conn</h3><p>Conn 是一个数据库连接的接口定义，他定义了一系列方法，这个 Conn 只能应用在一个 goroutine 里面，不能使用在多个 goroutine 里面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Prepare返回一个准备好的、绑定到该连接的状态。</span></span><br><span class="line">    Prepare(query <span class="keyword">string</span>) (Stmt, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close作废并停止任何现在准备好的状态和事务，将该连接标注为不再使用。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 因为sql包维护着一个连接池，只有当闲置连接过剩时才会调用Close方法，</span></span><br><span class="line">    <span class="comment">// 驱动的实现中不需要添加自己的连接缓存池。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin开始并返回一个新的事务。</span></span><br><span class="line">    Begin() (Tx, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Prepare</strong> 函数返回与当前连接相关的执行 SQL 语句的<strong>准备状态</strong>，可以进行查询、删除等操作。</li>
<li><strong>Close</strong> 函数<strong>关闭</strong>当前的连接，执行释放连接拥有的资源等清理工作。因为驱动实现了 database/sql 里面建议的 conn pool，所以你不用再去实现缓存 conn 之类的，这样会容易引起问题。</li>
<li><strong>Begin</strong> 函数返回一个代表<strong>事务</strong>处理的 Tx，通过它你可以进行查询，更新等操作，或者对事务进行回滚、递交。</li>
</ul>
<h3 id="driver-Stmt"><a href="#driver-Stmt" class="headerlink" title="driver.Stmt"></a>driver.Stmt</h3><p>Stmt 是一种准备好的状态，和 Conn 相关联（ Stmt会绑定到一个连接 ），而且只能应用于一个 goroutine 中，不能应用于多个 goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Close关闭Stmt。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 和Go1.1一样，如果Stmt被任何查询使用中的话，将不会被关闭。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NumInput返回占位参数的个数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果NumInput返回值 &gt;= 0，sql包会提前检查调用者提供的参数个数，</span></span><br><span class="line">    <span class="comment">// 并且会在调用Exec或Query方法前返回数目不对的错误。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NumInput可以返回-1，如果驱动占位参数的数量。</span></span><br><span class="line">    <span class="comment">// 此时sql包不会提前检查参数个数。</span></span><br><span class="line">    NumInput() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec执行查询，而不会返回结果，如insert或update。</span></span><br><span class="line">    Exec(args []Value) (Result, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query执行查询并返回结果，如select。</span></span><br><span class="line">    Query(args []Value) (Rows, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Close</strong> 函数<strong>关闭</strong>当前的链接状态，但是如果当前正在执行 query，query 还是有效返回 rows 数据。</li>
<li><strong>NumInput</strong> 函数返回<strong>当前预留参数的个数</strong>，当返回 &gt;=0 时数据库驱动就会智能检查调用者的参数。当数据库驱动包不知道预留参数的时候，返回 -1。</li>
<li><strong>Exec</strong> 函数执行 Prepare 准备好的 SQL，传入参数执行 <strong>update/insert</strong> 等操作，返回 Result 数据。</li>
<li><strong>Query</strong> 函数执行 Prepare 准备好的 SQL，传入需要的参数执行 <strong>select</strong> 操作，返回 Rows 结果集。</li>
</ul>
<h3 id="driver-Tx"><a href="#driver-Tx" class="headerlink" title="driver.Tx"></a>driver.Tx</h3><p>事务处理一般就两个过程，递交或者回滚。数据库驱动里面也只需要实现这两个函数就可以。Tx 代表一次<strong>事务</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tx <span class="keyword">interface</span> &#123;</span><br><span class="line">    Commit() error</span><br><span class="line">    Rollback() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-Execer"><a href="#driver-Execer" class="headerlink" title="driver.Execer"></a>driver.Execer</h3><p>这是一个 Conn 可选择实现的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec(query <span class="keyword">string</span>, args []Value) (Result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个接口没有定义，那么在调用 <strong>DB.Exec</strong>，就会首先调用 <strong>Prepare</strong> 返回 <strong>Stmt</strong>，然后执行 <strong>Stmt</strong> 的 <strong>Exec</strong>，然后关闭 <strong>Stmt</strong>。</p>
<h3 id="driver-Result"><a href="#driver-Result" class="headerlink" title="driver.Result"></a>driver.Result</h3><p>这个是执行 <strong>Update/Insert</strong> 等操作返回的结果接口定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// LastInsertId返回insert等命令后数据库自动生成的ID</span></span><br><span class="line">    LastInsertId() (<span class="keyword">int64</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RowsAffected返回被查询影响的行数</span></span><br><span class="line">    RowsAffected() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>LastInsertId</strong> 函数返回由数据库执行插入操作得到的<strong>自增 ID 号</strong>。</p>
</li>
<li><p><strong>RowsAffected</strong> 函数返回 query 操作影响的数据条目数。</p>
</li>
</ul>
<h3 id="driver-Rows"><a href="#driver-Rows" class="headerlink" title="driver.Rows"></a>driver.Rows</h3><p>Rows 是执行查询得到的结果的迭代器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rows <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Columns返回各列的名称，列的数量可以从切片长度确定。</span></span><br><span class="line">    <span class="comment">// 如果某个列的名称未知，对应的条目应为空字符串。</span></span><br><span class="line">    Columns() []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close关闭Rows。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Next方法以将下一行数据填充进提供的切片中。</span></span><br><span class="line">    <span class="comment">// 提供的切片必须和Columns返回的切片长度相同。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 切片dest可能被填充同一种驱动Value类型，但字符串除外。</span></span><br><span class="line">    <span class="comment">// 所有string值都必须转换为[]byte。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 当没有更多行时，Next应返回io.EOF。</span></span><br><span class="line">    Next(dest []Value) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Columns</strong> 函数返回查询数据库表的字段信息，这个返回的 slice 和 sql 查询的字段一一对应，而不是返回整个表的所有字段。</li>
<li><strong>Close</strong> 函数用来关闭 Rows 迭代器。</li>
<li><strong>Next</strong> 函数用来返回下一条数据，把数据赋值给 <strong>dest</strong>。dest 里面的元素必须是 driver.Value 的值除了 string，返回的数据里面所有的 string 都必须要转换成 [] byte。如果最后没数据了，Next 函数最后返回 io.EOF。</li>
</ul>
<h3 id="driver-RowsAffected"><a href="#driver-RowsAffected" class="headerlink" title="driver.RowsAffected"></a>driver.RowsAffected</h3><p>RowsAffected 其实就是一个 int64 的别名，但是他<strong>实现了 Result 接口</strong>，用于 <strong>insert</strong> 或 <strong>update</strong> 操作，这些操作会修改零到多行数据。：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RowsAffected <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(RowsAffected)</span> <span class="title">LastInsertId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v RowsAffected)</span> <span class="title">RowsAffected</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="driver-Value"><a href="#driver-Value" class="headerlink" title="driver.Value"></a>driver.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Value 是驱动必须能处理的值。它要么是nil，要么是如下类型的实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span></span><br><span class="line"><span class="keyword">float64</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">[]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">string</span>   [*] Rows.Next不会返回该类型值</span><br><span class="line">time.Time</span><br></pre></td></tr></table></figure>

<h3 id="driver-ValueConverter"><a href="#driver-ValueConverter" class="headerlink" title="driver.ValueConverter"></a>driver.ValueConverter</h3><p>ValueConverter 接口定义了如何把一个普通的值转化成 driver.Value 的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValueConverter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ConvertValue(v <span class="keyword">interface</span>&#123;&#125;) (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发的数据库驱动包里面实现这个接口的函数在很多地方会使用到，这个 ValueConverter 有很多好处：</p>
<ul>
<li>转化 driver.value 到数据库表相应的字段，例如 int64 的数据如何转化成数据库表 uint16 字段。</li>
<li>把数据库查询结果转化成 driver.Value 值。</li>
<li>在 scan 函数里面如何把 driver.Value 值转化成用户定义的值。</li>
</ul>
<h3 id="driver-Valuer"><a href="#driver-Valuer" class="headerlink" title="driver.Valuer"></a>driver.Valuer</h3><p>Valuer 接口定义了返回一个 driver.Value 的方式，很多类型都实现了这个 Value 方法，用来自身与 driver.Value 的转化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Value() (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p><strong>github.com/go-sql-driver/mysql</strong> 为支持 MySQL 的驱动，它支持 database/sql 标准。</p>
<h3 id="打开驱动"><a href="#打开驱动" class="headerlink" title="打开驱动"></a>打开驱动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开驱动</span></span><br><span class="line">dsn := <span class="string">&quot;user:password@tcp(ip:port)/dbname?charset=utf8&quot;</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">stmt, err := db.Prepare(<span class="string">&quot;INSERT userinfo SET username=?,department=?,created=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="string">&quot;dawn&quot;</span>, <span class="string">&quot;研发部门&quot;</span>, <span class="string">&quot;2022-05-15&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(id)</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">stmt, err = db.Prepare(<span class="string">&quot;update userinfo set username=? where uid=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err = stmt.Exec(<span class="string">&quot;zh&quot;</span>, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">affect, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(affect)</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * FROM userinfo&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> department <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> created <span class="keyword">string</span></span><br><span class="line">	err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">stmt, err = db.Prepare(<span class="string">&quot;delete from userinfo where uid=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err = stmt.Exec(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">affect, err = res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(affect)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/29/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><span class="page-number current">30</span><a class="page-number" href="/page/31/">31</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/31/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">416</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
