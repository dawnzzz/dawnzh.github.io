<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/26/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (4) 文本处理-XML JSON 模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 21:16:10" itemprop="dateCreated datePublished" datetime="2022-05-16T21:16:10+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web 开发中需要对输入、输出进行处理。</p>
<h1 id="XML-处理"><a href="#XML-处理" class="headerlink" title="XML 处理"></a>XML 处理</h1><p>示例 XML 文件如下： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span> <span class="attr">version</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Shanghai_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Beijing_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.2<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="读取-XML"><a href="#读取-XML" class="headerlink" title="读取 XML"></a>读取 XML</h2><p>读取 XML 选择 <strong>xml.Unmarshal</strong> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>将 XML 写入结构体为例，上述 XML 文件 对应的结构体为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开 XML 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.xml&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 读取文件内容</span></span><br><span class="line">	data, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 XML 转为结构体</span></span><br><span class="line">	v := Servers&#123;&#125;</span><br><span class="line">	err = xml.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;] </span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="输出-XML"><a href="#输出-XML" class="headerlink" title="输出 XML"></a>输出 XML</h2><p>xml 包提供了两个函数 Marshal 和 MarshalIndent 来输出 XML，二者的区别在于 MarshalIndent 会增加前缀和缩进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>构建结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析结构体并输出 XML ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建结构体</span></span><br><span class="line">	v := Servers&#123;Version: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Shanghai_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Beijing_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 转为 XML 数据</span></span><br><span class="line">	data, err := xml.MarshalIndent(&amp;v, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Stdout.Write([]<span class="keyword">byte</span>(xml.Header))</span><br><span class="line">	os.Stdout.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>之所以会有 <code>os.Stdout.Write([]byte(xml.Header))</code> 这句代码的出现，是因为 <code>xml.MarshalIndent</code> 或者 <code>xml.Marshal</code> 输出的信息都是<strong>不带 XML 头</strong>的，为了生成正确的 xml 文件，我们使用了 xml 包预定义的 Header 变量。</p>
<h1 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h1><p>示例 JSON 格式数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;servers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Shanghai_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Beijing_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析-JSON"><a href="#解析-JSON" class="headerlink" title="解析 JSON"></a>解析 JSON</h2><p>json 包中有如下函数可以解析 JSON 数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="解析到结构体"><a href="#解析到结构体" class="headerlink" title="解析到结构体"></a>解析到结构体</h3><p>上述 JSON 数据对应的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServerName <span class="keyword">string</span> <span class="string">`json:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span> <span class="string">`json:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	Servers []Server <span class="string">`json:&quot;servers&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 JSON 数据到结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取内容</span></span><br><span class="line">	data, _ := ioutil.ReadAll(file)</span><br><span class="line">	<span class="comment">// 解析 JSON</span></span><br><span class="line">	v := ServerSlice&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析到-interface"><a href="#解析到-interface" class="headerlink" title="解析到 interface"></a>解析到 interface</h3><p>如果知道 JSON 数据的格式，可以解析到结构体中。如果<strong>不知道 JSON 数据格式</strong>，可以利用 <strong>map [string] interface {}</strong> 和 <strong>[] interface {}</strong> 结构来存储任意的 JSON 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure>

<p>此时，空接口 f 实际上是一个 map[string] interface{}，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;servers&quot;</span>:[]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Shanghai_VPN&quot;</span>&#125;, </span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.2&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Beijing_VPN&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过类型断言将**空接口转为 map[string] interface{}**，接着就可以利用 <strong>for range</strong> 对 map 进行遍历了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>目前，<code>simplejson</code> 包可以更加容易的处理未知结构的 JSON 数据，其 github 地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/bitly/go-simplejson">github.com/bitly/go-simplejson</a></p>
<hr>
<h2 id="生成-JSON"><a href="#生成-JSON" class="headerlink" title="生成 JSON"></a>生成 JSON</h2><p>json 包提供了生成 JSON 数据的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>这里不再举例说明具体操作。</p>
<h1 id="模板处理"><a href="#模板处理" class="headerlink" title="模板处理"></a>模板处理</h1><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><h3 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h3><p>html/template 包中有两个函数可以解析模板：</p>
<ul>
<li><strong>ParseFiles 函数</strong>创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ParseGlob 函数</strong>创建一个模板并解析匹配 pattern 的文件里的模板定义。返回的模板的名字是第一个匹配的文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseGlob</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="模板执行"><a href="#模板执行" class="headerlink" title="模板执行"></a>模板执行</h3><p>html/template 包中有两个函数可以执行模板：</p>
<ul>
<li><strong>Execute 方法</strong>将解析好的模板应用到 data 上，并将输出写入 wr。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">Execute</span><span class="params">(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ExecuteTemplate 方法</strong>类似 Execute，但是使用名为 nam e的 t 关联的模板产生输出。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">ExecuteTemplate</span><span class="params">(wr io.Writer, name <span class="keyword">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="模板中插入数据"><a href="#模板中插入数据" class="headerlink" title="模板中插入数据"></a>模板中插入数据</h2><ul>
<li><p><strong>字段操作</strong>：<code>&#123;&#123;.&#125;&#125;</code> 代表<strong>当前对象</strong>，可以通过 <code>&#123;&#123;.FieldName&#125;&#125;</code> 访问当前对象的<strong>字段</strong>。</p>
</li>
<li><p><strong>输出嵌套字段</strong>：</p>
<ul>
<li><code>&#123;&#123;with …&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 可以指定当前对象的值，如子结构体。</li>
<li><code>&#123;&#123;range …&#125;&#125;&#123;&#123;end&#125;&#125;</code> 可以循环操作数据。</li>
</ul>
</li>
<li><p><strong>条件判断</strong>：<code>&#123;&#123;if …&#125;&#125;…&#123;&#123;else if …&#125;&#125;…&#123;&#123;else&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 语句可以进行条件判断。</p>
</li>
<li><p><strong>pipelines</strong>：在 <code>&#123;&#123;&#125;&#125;</code> 中的都是 pipeline，如 <code>&#123;&#123;. | html&#125;&#125;</code> 可以将当前对象进行 HTML 转义，变为 HTML 实体。</p>
</li>
<li><p><strong>模板变量</strong>：可以通过 <code>$variable := pipeline</code> 方式声明模板局部变量。</p>
</li>
<li><p><strong>模板嵌套</strong>：</p>
<ul>
<li>声明：<code>&#123;&#123;define "子模板名称"&#125;&#125;内容&#123;&#123;end&#125;&#125;</code></li>
<li>调用：<code>&#123;&#123;template "子模板名称"&#125;&#125;</code></li>
</ul>
</li>
<li><p><strong>模板函数</strong>：</p>
<ul>
<li>每一个模板函数都有一个唯一的名字，可以与一个 Go 函数相关联。<strong>FuncMap</strong> 类型定义了函数名字符串到函数的映射，每个函数都必须<strong>有 1 到 2 个返回值</strong>，如果有 2 个则<strong>后一个必须是 error 接口类型</strong>；如果有 2 个返回值的方法返回的 error 非 nil ，模板执行会中断并返回给调用者该错误。：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>t.Funcs</code> 函数在模板中注册函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = t.Funcs(template.FuncMap&#123;<span class="string">&quot;TmplFuncName&quot;</span>: FuncName&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在模板包内部已经有内置的实现函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builtins = FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;and&quot;</span>:      and,</span><br><span class="line">    <span class="string">&quot;call&quot;</span>:     call,</span><br><span class="line">    <span class="string">&quot;html&quot;</span>:     HTMLEscaper,</span><br><span class="line">    <span class="string">&quot;index&quot;</span>:    index,</span><br><span class="line">    <span class="string">&quot;js&quot;</span>:       JSEscaper,</span><br><span class="line">    <span class="string">&quot;len&quot;</span>:      length,</span><br><span class="line">    <span class="string">&quot;not&quot;</span>:      not,</span><br><span class="line">    <span class="string">&quot;or&quot;</span>:       or,</span><br><span class="line">    <span class="string">&quot;print&quot;</span>:    fmt.Sprint,</span><br><span class="line">    <span class="string">&quot;printf&quot;</span>:   fmt.Sprintf,</span><br><span class="line">    <span class="string">&quot;println&quot;</span>:  fmt.Sprintln,</span><br><span class="line">    <span class="string">&quot;urlquery&quot;</span>: URLQueryEscaper,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Must-操作"><a href="#Must-操作" class="headerlink" title="Must 操作"></a>Must 操作</h2><p>Must 函数用来检查模板是否正确：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Must</span><span class="params">(t *Template, err error)</span> *<span class="title">Template</span></span></span><br></pre></td></tr></table></figure>

<p>一般用于变量初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;html&quot;</span>))</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (3) Session和数据存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 09:06:46" itemprop="dateCreated datePublished" datetime="2022-05-16T09:06:46+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是由<strong>浏览器</strong>维持的，保存在<strong>客户端</strong>的一段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。通过 Cookie，服务器就可以验证 Cookie 信息、记录用户状态。</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/6.1.cookie2.png" alt="img"></p>
<p>Cookie 是有时间限制的，根据生命周期不同分为会话 Cookie 和持久 Cookie：</p>
<ul>
<li><strong>会话 Cookie</strong>：不设置生命周期的默认值，表示这个 Cookie 的生命周期到<strong>浏览器关闭为止</strong>，会话 Cookie 一般保存在<strong>内存</strong>中。</li>
<li><strong>持久 Cookie</strong>：设置了过期时间时，浏览器就会将 Cookie 保存在<strong>硬盘</strong>上，有效期直到超过了过期时间。</li>
</ul>
<h3 id="Go-设置-Cookie"><a href="#Go-设置-Cookie" class="headerlink" title="Go 设置 Cookie"></a>Go 设置 Cookie</h3><p>Go 语言中，通过 net/http 包中的 <strong>SetCookie</strong> 来设置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure>

<p>Cookie 结构体结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span></span><br><span class="line">    Value      <span class="keyword">string</span></span><br><span class="line">    Path       <span class="keyword">string</span></span><br><span class="line">    Domain     <span class="keyword">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于&quot;Max-Age: 0&quot;</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="keyword">int</span></span><br><span class="line">    Secure   <span class="keyword">bool</span></span><br><span class="line">    HttpOnly <span class="keyword">bool</span></span><br><span class="line">    Raw      <span class="keyword">string</span></span><br><span class="line">    Unparsed []<span class="keyword">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 Cookie 例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">expiration := time.Now()</span><br><span class="line">expiration = expiration.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 实例化 Cookie对象</span></span><br><span class="line">cookie := &amp;http.Cookie&#123;</span><br><span class="line">    Name: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">    Value: <span class="string">&quot;dawn&quot;</span>,</span><br><span class="line">    Expires: expiration,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入 HTTP 响应</span></span><br><span class="line">http.SetCookie(w, cookie)</span><br></pre></td></tr></table></figure>

<h3 id="Go-读取-Cookie"><a href="#Go-读取-Cookie" class="headerlink" title="Go 读取 Cookie"></a>Go 读取 Cookie</h3><p>Go 语言中，使用 <strong>r.Cookie</strong> 根据 name 读取 Cookie：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span></span></span><br></pre></td></tr></table></figure>

<p>还可以通过 <strong>r.Cookies</strong> 一次性得到所有的 Cookie 信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是一种<strong>服务器端</strong>的机制，服务器使用一种类似于散列表的结构来保存信息。服务器使用 <strong>Session id</strong> 来标识 Session 信息，它由服务器端产生，相当于一个密钥。可以借助 <strong>Cookie</strong> 或者 <strong>GET 请求</strong>方式传输 Session id。</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Session%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/6.1.session.png" alt="img"></p>
<hr>
<p><strong>总结</strong>：</p>
<ul>
<li>Session 和 Cookie 机制都是为了克服 HTTP 协议的无状态缺陷，用于记录用户状态。</li>
<li>Session 依托 Cookie 实现，将 Session id 保存在 Cookie 中。</li>
<li>Cookie 因为将所有信息都保存在客户端中，发起请求时会携带这些信息，所以有一定的安全隐患。</li>
</ul>
<hr>
<h1 id="Go-实现-Session"><a href="#Go-实现-Session" class="headerlink" title="Go 实现 Session"></a>Go 实现 Session</h1><h2 id="Session-创建过程"><a href="#Session-创建过程" class="headerlink" title="Session 创建过程"></a>Session 创建过程</h2><p>服务器端在创建 Session 时会分为三个步骤：</p>
<ul>
<li>生成一个<strong>全局唯一</strong>的标识符 <strong>Session id</strong>。</li>
<li><strong>开辟数据存储空间</strong>来存储 Session 信息：<ul>
<li><strong>内存</strong>：速度快，系统一旦掉电，所有的会话数据就会丢失。</li>
<li><strong>文件或者数据库</strong>：增加 I/O 开销，但是可以实现某种程度上的 Session 持久化，以及 Session 的共享。</li>
</ul>
</li>
<li>将 Session id <strong>发送给客户端</strong>：<ul>
<li><strong>Cookie</strong>：服务端通过设置 Set-cookie 头就可以将 Session id 发送给客户端，而客户端此后的每一次请求都会带上这个 Session id。一般情况下，会将包含 Session id 的 Cookie 的过期时间设置为 0。</li>
<li><strong>URL 重写</strong>：返回给用户的页面里的所有的 URL 后面追加 Session id，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上 Session id。如果客户端禁用了 Cookie，这种方案就是首选。</li>
</ul>
</li>
</ul>
<h2 id="Go-实现-Session-管理"><a href="#Go-实现-Session-管理" class="headerlink" title="Go 实现 Session 管理"></a>Go 实现 Session 管理</h2><p>目前 Go 标准包没有为 Session 提供任何支持，下面手动实现 Session 的管理和创建。</p>
<h3 id="Session-管理器"><a href="#Session-管理器" class="headerlink" title="Session 管理器"></a>Session 管理器</h3><p>定义一个全局的 Session 管理器，用于 Session 的管理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	cookieName  <span class="keyword">string</span></span><br><span class="line">	lock        sync.Mutex</span><br><span class="line">	provider    Provider</span><br><span class="line">	maxLifeTime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(provideName, cookieName <span class="keyword">string</span>, maxLifeTime <span class="keyword">int64</span>)</span> <span class="params">(*Manager, error)</span></span> &#123;</span><br><span class="line">	provider, ok := provides[provideName]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;session: unknown provide %q (forgotten import?)&quot;</span>, provideName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Manager&#123;</span><br><span class="line">		cookieName:  cookieName,</span><br><span class="line">		provider:    provider,</span><br><span class="line">		maxLifeTime: maxLifeTime,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session 是保存在服务器端的数据，它可以以任何的方式存储，比如存储在内存、数据库或者文件中。因此我们抽象出一个 <strong>Provider 接口</strong>，用以表征 Session 管理器<strong>底层存储结构</strong>：</p>
<ul>
<li><code>SessionInit</code> 实现 Session 的初始化。</li>
<li><code>SessionRead</code> 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量。</li>
<li><code>SessionDestroy</code> 销毁 sid 对应的 Session 变量。</li>
<li><code>SessionGC</code> 根据 maxLifeTime 来删除过期的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Provider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// SessionInit 实现 Session 的初始化</span></span><br><span class="line">	SessionInit(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">	<span class="comment">// SessionRead 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量</span></span><br><span class="line">	SessionRead(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">	<span class="comment">// SessionDestroy 销毁 sid 对应的 Session 变量</span></span><br><span class="line">	SessionDestroy(sid <span class="keyword">string</span>) error</span><br><span class="line">	<span class="comment">// SessionGC 根据 maxLifeTime 来删除过期的数据</span></span><br><span class="line">	SessionGC(maxLifeTime <span class="keyword">int64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Session 的处理基本上就是设置值、读取值、删除值、获取当前 Session id 四种操作，所以 <strong>Session 接口</strong>定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(key, value <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// set session value</span></span><br><span class="line">	Get(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// get session value</span></span><br><span class="line">	Delete(key <span class="keyword">interface</span>&#123;&#125;) error     <span class="comment">// delete session value</span></span><br><span class="line">	SessionID() <span class="keyword">string</span>                <span class="comment">// back current sessionID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局唯一的-Session-id"><a href="#全局唯一的-Session-id" class="headerlink" title="全局唯一的 Session id"></a>全局唯一的 Session id</h3><p>Session id 用来标识每一个用户以及对应的 Session，所以必须是全局唯一的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局唯一的 session id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">sessionId</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> _, err := rand.Read(b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-的创建"><a href="#Session-的创建" class="headerlink" title="Session 的创建"></a>Session 的创建</h3><p><code>SessionStart</code> 用来检测是否已经有某个 Session 与当前来访用户发生了关联，如果没有则创建之</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SessionStart 用来检测是否已经有某个 Session 与当前来访用户发生了关联，如果没有则创建之</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionStart</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="params">(session Session)</span></span> &#123;</span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 没有 Session，创建</span></span><br><span class="line">		sid := manager.sessionId()</span><br><span class="line">		session, _ = manager.provider.SessionInit(sid)</span><br><span class="line">		cookie := &amp;http.Cookie&#123;</span><br><span class="line">			Name:     manager.cookieName,</span><br><span class="line">			Value:    url.QueryEscape(sid),</span><br><span class="line">			Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">			HttpOnly: <span class="literal">true</span>,</span><br><span class="line">			MaxAge:   <span class="keyword">int</span>(manager.maxLifeTime),</span><br><span class="line">		&#125;</span><br><span class="line">		http.SetCookie(w, cookie)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发生了关联</span></span><br><span class="line">		sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class="line">		session, _ = manager.provider.SessionRead(sid)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-销毁"><a href="#Session-销毁" class="headerlink" title="Session 销毁"></a>Session 销毁</h3><p>在销毁 Session 时，除了从存储结构中删除 Session 信息之外，还需要设置 Cookie过期。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionDestroy</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 上锁</span></span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	<span class="comment">// 从存储结构中删除</span></span><br><span class="line">	manager.provider.SessionDestroy(cookie.Value)</span><br><span class="line">	<span class="comment">// 设置 Cookie</span></span><br><span class="line">	expiration := time.Now()</span><br><span class="line">	cookie = &amp;http.Cookie&#123;</span><br><span class="line">		Name:     manager.cookieName,</span><br><span class="line">		Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">		HttpOnly: <span class="literal">true</span>,</span><br><span class="line">		Expires:  expiration,</span><br><span class="line">		MaxAge:   <span class="number">-1</span>, <span class="comment">// 立即删除session</span></span><br><span class="line">	&#125;</span><br><span class="line">	http.SetCookie(w, cookie)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过期-Session-清理"><a href="#过期-Session-清理" class="headerlink" title="过期 Session 清理"></a>过期 Session 清理</h3><p>GC 利用了 <strong>time 包的定时器功能</strong>，当超时之后调用 GC 清理过期数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC 删除过期数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">	manager.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">	manager.provider.SessionGC(manager.maxLifeTime)</span><br><span class="line">	time.AfterFunc(time.Duration(manager.maxLifeTime), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		manager.GC()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-实现-Session-存储"><a href="#Go-实现-Session-存储" class="headerlink" title="Go 实现 Session 存储"></a>Go 实现 Session 存储</h2><p>在上一节中，定义了 Session 管理器 <strong>session.Manager</strong>，以及两个接口 <strong>session.Provider</strong> 和 <strong>session.Session</strong>，这两个接口用于存储 Session 数据。本节将实现一个基于内存的 Session 存储方式。</p>
<h3 id="Provider-接口实现"><a href="#Provider-接口实现" class="headerlink" title="Provider 接口实现"></a>Provider 接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock     sync.Mutex               <span class="comment">// 用来锁</span></span><br><span class="line">	sessions <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element <span class="comment">// 用来存储在内存</span></span><br><span class="line">	list     *list.List               <span class="comment">// 用来做 gc，按照 SessionStore.timeAccessed 最近访问时间排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provider 实现 session.Session 接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionInit 实现 Session 的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionInit</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">	v := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	newSess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class="line">	element := p.list.PushFront(newSess)</span><br><span class="line">	p.sessions[sid] = element</span><br><span class="line">	<span class="keyword">return</span> newSess, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionRead 返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionRead</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		<span class="comment">// 已存在 Session</span></span><br><span class="line">		<span class="keyword">return</span> element.Value.(*SessionStore), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 未存在，新建Session</span></span><br><span class="line">	sess, err := p.SessionInit(sid)</span><br><span class="line">	<span class="keyword">return</span> sess, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionDestroy 销毁 sid 对应的 Session 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionDestroy</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		<span class="comment">// Session 已存在</span></span><br><span class="line">		<span class="comment">// 从字典中删除</span></span><br><span class="line">		<span class="built_in">delete</span>(p.sessions, sid)</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		p.list.Remove(element)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionGC 根据 maxLifeTime 来删除过期的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionGC</span><span class="params">(maxLifeTime <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		element := p.list.Back()</span><br><span class="line">		<span class="keyword">if</span> element.Value.(*SessionStore).timeAccessed.Unix()+maxLifeTime &lt; time.Now().Unix() &#123;</span><br><span class="line">			<span class="comment">// 超时，清理 Session</span></span><br><span class="line">			<span class="comment">// 从字典中删除</span></span><br><span class="line">			<span class="built_in">delete</span>(p.sessions, element.Value.(*SessionStore).sid)</span><br><span class="line">			<span class="comment">// 从链表中删除</span></span><br><span class="line">			p.list.Remove(element)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionUpdate 用于更新最近访问时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">SessionUpdate</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> element, ok := p.sessions[sid]; ok &#123;</span><br><span class="line">		element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class="line">		p.list.MoveToFront(element)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-接口实现"><a href="#Session-接口实现" class="headerlink" title="Session 接口实现"></a>Session 接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SessionStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	sid          <span class="keyword">string</span>                      <span class="comment">// session id</span></span><br><span class="line">	timeAccessed time.Time                   <span class="comment">// 最后访问的时间</span></span><br><span class="line">	value        <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// session 存储的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	p = &amp;Provider&#123;list: list.New()&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 设置值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	st.value[key] = value</span><br><span class="line">	<span class="keyword">return</span> p.SessionUpdate(st.sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	p.SessionUpdate(st.sid)</span><br><span class="line">	<span class="keyword">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 删除值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(st.value, key)</span><br><span class="line">	<span class="keyword">return</span> p.SessionUpdate(st.sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionID 获取 sid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">SessionID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> st.sid</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化以及注册-Provider"><a href="#初始化以及注册-Provider" class="headerlink" title="初始化以及注册 Provider"></a>初始化以及注册 Provider</h3><p>初始化以及在 <strong>session.Manager</strong> 中<strong>注册</strong>该基于内存的 Provider。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element, <span class="number">0</span>)</span><br><span class="line">	session.Register(<span class="string">&quot;memory&quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>当 import 的时候已经执行了 memory 函数里面的 init 函数，这样就已经注册到 session 管理器中，我们就可以使用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;go-web-demo/ch6/session&quot;</span></span><br><span class="line">	_ <span class="string">&quot;go-web-demo/ch6/session/providers/memory&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	globalSessions, _ = session.NewManager(<span class="string">&quot;memory&quot;</span>, <span class="string">&quot;gosessionid&quot;</span>, <span class="number">3600</span>)</span><br><span class="line">    <span class="comment">// 开一个线程启动 GC</span></span><br><span class="line">	<span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防范-Session-劫持"><a href="#防范-Session-劫持" class="headerlink" title="防范 Session 劫持"></a>防范 Session 劫持</h1><h2 id="httponly-和-token"><a href="#httponly-和-token" class="headerlink" title="httponly 和 token"></a>httponly 和 token</h2><p>第一种方案通过 <strong>httponly + token</strong> 来预防 Session 劫持：</p>
<ul>
<li>可以设置 Session id 的值只能由 Cookie 进行设置，同时设置 <strong>httponly</strong> 为 true，这个属性可以防止通过客户端脚本访问到 Cookie，进而防止攻击者读取到 Cookie 中的 Session id。</li>
<li>在每个请求里面加上 token，然后每一次验证 token，从而保证用户的请求都是唯一性。</li>
</ul>
<h2 id="间隔生成新的-Sesseion-id"><a href="#间隔生成新的-Sesseion-id" class="headerlink" title="间隔生成新的 Sesseion id"></a>间隔生成新的 Sesseion id</h2><p>第二种方案是给 Session 额外设置一个<strong>创建时间</strong>的值，一旦过了一定的时间，就销毁这个 Session id，重新生成 Session。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过期时间 60s</span></span><br><span class="line">expires := <span class="number">60</span></span><br><span class="line"></span><br><span class="line">createTime := sess.Get(<span class="string">&quot;createtime&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> createTime == <span class="literal">nil</span> &#123;</span><br><span class="line">    sess.Set(<span class="string">&quot;createtime&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> createTime.(<span class="keyword">int64</span>) + expires &lt; time.Now().Unix() &#123;</span><br><span class="line">    <span class="comment">// 当前 Session 过期，重新分配 Session</span></span><br><span class="line">    globalSessions.SessionDestroy(w, r)</span><br><span class="line">    sess = globalSessions.SessionStart(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为 Session 设置了一个值，用于记录生成 Session id 的时间。每次请求都判断是否过期，如果过期，则分配新的 Session id。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面两个手段的组合可以在实践中消除 session 劫持的风险：</p>
<ul>
<li><p><strong>Session id 的频繁改变</strong>，使得攻击者很难获取到有效的 Session id。</p>
</li>
<li><p>Session 只在 Cookie 中传递，并且设置了 <strong>httponly</strong> 选项，可以有效阻止通过客户端脚本访问到 Cookie，也可以预防 XSS 攻击获取 Cookie。</p>
</li>
<li><p>还可以设置 <strong>MaxAge=0</strong>，这样 Cookie 就不会存储在浏览器的记录中，随着浏览器关闭 Cookie 也随机消失。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/14/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E8%A1%A8%E5%8D%95%E5%92%8C%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/14/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E8%A1%A8%E5%8D%95%E5%92%8C%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (2) 表单和访问数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-14 14:31:48" itemprop="dateCreated datePublished" datetime="2022-05-14T14:31:48+08:00">2022-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="处理表单输入"><a href="#处理表单输入" class="headerlink" title="处理表单输入"></a>处理表单输入</h2><p>编写 <code>login.gtpl</code> 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>处理登录的逻辑，其中 <code>r.ParseForm()</code> 方法用于<strong>解析参数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &#123;</span><br><span class="line">		<span class="comment">// 如果是 GET 请求</span></span><br><span class="line">		t, _ := template.ParseFiles(<span class="string">&quot;./login.gtpl&quot;</span>)</span><br><span class="line">		log.Println(t.Execute(w, <span class="literal">nil</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是 POST 请求</span></span><br><span class="line">		err := r.ParseForm()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;ParseForm error:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;username:&quot;</span>, r.Form[<span class="string">&quot;username&quot;</span>])</span><br><span class="line">		fmt.Println(<span class="string">&quot;password:&quot;</span>, r.Form[<span class="string">&quot;password&quot;</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/login&quot;</span>, login)         <span class="comment">// 设置访问的路由</span></span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>r.Form</strong> 里面包含了所有请求的参数，比如 URL 中 <strong>query-string</strong>、<strong>POST 的数据</strong>、<strong>PUT 的数据</strong>，所以当你在 URL 中的 query-string 字段和 POST 冲突时，会保存成一个 <strong>slice</strong>，里面存储了多个值。</p>
<p><strong>r.From</strong> 是一个 <strong>url.Values</strong> 类型的值，可以对其进行一些操作（ <strong>Get、Set、Add、Del、Has</strong> ）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key.</span></span><br><span class="line"><span class="comment">// If there are no values associated with the key, Get returns</span></span><br><span class="line"><span class="comment">// the empty string. To access multiple values, use the map</span></span><br><span class="line"><span class="comment">// directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	vs := v[key]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(vs) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the key to value. It replaces any existing</span></span><br><span class="line"><span class="comment">// values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	v[key] = []<span class="keyword">string</span>&#123;value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the value to key. It appends to any existing</span></span><br><span class="line"><span class="comment">// values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	v[key] = <span class="built_in">append</span>(v[key], value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del deletes the values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(v, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has checks whether a given key is set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Has</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	_, ok := v[key]</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>在处理表单的逻辑事，不要忘了对<strong>表单的输入的验证</strong>，不能信任用户输入的任何信息。</p>
<hr>
<h2 id="预防跨站脚本"><a href="#预防跨站脚本" class="headerlink" title="预防跨站脚本"></a>预防跨站脚本</h2><p>对 XSS 的防护主要在于两方面：</p>
<ul>
<li>对<strong>输入</strong>的验证，检测攻击。</li>
<li>对所有<strong>输出</strong>数据进行适当的处理，以防止任何已成功注入的脚本在浏览器端运行。</li>
</ul>
<p>对于对输出数据的处理，Go 的 <strong>html/template</strong> 里面带有下面几个函数可以<strong>转义</strong>：</p>
<ul>
<li><code>func HTMLEscape (w io.Writer, b [] byte)</code>：把 b 进行转义之后写到 w 中。</li>
<li><code>func HTMLEscapeString (s string) string</code>：转义 s 之后返回结果字符串。</li>
<li><code>func HTMLEscaper (args ...interface &#123;&#125;) string</code>：支持多个参数一起转义，返回结果字符串</li>
</ul>
<p>如果需要输出 HTML 标签，可以使用 <strong>template.HTML</strong> 类型，它用于封装一个<strong>已知安全的 HTML 文档片段</strong>。它不应被第三方使用，也不能用于含有未闭合的标签或注释的 HTML 文本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;html/template&quot;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">t, err := template.New(<span class="string">&quot;foo&quot;</span>).Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">&quot;T&quot;</span>, template.HTML(<span class="string">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="防止多次提交表单"><a href="#防止多次提交表单" class="headerlink" title="防止多次提交表单"></a>防止多次提交表单</h2><p>解决方案是在表单中添加一个<strong>带有唯一值的隐藏字段</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在验证表单时，先<strong>检查带有该唯一值（ 如 MD5(时间戳) ）的表单</strong>是否已经递交过了：</p>
<ul>
<li>如果是，拒绝再次递交。</li>
<li>如果不是，则处理表单进行逻辑处理。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">&quot;GET&quot;</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        <span class="comment">// 通过 md5(时间戳) 构造token</span></span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">&quot;login.gtpl&quot;</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">        r.ParseForm()</span><br><span class="line">        token := r.Form.Get(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 验证 token 的合法性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不存在 token 报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;username length:&quot;</span>, <span class="built_in">len</span>(r.Form[<span class="string">&quot;username&quot;</span>][<span class="number">0</span>]))</span><br><span class="line">        fmt.Println(<span class="string">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到服务器端</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;password&quot;</span>)))</span><br><span class="line">        template.HTMLEscape(w, []<span class="keyword">byte</span>(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h2><h3 id="form-的-enctype-属性"><a href="#form-的-enctype-属性" class="headerlink" title="form 的 enctype 属性"></a>form 的 enctype 属性</h3><p>form 表单的 enctype 属性指明了发送到服务器时时浏览器使用的编码类型，有三种取值：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code> ：<strong>默认</strong>编码类型，在发送前编码所有的字符。</li>
<li><code>multipart/form-data</code> ：不对字符进行编码，指定传输的数据为<strong>二进制</strong>类型，所以可以用于文件上传。</li>
<li><code>text/plain</code> ：空格转换为 “+” 加号，但不对特殊字符编码。</li>
</ul>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>创建名为 <code>upload.gtpl</code> 的模板文件用于文件上传：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadfile&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写服务器文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &#123;</span><br><span class="line">		<span class="comment">// 若是 GET 请求</span></span><br><span class="line">		curTime := time.Now().Unix() <span class="comment">// 获取当前时间的时间戳</span></span><br><span class="line">		h := md5.New()</span><br><span class="line">		_, err := io.WriteString(h, strconv.FormatInt(curTime, <span class="number">10</span>)) <span class="comment">// 将时间戳进行 md5 加密</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 渲染页面</span></span><br><span class="line">		t, _ := template.ParseFiles(<span class="string">&quot;upload.gtpl&quot;</span>)</span><br><span class="line">		t.Execute(w, token)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// POST 请求</span></span><br><span class="line">		r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">		file, handler, err := r.FormFile(<span class="string">&quot;uploadfile&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;%v&quot;</span>, handler.Header)</span><br><span class="line">		f, err := os.OpenFile(<span class="string">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>) <span class="comment">// 此处假设当前目录下已存在test目录</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">		io.Copy(f, file)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/upload&quot;</span>, upload)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理文件上传需要调用 <code>r.ParseMultipartForm( maxMemory )</code> 函数，其中 <code>maxMemroy</code> 表示文件存储在内存中的大小，如果文件大小超过了该值，则剩余的部分将存储在系统的临时文件中。使用 <code>r.FormFile</code> 函数可以获取文件句柄以及文件属性。</p>
<p>其中，文件 handler 的类型为 *<strong>multipart.FileHeader</strong>，结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileHeader describes a file part of a multipart request.</span></span><br><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Filename <span class="keyword">string</span></span><br><span class="line">	Header   textproto.MIMEHeader</span><br><span class="line">	Size     <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 非导出字段</span></span><br><span class="line">	content []<span class="keyword">byte</span></span><br><span class="line">	tmpfile <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><h2 id="database-sql-接口"><a href="#database-sql-接口" class="headerlink" title="database/sql 接口"></a>database/sql 接口</h2><p>Go 定义了了一些标准的接口，开发者可以根据定义的接口来开发相应的数据库驱动。</p>
<h3 id="sql-Register"><a href="#sql-Register" class="headerlink" title="sql.Register"></a>sql.Register</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span></span><br></pre></td></tr></table></figure>

<p>Register <strong>注册并命名</strong>一个数据库，可以在 Open 函数中使用该命名启用该驱动。</p>
<p>mymysql、sqlite3的驱动通过 <code>init()</code> 函数注册自己的数据库驱动名称以及相应的 driver 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/mattn/go-sqlite3 驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sql.Register(<span class="string">&quot;sqlite3&quot;</span>, &amp;SQLiteDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/mikespook/mymysql 驱动</span></span><br><span class="line"><span class="comment">// Driver automatically registered in database/sql</span></span><br><span class="line"><span class="keyword">var</span> d = Driver&#123;proto: <span class="string">&quot;tcp&quot;</span>, raddr: <span class="string">&quot;127.0.0.1:3306&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Register(<span class="string">&quot;SET NAMES utf8&quot;</span>)</span><br><span class="line">    sql.Register(<span class="string">&quot;mymysql&quot;</span>, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 database/sql 内部，通过一个 <strong>map</strong> 来存储用户定义的驱动，所以可以通过注册函数 Register 同时注册多个数据库驱动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drivers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</span><br></pre></td></tr></table></figure>

<h3 id="sql-DB"><a href="#sql-DB" class="headerlink" title="sql.DB"></a>sql.DB</h3><p>DB 中 freeConn 是一个简易的<strong>连接池</strong>，它的实现相当的简单：</p>
<ul>
<li>当执行 <code>db.prepare</code> -&gt; <code>db.prepareDC</code> 的时候会 <code>defer dc.releaseConn</code>。</li>
<li>调用<code>db.putConn</code>，也就是把这个连接放入连接池。</li>
<li>每次调用 <code>db.conn</code> 的时候会先判断 freeConn 的长度是否大于 0，大于 0 说明有可以复用的 conn，直接拿出来用就是了，如果不大于 0，则创建一个 conn，然后再返回之。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    driver   driver.Driver</span><br><span class="line">    dsn      <span class="keyword">string</span></span><br><span class="line">    mu       sync.Mutex <span class="comment">// protects freeConn and closed</span></span><br><span class="line">    freeConn []driver.Conn</span><br><span class="line">    closed   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-Driver"><a href="#driver-Driver" class="headerlink" title="driver.Driver"></a>driver.Driver</h3><p>Driver 是一个数据库驱动接口，它定义了一个方法 <strong>Open</strong>，这个方法返回一个数据库 <strong>Conn</strong> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Open返回一个新的与数据库的连接，参数name的格式是驱动特定的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open可能返回一个缓存的连接（之前关闭的连接），但这么做是不必要的；</span></span><br><span class="line">    <span class="comment">// sql包会维护闲置连接池以便有效的重用连接。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回的连接同一时间只会被一个go程使用。</span></span><br><span class="line">    Open(name <span class="keyword">string</span>) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，返回的 Conn 连接同一时间只能被一个 goroutine 使用。</p>
<h3 id="driver-Conn"><a href="#driver-Conn" class="headerlink" title="driver.Conn"></a>driver.Conn</h3><p>Conn 是一个数据库连接的接口定义，他定义了一系列方法，这个 Conn 只能应用在一个 goroutine 里面，不能使用在多个 goroutine 里面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Prepare返回一个准备好的、绑定到该连接的状态。</span></span><br><span class="line">    Prepare(query <span class="keyword">string</span>) (Stmt, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close作废并停止任何现在准备好的状态和事务，将该连接标注为不再使用。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 因为sql包维护着一个连接池，只有当闲置连接过剩时才会调用Close方法，</span></span><br><span class="line">    <span class="comment">// 驱动的实现中不需要添加自己的连接缓存池。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin开始并返回一个新的事务。</span></span><br><span class="line">    Begin() (Tx, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Prepare</strong> 函数返回与当前连接相关的执行 SQL 语句的<strong>准备状态</strong>，可以进行查询、删除等操作。</li>
<li><strong>Close</strong> 函数<strong>关闭</strong>当前的连接，执行释放连接拥有的资源等清理工作。因为驱动实现了 database/sql 里面建议的 conn pool，所以你不用再去实现缓存 conn 之类的，这样会容易引起问题。</li>
<li><strong>Begin</strong> 函数返回一个代表<strong>事务</strong>处理的 Tx，通过它你可以进行查询，更新等操作，或者对事务进行回滚、递交。</li>
</ul>
<h3 id="driver-Stmt"><a href="#driver-Stmt" class="headerlink" title="driver.Stmt"></a>driver.Stmt</h3><p>Stmt 是一种准备好的状态，和 Conn 相关联（ Stmt会绑定到一个连接 ），而且只能应用于一个 goroutine 中，不能应用于多个 goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Close关闭Stmt。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 和Go1.1一样，如果Stmt被任何查询使用中的话，将不会被关闭。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NumInput返回占位参数的个数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果NumInput返回值 &gt;= 0，sql包会提前检查调用者提供的参数个数，</span></span><br><span class="line">    <span class="comment">// 并且会在调用Exec或Query方法前返回数目不对的错误。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NumInput可以返回-1，如果驱动占位参数的数量。</span></span><br><span class="line">    <span class="comment">// 此时sql包不会提前检查参数个数。</span></span><br><span class="line">    NumInput() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec执行查询，而不会返回结果，如insert或update。</span></span><br><span class="line">    Exec(args []Value) (Result, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query执行查询并返回结果，如select。</span></span><br><span class="line">    Query(args []Value) (Rows, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Close</strong> 函数<strong>关闭</strong>当前的链接状态，但是如果当前正在执行 query，query 还是有效返回 rows 数据。</li>
<li><strong>NumInput</strong> 函数返回<strong>当前预留参数的个数</strong>，当返回 &gt;=0 时数据库驱动就会智能检查调用者的参数。当数据库驱动包不知道预留参数的时候，返回 -1。</li>
<li><strong>Exec</strong> 函数执行 Prepare 准备好的 SQL，传入参数执行 <strong>update/insert</strong> 等操作，返回 Result 数据。</li>
<li><strong>Query</strong> 函数执行 Prepare 准备好的 SQL，传入需要的参数执行 <strong>select</strong> 操作，返回 Rows 结果集。</li>
</ul>
<h3 id="driver-Tx"><a href="#driver-Tx" class="headerlink" title="driver.Tx"></a>driver.Tx</h3><p>事务处理一般就两个过程，递交或者回滚。数据库驱动里面也只需要实现这两个函数就可以。Tx 代表一次<strong>事务</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tx <span class="keyword">interface</span> &#123;</span><br><span class="line">    Commit() error</span><br><span class="line">    Rollback() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-Execer"><a href="#driver-Execer" class="headerlink" title="driver.Execer"></a>driver.Execer</h3><p>这是一个 Conn 可选择实现的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec(query <span class="keyword">string</span>, args []Value) (Result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个接口没有定义，那么在调用 <strong>DB.Exec</strong>，就会首先调用 <strong>Prepare</strong> 返回 <strong>Stmt</strong>，然后执行 <strong>Stmt</strong> 的 <strong>Exec</strong>，然后关闭 <strong>Stmt</strong>。</p>
<h3 id="driver-Result"><a href="#driver-Result" class="headerlink" title="driver.Result"></a>driver.Result</h3><p>这个是执行 <strong>Update/Insert</strong> 等操作返回的结果接口定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// LastInsertId返回insert等命令后数据库自动生成的ID</span></span><br><span class="line">    LastInsertId() (<span class="keyword">int64</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RowsAffected返回被查询影响的行数</span></span><br><span class="line">    RowsAffected() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>LastInsertId</strong> 函数返回由数据库执行插入操作得到的<strong>自增 ID 号</strong>。</p>
</li>
<li><p><strong>RowsAffected</strong> 函数返回 query 操作影响的数据条目数。</p>
</li>
</ul>
<h3 id="driver-Rows"><a href="#driver-Rows" class="headerlink" title="driver.Rows"></a>driver.Rows</h3><p>Rows 是执行查询得到的结果的迭代器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rows <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Columns返回各列的名称，列的数量可以从切片长度确定。</span></span><br><span class="line">    <span class="comment">// 如果某个列的名称未知，对应的条目应为空字符串。</span></span><br><span class="line">    Columns() []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close关闭Rows。</span></span><br><span class="line">    Close() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Next方法以将下一行数据填充进提供的切片中。</span></span><br><span class="line">    <span class="comment">// 提供的切片必须和Columns返回的切片长度相同。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 切片dest可能被填充同一种驱动Value类型，但字符串除外。</span></span><br><span class="line">    <span class="comment">// 所有string值都必须转换为[]byte。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 当没有更多行时，Next应返回io.EOF。</span></span><br><span class="line">    Next(dest []Value) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Columns</strong> 函数返回查询数据库表的字段信息，这个返回的 slice 和 sql 查询的字段一一对应，而不是返回整个表的所有字段。</li>
<li><strong>Close</strong> 函数用来关闭 Rows 迭代器。</li>
<li><strong>Next</strong> 函数用来返回下一条数据，把数据赋值给 <strong>dest</strong>。dest 里面的元素必须是 driver.Value 的值除了 string，返回的数据里面所有的 string 都必须要转换成 [] byte。如果最后没数据了，Next 函数最后返回 io.EOF。</li>
</ul>
<h3 id="driver-RowsAffected"><a href="#driver-RowsAffected" class="headerlink" title="driver.RowsAffected"></a>driver.RowsAffected</h3><p>RowsAffected 其实就是一个 int64 的别名，但是他<strong>实现了 Result 接口</strong>，用于 <strong>insert</strong> 或 <strong>update</strong> 操作，这些操作会修改零到多行数据。：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RowsAffected <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(RowsAffected)</span> <span class="title">LastInsertId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v RowsAffected)</span> <span class="title">RowsAffected</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="driver-Value"><a href="#driver-Value" class="headerlink" title="driver.Value"></a>driver.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Value 是驱动必须能处理的值。它要么是nil，要么是如下类型的实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span></span><br><span class="line"><span class="keyword">float64</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">[]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">string</span>   [*] Rows.Next不会返回该类型值</span><br><span class="line">time.Time</span><br></pre></td></tr></table></figure>

<h3 id="driver-ValueConverter"><a href="#driver-ValueConverter" class="headerlink" title="driver.ValueConverter"></a>driver.ValueConverter</h3><p>ValueConverter 接口定义了如何把一个普通的值转化成 driver.Value 的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValueConverter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ConvertValue(v <span class="keyword">interface</span>&#123;&#125;) (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发的数据库驱动包里面实现这个接口的函数在很多地方会使用到，这个 ValueConverter 有很多好处：</p>
<ul>
<li>转化 driver.value 到数据库表相应的字段，例如 int64 的数据如何转化成数据库表 uint16 字段。</li>
<li>把数据库查询结果转化成 driver.Value 值。</li>
<li>在 scan 函数里面如何把 driver.Value 值转化成用户定义的值。</li>
</ul>
<h3 id="driver-Valuer"><a href="#driver-Valuer" class="headerlink" title="driver.Valuer"></a>driver.Valuer</h3><p>Valuer 接口定义了返回一个 driver.Value 的方式，很多类型都实现了这个 Value 方法，用来自身与 driver.Value 的转化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Value() (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p><strong>github.com/go-sql-driver/mysql</strong> 为支持 MySQL 的驱动，它支持 database/sql 标准。</p>
<h3 id="打开驱动"><a href="#打开驱动" class="headerlink" title="打开驱动"></a>打开驱动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开驱动</span></span><br><span class="line">dsn := <span class="string">&quot;user:password@tcp(ip:port)/dbname?charset=utf8&quot;</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">stmt, err := db.Prepare(<span class="string">&quot;INSERT userinfo SET username=?,department=?,created=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="string">&quot;dawn&quot;</span>, <span class="string">&quot;研发部门&quot;</span>, <span class="string">&quot;2022-05-15&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(id)</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">stmt, err = db.Prepare(<span class="string">&quot;update userinfo set username=? where uid=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err = stmt.Exec(<span class="string">&quot;zh&quot;</span>, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">affect, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(affect)</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * FROM userinfo&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> department <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> created <span class="keyword">string</span></span><br><span class="line">	err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">stmt, err = db.Prepare(<span class="string">&quot;delete from userinfo where uid=?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err = stmt.Exec(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">affect, err = res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(affect)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/13/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-Web%E5%9F%BA%E7%A1%80%E5%92%8Chttp%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-Web%E5%9F%BA%E7%A1%80%E5%92%8Chttp%E5%8C%85/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (1) Web基础和http包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-13 17:52:51" itemprop="dateCreated datePublished" datetime="2022-05-13T17:52:51+08:00">2022-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h1><h2 id="Go-搭建一个-Web-服务器"><a href="#Go-搭建一个-Web-服务器" class="headerlink" title="Go 搭建一个 Web 服务器"></a>Go 搭建一个 Web 服务器</h2><p>Go 搭建一个 Web 服务器</p>
<p>使用 <code>http</code> 包可以轻松的搭建一个 Web 服务器：</p>
<ul>
<li><code>http.HandleFunc</code> 函数：用于绑定路由。</li>
<li><code>http.ListenAndServe</code> 函数：设置监听的端口。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()       <span class="comment">// 解析参数</span></span><br><span class="line">	fmt.Println(r.Form) <span class="comment">// 这些信息是输出到服务器端的打印信息</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;path:&quot;</span>, r.URL.Path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;scheme:&quot;</span>, r.URL.Scheme)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">		fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello astaxie!&quot;</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayHelloName)       <span class="comment">// 设置路由</span></span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-中-Web-的工作方式"><a href="#Go-中-Web-的工作方式" class="headerlink" title="Go 中 Web 的工作方式"></a>Go 中 Web 的工作方式</h2><p>以下是服务器端的几个基本概念：</p>
<ul>
<li><code>Request</code> ：用户的请求信息。</li>
<li><code>Response</code> ：服务器需要反馈给客户端的信息。</li>
<li><code>Conn</code> ：用户每次请求的链接。</li>
<li><code>Handler</code> ：处理请求和生成返回信息的处理逻辑。</li>
</ul>
<h3 id="http-包运行机制"><a href="#http-包运行机制" class="headerlink" title="http 包运行机制"></a>http 包运行机制</h3><p>Go 实现 Web 服务的工作模式如下：</p>
<ol>
<li>创建 <strong>Listen Socket</strong>，监听指定的端口，等待客户端请求到来。</li>
<li>Listen Socket 接收客户端的请求，得到 <strong>Client Socket</strong>，通过Client Socket 与客户端进行通信。</li>
<li>处理客户端的请求，交给 <strong>Handler</strong>进行处理，Handler 处理好数据之后通过 Client Socket 返回给客户端。</li>
</ol>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-Web%E5%9F%BA%E7%A1%80%E5%92%8Chttp%E5%8C%85/3.3.http.png" alt="img"></p>
<p>这整个的过程里面我们只要了解清楚下面三个问题，也就知道 Go 是如何让 Web 运行起来了：</p>
<ul>
<li><strong>如何监听端口？</strong></li>
</ul>
<p>通过 <code>http.ListenAndServe</code> 函数，可以监听端口并分配handler，底层实现如下：初始化一个 <strong>server</strong> 对象，然后调用了 <code>net.Listen(&quot;tcp&quot;, addr)</code>，也就是底层用 TCP 协议搭建了一个服务，然后监控我们设置的端口。</p>
<ul>
<li><strong>如何接收客户端请求？</strong></li>
</ul>
<p>以下来自 http 包的源码，可以看到整个 http 的处理过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                log.Printf(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c, err := srv.newConn(rw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> c.serve()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在监听完端口过后，调用了 <code>srv.Serve(net.Listener)</code> 方法，这个方法就是处理客户端的请求信息。在 Accept 之后，创建一个 Conn，然后开启一个<strong>协程</strong>来单独处理来自客户端的 http 请求：<code>go c.serve()</code>。</p>
<ul>
<li><strong>如何分配 handler？</strong></li>
</ul>
<p>Conn 首先会解析 request：<code>c.readRequest()</code>，然后获取相应的 handler：<code>handler := c.server.Hander</code>，<code>c.server.Handler</code> 即为 <code>http.ListenAndServe</code> 的第二个参数；若为<strong>空</strong>，则默认获取 <code>handler = DefaultServeMux</code>。</p>
<p><strong>DefaultServeMux</strong> 实际上是一个路由器，它用来匹配 url 跳转到其相应的 handle 函数，通过 <code>http.HandleFunc</code> 函数设置。DefaultServeMux 会调用 <strong>ServeHTTP</strong>方法，这个方法内部调用了 <code>http.HandleFunc</code> 函数定义的 handler。</p>
<p>和http包<img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-Web%E5%9F%BA%E7%A1%80%E5%92%8Chttp%E5%8C%85/3.3.illustrator.png" alt="img"></p>
<h1 id="http-包"><a href="#http-包" class="headerlink" title="http 包"></a>http 包</h1><p>Go 的 http 有两个核心功能：Conn、ServeMux</p>
<h2 id="Conn-的-goroutine"><a href="#Conn-的-goroutine" class="headerlink" title="Conn 的 goroutine"></a>Conn 的 goroutine</h2><p>在 http 包中，当与客户端建立 TCP 连接之后，会建立一个协程来单独处理这一次用户的请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></table></figure>

<h2 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h2><p>当 <code>c.server.Handler</code> 为<strong>空</strong>时，则默认获取 <code>handler = DefaultServeMux</code>。这个 <strong>DefaullServeMux</strong> 是一个<strong>路由器</strong>，结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex   <span class="comment">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有 host 信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>muxEntry</strong> 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    explicit <span class="keyword">bool</span>   <span class="comment">// 是否精确匹配</span></span><br><span class="line">    h        Handler <span class="comment">// 这个路由表达式对应哪个 handler</span></span><br><span class="line">    pattern  <span class="keyword">string</span>  <span class="comment">// 匹配字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler 是一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  <span class="comment">// 路由实现器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是用户自定义的 Handler 并没有实现 ServeHTTP 方法，所以在 http 包里面还定义了一个类型 <code>HandlerFunc</code>，这个<strong>类型实现了 ServeHTTP 方法</strong>，也就是 Handler 接口。调用了 <code>http.HandlerFunc</code> 函数之后，我们自定义的 Handler 会被强制类型转换为 HandleFunc 类型，这样就有了 ServeHTTP方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由器里面存储好了相应的路由规则之后，那么具体的请求又是怎么分发的呢？请看下面的代码，默认的路由器实现了 <code>ServeHTTP</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在路由器收到请求之后，如果是 <code>*</code>，则关闭连接。否则调用 <code>mux.Handler(r)</code> 返回应设置路由的处理 Handler， 然后执行 <code>h.ServeHTTP(w, r)</code>。</p>
<p><code>mux.Handler(r)</code> 函数实现如下，它根据用户请求的 <strong>URL</strong> 和路由器里面存储的 <strong>map</strong> 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的 ServeHTTP 接口就可以执行到相应的函数了。：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">&quot;CONNECT&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class="line">            _, pattern = mux.handler(r.Host, p)</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(p, StatusMovedPermanently), pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义路由器"><a href="#自定义路由器" class="headerlink" title="自定义路由器"></a>自定义路由器</h3><p><code>ListenAndServe</code> 函数的第二个参数可以用来配置外部路由器，它是一个 Handler 接口，即即外部路由器只要实现了 Handler 接口就可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myMux <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p myMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">		sayHello(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.NotFound(w, r)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello, I am Dawn.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := myMux&#123;&#125;</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, mux)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言中 Web 的工作流程如下：</p>
<ul>
<li><p>首先调用 <strong>http.HandleFunc</strong> 函数：</p>
<ol>
<li>调用 DefaultServeMux 的<strong>HandleFunc</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用了 DefaultServeMux 的 <strong>Handle</strong></li>
<li>往 DefaultServeMux  的 <strong>map[string]muxEntry</strong> 中<strong>增加对应条目</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;http: invalid pattern&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;http: multiple registrations for &quot;</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">	mux.m[pattern] = e</span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">		mux.es = appendSorted(mux.es, e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其次调用 <strong>http.ListenAndServe</strong> 函数：</p>
<ol>
<li>实例化 <strong>Server</strong></li>
<li>调用 Server 的 <strong>ListenAndServe</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 <strong>net.Listen(“tcp”, addr)</strong> 监听端口</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address srv.Addr and then</span></span><br><span class="line"><span class="comment">// calls Serve to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If srv.Addr is blank, &quot;:http&quot; is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error. After Shutdown or Close,</span></span><br><span class="line"><span class="comment">// the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">	&#125;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动一个 for 循环，在循环体中 <strong>Accept</strong> 请求。对于每一个请求实例化一个 <strong>Conn</strong>，请开启一个 <strong>goroutine</strong> 运行服务 <strong>go c.serve()</strong></li>
<li>读取每一个请求的内容 <strong>w, err := c.readRequest()</strong></li>
<li>判断 handler 是否为空，如果为空则将 handler 设置为 <strong>DefaultServeMux</strong></li>
<li>调用 handler 的 <strong>ServeHTTP</strong>，即 DefaultServeMux.ServeHTTP</li>
<li>根据请求选择 handler，并进入这个handler 的 <strong>ServeHTTP</strong>：<code>mux.handler(r).ServeHTTP(w, r)</code></li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/13/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BCompose-Machine-Swarm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BCompose-Machine-Swarm/" class="post-title-link" itemprop="url">Docker学习笔记 (5) 三剑客之Compose Machine Swarm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-13 09:39:24" itemprop="dateCreated datePublished" datetime="2022-05-13T09:39:24+08:00">2022-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">docker学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h1><p><code>Compose</code> 项目负责实现对 Docker 容器集群的快速编排，用于快速部署分布式应用。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Compose</code> 允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（<strong>YAML</strong> 格式）来定义<strong>一组</strong>相关联的应用容器为一个项目（project）。 <code>Compose</code> 中有两个重要概念：</p>
<ul>
<li><strong>服务</strong> (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li><strong>项目</strong> (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p>一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h1 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h1><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p>
<h1 id="Swarm-mode"><a href="#Swarm-mode" class="headerlink" title="Swarm mode"></a>Swarm mode</h1><p><code>Swarm</code> 提供 Docker 容器集群服务，使用它，用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>集群中的节点分为管理（<code>manager</code>）节点和工作（<code>worker</code>）节点：</p>
<ul>
<li><strong>管理节点</strong>：用于集群的管理，一个 <code>swarm</code> 集群中可以有多个管理节点，但是只能有一个 <strong>leader</strong> 节点，leader 节点由 <strong>raft</strong> 算法选举出。<code>docker swarm</code> 命令基本只能在管理节点执行（除了 <code>docker swarm leave</code> 命令可以在工作节点执行）。</li>
<li><strong>工作节点</strong>：用于执行任务，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点也默认为工作节点。</li>
</ul>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BCompose-Machine-Swarm/swarm-diagram.png" alt="img"></p>
<h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><ul>
<li>任务（<code>Task</code>）是 <code>swarm</code>中最小的调度单位，目前来说就是一个单一的容器。</li>
<li>服务（<code>Services</code>）是指一组任务的集合，服务定义了任务的属性。服务有两种模式，通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定：<ul>
<li><code>replicated services</code>：按照一定规则在各个工作节点上运行指定个数的任务。</li>
<li><code>global services</code>：每个工作节点上运行一个任务。</li>
</ul>
</li>
</ul>
<p>下图是容器、服务、任务的关系：</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BCompose-Machine-Swarm/services-diagram.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Docker学习笔记 (4) 数据管理和网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 21:39:39" itemprop="dateCreated datePublished" datetime="2022-05-12T21:39:39+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">docker学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录（Bind mounts）</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间<strong>共享和重用</strong></li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<h3 id="数据卷的操作"><a href="#数据卷的操作" class="headerlink" title="数据卷的操作"></a>数据卷的操作</h3><ul>
<li><code> docker volume create</code> 命令：创建数据卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker volume ls</code> 命令：查看所有的数据卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     my-vol</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker volume inspect</code> 命令：查看指定数据卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-05-12T13:46:43Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
</li>
<li><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--mount <span class="built_in">source</span>=数据卷名,target=容器目录</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">-v 数据卷名:容器目录</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker volume rm</code> 命令：删除数据卷。<code>docker volume prune</code> 命令：删除所有无主的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</li>
</ul>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><ul>
<li>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=主机目录,target=挂载点</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">-v 宿主机绝对路径目录:容器内挂载点</span><br></pre></td></tr></table></figure>

<hr>
<p>也可以挂载一个主机<strong>文件</strong>到容器中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history</span><br></pre></td></tr></table></figure>

<p>这样就可以记录在容器输入过的命令了。</p>
<blockquote>
<p>docker 目录主机目录/数据卷<strong>出现 cannot open directory. Permission denied 错误</strong>，解决方法：</p>
<p><strong>加上 –privileged=true 参数</strong>。在SELinux里面挂载目录被禁止了，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题。即<strong>使用该参数，container内的root拥有真正的root权限</strong>；否则，container内的root只是外部的一个普通用户权限。</p>
</blockquote>
<blockquote>
<p><strong>读写权限设置：</strong></p>
<ul>
<li><p><strong>读写（read write，rw）：</strong>容器可以对主机目录/数据卷进行读写操作，默认。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /宿主机绝对路径目录或者数据卷名:/容器内目录:rw</span><br></pre></td></tr></table></figure></li>
<li><p><strong>只读（read only，ro）：</strong>容器实例内部被限制，只能读取不能写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /宿主机绝对路径目录或者数据卷名:/容器内目录:ro</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>当 Docker 启动时，会<strong>自动</strong>在主机上创建一个 <code>docker0</code> 虚拟网桥。同时，Docker 随机分配一个本地未占用的<strong>私有网段</strong>中的一个地址给 <code>docker0</code> 接口。此后启动的容器内的网口也会自动分配一个同一网段的地址。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络：</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/network.png" alt="Docker 网络"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Docker 网络的作用如下：</p>
<ul>
<li><p>容器间的<strong>互联通信</strong>、<strong>端口映射</strong>。</p>
</li>
<li><p>把多个容器放在同一个 Docker 网桥下，<strong>可以通过服务名（容器名）直接网络通信</strong>，而不使用 IP 地址。</p>
</li>
</ul>
<h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射：</p>
<ul>
<li>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</li>
<li><code>-p</code> 则可以指定要映射的端口。</li>
</ul>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><ul>
<li><code>docker network create -d bridge my-net</code> 命令：创建网络。</li>
<li>在 <code>docker run</code> 运行容器时，可以使用 <code>--network</code> 加入到一个网络中。</li>
</ul>
<p>多个容器可以加入到同一个网络中，实现容器之间的互联。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>docker 网络的常用命令如下：</p>
<ul>
<li><p><strong>新建网络（网桥）：</strong>docker network 网络名字</p>
</li>
<li><p><strong>查看网络：</strong>docker network ls</p>
</li>
<li><p><strong>查看网络信息：</strong>docker network inspect 网络名字</p>
</li>
<li><p><strong>删除网络：</strong>docker network rm 网络名字</p>
</li>
</ul>
<h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p>网络模式有四种，分别是：</p>
<ul>
<li>bridge 模式</li>
<li>host 模式</li>
<li>none 模式</li>
<li>container 模式</li>
</ul>
<h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p><strong>使用 –network  bridge 指定，默认使用 docker0</strong>。docker run 的时候，没有指定 network 的话默认使用的网桥模式就是 bridge，使用的就是 docker0。</p>
<p>Docker 在宿主机虚拟一个 Docker 容器网桥（默认 docker0），Docker 启动一个容器时会根据 Docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网关。<strong>因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信</strong>。</p>
<p>网桥创建一对对等虚拟设备接口<strong>一个叫 veth（网桥端），另一个叫 eth0（容器端）</strong>，成对匹配。</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/image-20221228163656973.png" alt="image-20221228163656973"></p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><strong>使用–network host 指定</strong>，该模式<strong>直接使用宿主机的 IP 地址与外界进行通信</strong>，不再需要额外进行NAT 转换。</p>
<p>容器将不会获得一个独立的 Network Namespace， 而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/image-20221228164308411.png" alt="image-20221228164308411"></p>
<blockquote>
<p>注意：</p>
<p>在使用 host 模式时，无法使用 -p 进行端口映射（会发生 warning），端口映射不起作用。</p>
</blockquote>
<h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p><strong>使用–network none 指定</strong>，在 none 模式下，并<strong>不为 Docker 容器进行任何网络配置</strong>。 </p>
<p>也就是禁用网络功能，只有lo标识（127.0.0.1，表示本地回环地址）。</p>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p><strong>使用 –network container:NAME或者容器ID 指定</strong>。</p>
<p>新建的容器<strong>和已经存在的一个容器共享一个网络 ip 配置而不是和宿主机共享。</strong>新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C/image-20221228164705206.png" alt="image-20221228164705206"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/11/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Docker学习笔记 (3) 容器和仓库操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-11 21:02:19" itemprop="dateCreated datePublished" datetime="2022-05-11T21:02:19+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">docker学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><h2 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h2><p>使用 <code>docker ps [OPTIONS]</code> 命令列出容器：</p>
<blockquote>
<p><strong>OPTIONS说明（常用）：</strong><br>-a：列出当前所有正在运行的容器+历史上运行过的容器。<br>-l：显示最近创建的容器。<br>-n：显示最近n个创建的容器。<br>-q：静默模式，只显示容器编号。</p>
</blockquote>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动容器有两种方式：</p>
<ul>
<li><p>一种是基于<strong>镜像</strong>新建一个容器并启动 <code>docker run</code>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>OPTIONS 说明：</strong></p>
<ul>
<li><p><strong>–name=”容器新名字”：</strong> 为容器指定一个名称；</p>
</li>
<li><p><strong>-d：</strong>后台运行容器并返回容器ID，也即启动守护式容器；</p>
</li>
<li><p><strong>-i：</strong>以交互模式运行容器，通常与 -t 同时使用；</p>
</li>
<li><p><strong>-t：</strong>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
</li>
<li><p><strong>-P：</strong>随机端口映射；</p>
</li>
<li><p><strong>-p：</strong>指定端口映射；</p>
</li>
</ul>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C/image-20221223100302221.png" alt="image-20221223100302221"></p>
<p><strong>启动交互式容器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>使用镜像ubuntu:latest以交互模式启动一个容器，在容器内执行 /bin/bash 命令。</p>
</blockquote>
</li>
<li><p>另外一个是将在<strong>终止</strong>状态（<code>stopped</code>）的容器重新启动 <code>docker start</code>。</p>
</li>
<li><p>重启容器：<code>docker restart 容器名/容器ID</code></p>
</li>
</ul>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>可以通过 <code>-d</code> 参数实现容器的<strong>后台</strong>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">905b8470023fe399cdc97f579cfef7def7450cf62874685ca64e7c7d223b4e78</span><br></pre></td></tr></table></figure>

<p>此时容器会在后台运行并不会把输出的结果打印到宿主机的STDOUT上面（输出结果可以用 <code>docker logs</code> 查看）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker container logs 905b</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息（<code>docker ps</code> 命令也可以查看容器信息）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\63544&gt;docker container ls</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">905b8470023f   ubuntu:18.04   <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   About a minute ago   Up About a minute             stupefied_pike</span><br></pre></td></tr></table></figure>

<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器会在后台运行。那么可以使用 <code>attach</code> 或者 <code>exec</code> 命令进入容器：</p>
<ul>
<li><p><code>docker attach </code>命令：如果从这个 stdin 中 exit，会导致容器的停止。</p>
</li>
<li><p><code>docker exec</code> 命令：如果从这个 stdin 中 exit，不会导致容器的停止。<strong>推荐使用 exec 命令</strong>。</p>
<ul>
<li><code>-i</code> 参数：只是打开容器的 STDIN，此时没有 Linux 命令提示符。</li>
<li><code>-it</code> 参数：可以看到 Linux 命令提示符。</li>
</ul>
</li>
</ul>
<h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><ul>
<li><code>docker export</code> 命令：可以导出容器。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker import</code> 命令：从容器快照文件中再导入为镜像。</li>
</ul>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><ul>
<li>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。<ul>
<li>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。</li>
</ul>
</li>
<li><code>docker container prune</code> 清除所有处于终止状态的容器。</li>
</ul>
<h2 id="重要操作"><a href="#重要操作" class="headerlink" title="重要操作"></a>重要操作</h2><h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p>在大部分的场景下，我们希望 docker 的服务是在<strong>后台运行</strong>的，我们可以过 -d 指定容器的后台运行模式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure>

<h3 id="启动前台交互式容器"><a href="#启动前台交互式容器" class="headerlink" title="启动前台交互式容器"></a>启动前台交互式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it 容器名 bashShell</span><br><span class="line">UID		PID		PPID	C	STIME	TTY		TIME		CMD</span><br><span class="line">root	5007	4987	0	02:54	?		00:00:00	bash</span><br></pre></td></tr></table></figure>

<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器ID</span><br></pre></td></tr></table></figure>

<h3 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>

<h3 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<h3 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h3><p>可以用两个命令：</p>
<ul>
<li><code>docker exec -it 容器ID bashShell</code></li>
<li><code>docker attach 容器ID</code></li>
</ul>
<blockquote>
<p><strong>两种命令的区别：</strong></p>
<ul>
<li>attach 直接<strong>进入容器启动命令的终端</strong>，不会启动新的进程。用 exit 退出，会导致容器的停止。</li>
<li>exec 是<strong>在容器中打开新的终端</strong>，并且可以启动新的进程。<strong>用 exit 退出，不会导致容器的停止</strong>。</li>
</ul>
<p>推荐使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。</p>
</blockquote>
<h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<h3 id="导入和导出容器-1"><a href="#导入和导出容器-1" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><ul>
<li><p><strong>export：</strong>导出容器的内容留作为一个tar归档文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 容器ID &gt; 文件名.tar</span><br></pre></td></tr></table></figure></li>
<li><p><strong>import：</strong>从tar包中的内容创建一个新的文件系统再导入为镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名.tar | docker import - 镜像名:镜像版本号</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>Docker 官方维护了一个公共仓库 Docker Hub：</p>
<ul>
<li><p><code>docker search</code> 命令可以<strong>查找</strong>官方仓库中的镜像。</p>
</li>
<li><p><code>docker pull</code> 命令<strong>下载</strong>镜像到本地。</p>
</li>
<li><p>在登录后，可以使用 <code>docker push username/镜像名:标签</code> 将自己的镜像<strong>推送</strong>到 Docker Hub 中。</p>
</li>
</ul>
<hr>
<p>若不想使用官方的 Docker Hub 仓库，也可以创建私有仓库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Docker学习笔记 (2) 镜像操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 11:48:58" itemprop="dateCreated datePublished" datetime="2022-05-10T11:48:58+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">docker学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>使用<code>docker search</code>命令可以搜索镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker search redis</span><br><span class="line">NAME                                DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">redis                               Redis is an open <span class="built_in">source</span> key-value store that…   11669     [OK]</span><br><span class="line">bitnami/redis                       Bitnami Redis Docker Image                      236                  [OK]</span><br><span class="line">redislabs/redisinsight              RedisInsight - The GUI <span class="keyword">for</span> Redis                75</span><br><span class="line">redislabs/redisearch                Redis With the RedisSearch module pre-loaded…   56</span><br><span class="line">redislabs/rejson                    RedisJSON - Enhanced JSON data <span class="built_in">type</span> processi…   51</span><br><span class="line">redislabs/redis                     Clustered in-memory database engine compatib…   36</span><br></pre></td></tr></table></figure>

<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>使用 <code>docker run</code> 命令可以运行容器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Docker学习笔记 (1) 基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-09 20:48:11" itemprop="dateCreated datePublished" datetime="2022-05-09T20:48:11+08:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">docker学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker是基于Go语言开发并实现的，基于Linux内核的<strong>cgroups</strong>（control groups，控制群组，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源，如CPU、内存等）、<strong>namespace</strong>（是Linux内核用来隔离内核资源的方式，通过namespace可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源）以及<strong>Union FS</strong>等技术，对进程进行封装隔离，属于<strong>操作系统层面的虚拟化技术</strong>。</p>
<blockquote>
<p><strong>Docker和传统虚拟化技术的不同：</strong></p>
<p>传统虚拟机技术是<strong>虚拟出一套硬件</strong>后，在其上运行一个<strong>完整操作系统</strong>，在该系统上再运行所需应用进程：</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/virtualization.png" alt="传统虚拟化"></p>
<p>Docker容器内的应用进程<strong>直接运行于宿主的内核</strong>，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便：</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/docker.png" alt="Docker"></p>
</blockquote>
<!--more--->

<h2 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h2><p>Docker与传统虚拟化技术相比，有如下<strong>优点</strong>：</p>
<ul>
<li><strong>更高效的利用系统资源：</strong>Docker不需要对硬件虚拟化以及运行完整的操作系统等额外开销，所以Docker对系统资源的利用更有效。在相同配置下，Docker可以运行更多的应用程序。</li>
<li><strong>更快速的启动时间：</strong>Docker容器运行于宿主内核，启动速度可以达到秒级。</li>
<li><strong>一致的运行环境：</strong>Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。</li>
<li><strong>持续交付和部署：</strong>一次创建或配置，可以在任意地方正常运行。</li>
<li><strong>更轻松的迁移：</strong>Docker确保了执行环境的一致性，使得应用的迁移更加容易。</li>
<li><strong>更轻松的维护和扩展：</strong>Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Docker容器</th>
<th align="left">传统虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为 <code>MB</code></td>
<td align="left">一般为 <code>GB</code></td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般几十个</td>
</tr>
</tbody></table>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像是一个特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>Docker设计时，就充分利用了<strong>Union FS（联合文件系统）</strong>技术，将其设计为<strong>分层存储</strong>的结构。</p>
<p>镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组（<strong>多层</strong>）文件系统组成。</p>
<p>镜像构建时，<strong>会一层层构建，前一层是后一层的基础</strong>。每一层构建完就不会再发生改变，<strong>后一层上的任何改变只发生在自己这一层</strong>。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储使得镜像的复用、定制更加容易，<strong>可以用之前构建好的镜像作为基础层，然后进一步添加新的层</strong>，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成。</p>
<ul>
<li><p><strong>bootfs（boot file system）</strong>主要包含bootloader和kernel。<strong>bootloader主要是引导加载kernel</strong>，Linux刚启动时会加载bootfs文件系统，在<strong>Docker镜像的最底层是引导文件系统bootfs</strong>。这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
</li>
<li><p><strong>rootfs（root file system）</strong>，在bootfs之上。包含的就是典型 Linux 系统中的/dev、/proc、/bin、/etc等标准目录和文件。<strong>rootfs就是各种不同的操作系统发行版</strong>，如Ubuntu、CentOS等。</p>
</li>
</ul>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221223111944166.png" alt="image-20221223111944166"></p>
<blockquote>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
</blockquote>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像和容器的关系，就像是类和实例的关系。镜像是<strong>静态</strong>的定义，容器是镜像<strong>运行时</strong>的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的经常运行在一个隔离的环境里，因此也更加的安全。</p>
<h3 id="容器存储层"><a href="#容器存储层" class="headerlink" title="容器存储层"></a>容器存储层</h3><p>容器也使用<strong>分层存储</strong>，每一个容器运行时，以镜像为基础层，在其上创建一个当前容器的存储层用于容器运行时的读写，称为<strong>容器存储层</strong>。只有<strong>容器层是可写的</strong>，容器层下面的所有<strong>镜像层都是只读的</strong>。</p>
<p><img src="/../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221223112458661.png" alt="image-20221223112458661"></p>
<p><strong>容器存储层的生存周期和容器一样</strong>，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。因此所有的文件写入操作，都应该使用<strong>数据卷（Volume）</strong>，数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Docker Registry用于提供集中的<strong>存储、分发镜像</strong>的服务。</p>
<p>一个Docker Registry中可以包含多个<strong>仓库</strong>（Repository），每个仓库包含多个<strong>标签</strong>（Tag，标签用于指明镜像的版本），每个标签对应一个<strong>镜像</strong>。</p>
<p>可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>指定哪个版本的镜像，默认标签为<code>latest</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/04/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31/" class="post-title-link" itemprop="url">算法刷题笔记 (31) 整数反转</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 09:37:12" itemprop="dateCreated datePublished" datetime="2022-04-13T09:37:12+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法刷题笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer">整数反转</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过<strong>模10</strong>的方法取出最低位数字，通过<strong>除以10</strong>去掉最低为数字。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        res = res*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x = x/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res &gt; math.MaxInt32 || res &lt; math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">369</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
