<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/28/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/28/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/06/22/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/22/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/" class="post-title-link" itemprop="url">NLP学习笔记 (6) Parsing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-22 17:35:05" itemprop="dateCreated datePublished" datetime="2022-06-22T17:35:05+08:00">2022-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">NLP学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Constituency-Parsing"><a href="#Constituency-Parsing" class="headerlink" title="Constituency Parsing"></a>Constituency Parsing</h1><p><strong>Constituency Parsing 就是：</strong></p>
<ul>
<li><p>找出一段 text span 作为 <strong>constituents</strong></p>
</li>
<li><p>每一个 constituents 都有一个<strong>标签</strong></p>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655892270551.png" alt="1655892270551"></p>
<ul>
<li>对于<strong>每一个单词</strong>都是一个 constituent（标签为这个单词的词性）</li>
<li><strong>相邻的 constituent</strong> 可以组成一个<strong>更大</strong>的 constituent</li>
<li>一句话的所有单词，从底向上，可以组成一棵树</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655892544642.png" alt="1655892544642"></p>
<h2 id="Chart-based"><a href="#Chart-based" class="headerlink" title="Chart-based"></a>Chart-based</h2><p>Chart-based 方法实际上就是<strong>对每一个 span 进行两次分类</strong>：</p>
<ul>
<li>放入<strong>二分类</strong>：判断<strong>是否是</strong> constituent</li>
<li>放入<strong>多分类</strong>：constituent 属于哪一个<strong>标签</strong></li>
</ul>
<p>下图是 Chart-based 的结构，其中 <strong>Span Feature Extraction 与 Coreference Resolution 中的一样</strong>。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655893866459.png" alt="1655893866459"></p>
<hr>
<p>需要注意的是，对于 span 的选择可能会产生<strong>矛盾</strong>，比如两个<strong>重合</strong>的 span 都被判断出是 constituent，那么就无法组成一棵树。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655894066479.png" alt="1655894066479"></p>
<p><strong>解决方法就是</strong>，<strong>穷举出所有可能性的树</strong>，然后对每一棵树进行评分，选取评分最高的树。</p>
<h2 id="Transition-based"><a href="#Transition-based" class="headerlink" title="Transition-based"></a>Transition-based</h2><p>Transition-based 中由三个部分组成：</p>
<ul>
<li><strong>Stack</strong>：初始为空。</li>
<li><strong>Buffer</strong>：初始存放整个句子。</li>
<li><strong>Actions</strong>：包括三种操作<ul>
<li>NT (X)：创建一个带有 X 标签的 constituent</li>
<li>SHIFT：将一个 token 从 Buffer 移动到 Stack 中</li>
<li>REDUCE：结束一个 constituent</li>
</ul>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655894315635.png" alt="1655894315635"></p>
<p>实际上，我们需要训练一个<strong>分类模型</strong>，用于输出 Actions。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655894356049.png" alt="1655894356049"></p>
<h2 id="Tree-to-Sequence"><a href="#Tree-to-Sequence" class="headerlink" title="Tree to Sequence"></a>Tree to Sequence</h2><p>甚至，我们可以利用 <strong>Seq2seq Model</strong>，将语法树变为一个 Sequence，比如：</p>
<p>对树进行<strong>遍历</strong>，得到遍历序列，这个遍历序列就是 Sequence。需要注意的是，这个模型不需要输出单词（因为可能会改变输入的句子），可以用 XX 表示输入的一个单词。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655894496403.png" alt="1655894496403"></p>
<h1 id="Dependency-Parsing"><a href="#Dependency-Parsing" class="headerlink" title="Dependency Parsing"></a>Dependency Parsing</h1><p>Constituency Parsing 考虑的是一个句子中，相邻单词的关系。</p>
<p><strong>Dependency Parsing</strong> 考虑的是任意<strong>两个单词（不需要相邻）</strong>的关系，用箭头表示这种关系（标签为关系的类别），起始为 head，结束为 dependent。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1655894898468.png" alt="1655894898468"></p>
<p>Dependency Parsing就是将一句话变为有向图（Directed Graph，实际上也是一棵树），word 变为 node，关系变为 edge。</p>
<ul>
<li>所有 word 只有一个入边（除去 ROOT）。</li>
<li>从每一个 word 到 ROOT 有唯一的一条路径。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1656986928287.png" alt="1656986928287"></p>
<p>核心方法就是：两个<strong>分类器</strong>，输入是两个 word。</p>
<ul>
<li>判断左边是否指向右边。</li>
<li>判断属于哪一种关系。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Parsing/1656987793280.png" alt="1656987793280"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/06/20/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/" class="post-title-link" itemprop="url">NLP学习笔记 (5) 自注意力机制和Transformer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 17:52:30" itemprop="dateCreated datePublished" datetime="2022-06-20T17:52:30+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">NLP学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Self-Attention-机制"><a href="#Self-Attention-机制" class="headerlink" title="Self-Attention 机制"></a>Self-Attention 机制</h1><p>将各个向量放入 <strong>Self-Attention</strong>（可以使用多次） 中，得到与<strong>整个句子都相关</strong>的另外的向量。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655719447203.png" alt="1655719447203"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Self-Attention 层，输入一些向量，输出另一些向量。每一个输出的向量与输入的向量都有关系。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655719567664.png" alt="1655719567664"></p>
<p>对于如何输出一个向量，实际上是看其他向量是否对应的输入<strong>有关系（relevant）</strong>。这里的有关系的程度用 <strong>α</strong> 表示：</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655719768962.png" alt="1655719768962"></p>
<p>对于<strong>如何计算 α</strong>，有两种方式：</p>
<ul>
<li><strong>Dot-product</strong>：输入向量乘以一个矩阵 W，之后再做点乘，点乘结果为 α。（transformer使用） </li>
<li><strong>Additive</strong>：输入向量乘以一个矩阵 W，相加之后进入 tanh，最后经过线性变换得到 α。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655719747182.png" alt="1655719747182"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li><strong>得到相关性分数 α</strong>：首先输入乘以矩阵得到向量 q 和 k，将 q 和 k 点乘（<strong>dot-product</strong>）后进入 <strong>soft-max（作用是 normalization，也可以用其他的）</strong> 层：</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655721797344.png" alt="1655721797344"></p>
<ul>
<li><strong>根据 α 提取信息</strong>：将输入与矩阵相乘得到<strong>向量 v</strong>，再与 soft-max 的输出相乘并相加得到 Self-Attention 的输出 b。<strong>相关性大，则 α 大，所以输出中对应 v 的占比越高</strong>。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655721841471.png" alt="1655721841471"></p>
<h2 id="Multi-head-Self-Attention"><a href="#Multi-head-Self-Attention" class="headerlink" title="Multi-head Self-Attention"></a>Multi-head Self-Attention</h2><p>这是 Self-Attention 的变形，用于计算不同种类的相关性。</p>
<p>最大的不同就是 q、k、v 三种向量<strong>乘以多个矩阵</strong>（矩阵的个数就是 head 的数量，即种数）得到<strong>不同的种类</strong>，每一种单独 Attention 得到每一种对应的输出。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655722732610.png" alt="1655722732610"></p>
<p>最后将每一种输出乘以一个矩阵，得到最终的输出。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655722841770.png" alt="1655722841770"></p>
<h2 id="加上位置信息-Positional-Encoding"><a href="#加上位置信息-Positional-Encoding" class="headerlink" title="加上位置信息 - Positional Encoding"></a>加上位置信息 - Positional Encoding</h2><p>上述的 Self-Attention 中，是没有位置信息的。若需要<strong>位置信息</strong>，则需要 <strong>Positional Encoding</strong>。具有工作如下：</p>
<ul>
<li>每一个位置 i，都有一个唯一的位置向量 ei</li>
<li>输入加上位置向量之后再 Attention 即可</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655723108847.png" alt="1655723108847"></p>
<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>Transformer 是一种 <strong>Seq2seq Model</strong>（输入一个 sequence，输出一个 sequence）。</p>
<h2 id="Seq2seq-结构"><a href="#Seq2seq-结构" class="headerlink" title="Seq2seq 结构"></a>Seq2seq 结构</h2><p>Seq2seq Model 的结构包括一个 <strong>Encoder</strong> 和一个  <strong>Decoder</strong>。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655809629816.png" alt="1655809629816"></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>Encoder 输入一排向量，输出另外一排向量。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655809876570.png" alt="1655809876570"></p>
<p>其中 Encoder 是 N 个 block 的重复，每一个 block 的结构如下：</p>
<ul>
<li>Self-Attention</li>
<li>Residual + Norm</li>
<li>全连接层（上图中 Feed Forward）</li>
<li>Residual + Norm</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655809982256.png" alt="1655809982256"></p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><h4 id="Autoregressive（AT）"><a href="#Autoregressive（AT）" class="headerlink" title="Autoregressive（AT）"></a>Autoregressive（AT）</h4><p>Autoregressive 就是在输出时，从左到右依次输出。其最显著的特点就是，<strong>每一个 Decoder 的输出作为下一次 Decoder 的输入</strong>。</p>
<p>Decoder 和 Encoder 的结构比较类似，区别在于：</p>
<ul>
<li>第一个 Attention 变为了 <strong>Masked</strong> Multi-Head Attention（Encoder中为 Multi-Head Attention）：Mask 的含义就是每一次 Attention，<strong>只看前面的向量，不看后面的向量</strong>。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655811020124.png" alt="1655811020124"></p>
<ul>
<li><strong>增加</strong>了一层 Multi-Head Attention 和 Add &amp; Norm</li>
<li>最后一个 block 的输出进入<strong>线性层</strong>和 <strong>soft-max 层</strong>，输出的是最大可能性对应的结果（将这个输出放入下一次 Decoder 的输入）。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655810751137.png" alt="1655810751137"></p>
<h4 id="Non-autoregressive（NAT）"><a href="#Non-autoregressive（NAT）" class="headerlink" title="Non-autoregressive（NAT）"></a>Non-autoregressive（NAT）</h4><p><strong>AT 和 NAT 的比较</strong>：</p>
<ul>
<li>AT 将 Decoder 的输出作为下一次 Decoder 的输入；NAT 输入的只有 BEGIN token，输入不会进入 Decoder 的输入。</li>
<li>如何得到 NAT 的输出长度？（Seq2seq 输出长度是不确定的）<ul>
<li>训练一个 Model 进行输出长度的预测。</li>
<li>输出一个很长的 sequence，忽略 END token 之后的东西。</li>
</ul>
</li>
<li>NAT 的优点：<ul>
<li>可以并行化计算，因为不用等待上一个 Decoder 的输出。</li>
<li>可以控制输出长度。</li>
</ul>
</li>
<li>NAT 通常比 AT 表现更差。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655811450753.png" alt="1655811450753"></p>
<h3 id="Encoder-Decoder-之间的连接部分"><a href="#Encoder-Decoder-之间的连接部分" class="headerlink" title="Encoder-Decoder 之间的连接部分"></a>Encoder-Decoder 之间的连接部分</h3><p>实际上，Decoder 中多出的一层 Multi-Head Attention 和 Add &amp; Norm，就是用于连接 Encoder 和 Decoder。</p>
<p>这一部分被称为 <strong>Cross Attention</strong>。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655811789284.png" alt="1655811789284"></p>
<p>Cross Attention 的详细结构如下，计算 <strong>Decoder 中 Masked Multi-Head Attention 的输出</strong>向量与 <strong>Encoder 的输出</strong>之间的相关性（Attention）。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655811904635.png" alt="1655811904635"></p>
<h3 id="如何训练"><a href="#如何训练" class="headerlink" title="如何训练"></a>如何训练</h3><p>训练时，采用<strong>强制学习（Teacher Forcing）</strong>：每一次向 Decoder 的输入并不是上一次 Decoder 的输出，而是正确的结果。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%92%8CTransformer/1655812460812.png" alt="1655812460812"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/06/15/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/" class="post-title-link" itemprop="url">NLP学习笔记 (4) Coreference Resolution</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-15 17:40:47" itemprop="dateCreated datePublished" datetime="2022-06-15T17:40:47+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">NLP学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Coreference-Resolution"><a href="#Coreference-Resolution" class="headerlink" title="Coreference Resolution"></a>Coreference Resolution</h1><p><strong>Coreference Resolution</strong>，即代指消解，识别出代指的相同的东西。</p>
<p>需要识别出代指的一段文字（如他、它的 XX 等），称为 <strong>mention</strong>。代指消解的结果就是将同一个代指的 mention，放入同一个 <strong>cluster</strong> 中。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><strong>识别出 mention</strong>：需要一个二分类器，输入一个 span，判别是否是一个 mention。若有 N 个 token 的句子，需要运行 <code>N(N-1)/2</code> 次。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655291452800.png" alt="1655291452800"></p>
<ul>
<li><strong>识别哪些 mention 需要放在同一个 cluster 中</strong>：同样需要一个二分类器，输入为两个 mention，输出判断是否属于同一个 cluster。若有 K 个 mention，需要运行 <code>K(K-1)/2</code> 次。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655291785154.png" alt="1655291785154"></p>
<p><strong>或者可以</strong>直接输入两个 span 到二分类器中，判断这两个 span 是否代指同一个实体。若有 N 个 token，则有 <code>K=N(N-1)/2</code> 个 span，需要运行 <code>K(K-1)/2</code> 次。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655291986984.png" alt="1655291986984"></p>
<h2 id="训练二分类器"><a href="#训练二分类器" class="headerlink" title="训练二分类器"></a>训练二分类器</h2><p>一个通常的用于 Coreference Resolution 二分类器如下：</p>
<ul>
<li><p>将句子中的所有 token 输入预训练模型中，得到 embedding。</p>
</li>
<li><p>将 embedding span 输入 Span Feature Extraction，得到两个向量（每一个 Span Feature Extraction 将 embedding 汇聚成一个 embedding）。</p>
</li>
<li><p>判断两个向量是否是 mention、是否属于同一个 cluster，最终输出一个分数。</p>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655292350102.png" alt="1655292350102"></p>
<p>对于 <strong>Span Feature Extraction</strong>，结构如下。将 embedding span 进行 <strong>Attention</strong>，得到一个 Attention 向量，再把 span <strong>中起始 embedding</strong> 和<strong>最后一个 embedding</strong> 与 <strong>Attention 向量</strong>相加，得到 Span Feature Extraction 的输出向量。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655294345873.png" alt="1655294345873"></p>
<hr>
<p>上述是有监督模型，那么是否可以训练一个<strong>无监督</strong>模型呢？</p>
<p>答案是可以的，把 <strong>mention Mask 起来</strong>，这样模型的输出就是相关的代指实体。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Coreference-Resolution/1655295040850.png" alt="1655295040850"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/06/15/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">GO语言杂谈 (12) 内存管理和编译器优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-15 11:16:34" itemprop="dateCreated datePublished" datetime="2022-06-15T11:16:34+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">Go语言杂谈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Go 中，内存分配主要有两个思想：</p>
<ul>
<li><strong>分块</strong></li>
<li><strong>缓存</strong></li>
</ul>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>分块的思路为：</p>
<ul>
<li>调用系统调用 <code>mmap()</code> 向 OS 申请一大块内存，例如 4MB。</li>
<li>将内存划分为大块，例如 8KB，称为 <strong>mspan</strong>。<ul>
<li><strong>noscan mspan</strong>：分配不包含指针的对象，GC 不需要扫描。</li>
<li><strong>scan mspan</strong>：分配包含指针的对象，GC 需要扫描。</li>
</ul>
</li>
<li>再将 mspan 划分为特定大小的<strong>小块</strong>，用于<strong>对象分配</strong>。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存的基本思路是：</p>
<ul>
<li>每一个 P 包含一个 <strong>mcache</strong> 用于快速分配，mcache 管理<strong>一组 mspan</strong>。</li>
<li>当 mcache 中的 mspan 分配完毕，向 <strong>mcentral</strong> 申请带有未分配块的 mspan。</li>
<li>当 mspan 中没有分配的对象，mspan 会被<strong>缓存</strong>在 mcentral 中，而不是立刻释放归还给 OS。</li>
</ul>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/1655263401798.png" alt="1655263401798"></p>
<h2 id="优化-Balanced-GC"><a href="#优化-Balanced-GC" class="headerlink" title="优化 - Balanced GC"></a>优化 - Balanced GC</h2><p>字节跳动有自己的 Go 语言内存管理优化方案，即 <strong>Balanced GC</strong>，其思路如下：</p>
<p>每个 G 都绑定一大块内存（1 KB），称为 <strong>Goroutine Allocation Buffer（GAB）</strong>。</p>
<ul>
<li>GAB 用于 <strong>noscan</strong> 类型的<strong>小对象（小于 128B）</strong>的分配。</li>
<li>GAB 使用三个指针进行维护：<strong>base、end、top</strong>。使用<strong>指针碰撞</strong>风格进行对象分配。</li>
</ul>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/1655263925528.png" alt="1655263925528"></p>
<ul>
<li>GAB 对于 Go 内存管理来说就是一个<strong>大对象</strong>。</li>
</ul>
<hr>
<p>GAB 有一个<strong>问题</strong>：会导致<strong>内存被延迟释放</strong>，GAB 中即使只有一个很小的对象存活，Go 内存管理也不会回收其余空闲空间。</p>
<p><strong>解决方法</strong>：</p>
<p>当 GAB 中存活对象大小<strong>少于一定阈值</strong>时，<strong>将 GAB 中存活的对象复制到另外分配的 GAB（Survivor GAB）中</strong>，原先的 GAB 可以释放。</p>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/1655264117801.png" alt="1655264117801"></p>
<h1 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h1><h2 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h2><p><strong>函数内联</strong>是指，将被<strong>调用函数的函数体</strong>的<strong>副本</strong>，<strong>替换</strong>到<strong>调用位置</strong>上，同时重写代码以反映参数的绑定。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>消除函数调用的开销，如传递参数、保存寄存器等。</li>
<li>扩展了函数边界，更多对象不逃逸分析。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>函数体变大。</li>
<li>编译生成的可执行文件变大。</li>
</ul>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析<strong>步骤</strong>：</p>
<ul>
<li>从对象分配处出发，观察对象的数据流。</li>
<li>若发现<strong>指针 p</strong> 在当前作用域 s：<ul>
<li>作为参数传递给<strong>其他函数</strong></li>
<li>传递给<strong>全局变量</strong></li>
<li>传递给<strong>其他 goroutine</strong></li>
<li>传递给<strong>已逃逸的指针指向的对象</strong></li>
</ul>
</li>
<li>则指针 p 指向的对象逃逸出 s，反正没有逃逸。</li>
</ul>
<p>对于<strong>未逃逸</strong>的对象，在<strong>栈</strong>上分配；<strong>逃逸</strong>对象，在<strong>堆</strong>上分配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/06/14/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/14/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">GO语言杂谈 (11) 依赖管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-14 23:15:29" itemprop="dateCreated datePublished" datetime="2022-06-14T23:15:29+08:00">2022-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">Go语言杂谈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-依赖管理演进"><a href="#Go-依赖管理演进" class="headerlink" title="Go 依赖管理演进"></a>Go 依赖管理演进</h1><p>Go 语言中，依赖管理的演进分为<strong>三个阶段</strong>，依次是：</p>
<ul>
<li><strong>GOPATH</strong></li>
<li><strong>Go Vendor</strong></li>
<li><strong>Go Module</strong></li>
</ul>
<h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>配置环境变量 <code>$GOPATH</code>，GOPATH 下有以下三个文件夹：</p>
<ul>
<li>bin：项目编译的二进制文件</li>
<li>pkg：项目编译的中间产物，用于加速编译</li>
<li>src：项目源码</li>
</ul>
<p><strong>项目的代码直接依赖于 src 下的代码</strong>，可以通过 <code>go get</code> 命令将依赖包下载到 src 下。</p>
<hr>
<p>GOPATH 的<strong>缺点</strong>在于：无法实现对 package 的<strong>多版本控制</strong>。</p>
<p>若 A 和 B 依赖于某一 package 的不同版本，这样的情况 GOPATH 无法解决。</p>
<h2 id="Go-Vendor"><a href="#Go-Vendor" class="headerlink" title="Go Vendor"></a>Go Vendor</h2><p>项目目录下<strong>增加 vendor 文件夹</strong>，所有依赖包的<strong>副本</strong>存放在项目下的 vendor 文件夹中。</p>
<p>若 vendor 中没有依赖包，则会在 GOPATH 下去寻找。</p>
<hr>
<p>Go Vendor 的<strong>缺点</strong>在于：无法控制依赖的版本、更新项目可能出现依赖冲突。</p>
<p>若一个项目依赖于 package B 和 packag C，而 package B 依赖于 package D-V1 版本；package C 依赖于 package D-V2 版本。这样的场景下，Go Vendor 无法很好的解决。</p>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/1655220603232.png" alt="1655220603232"></p>
<h2 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h2><p>Go Module 通过 <strong>go.mod 文件</strong>管理依赖包版本。</p>
<p>通过 go get / go mod 工具，管理依赖包。</p>
<h1 id="Go-Module-详解"><a href="#Go-Module-详解" class="headerlink" title="Go Module 详解"></a>Go Module 详解</h1><h2 id="依赖管理三要素"><a href="#依赖管理三要素" class="headerlink" title="依赖管理三要素"></a>依赖管理三要素</h2><p>Go Module 中，依赖管理需要三要素：</p>
<ul>
<li><strong>go.mod</strong>：配置文件，描述依赖。</li>
<li><strong>Proxy</strong>：中心仓库管理依赖库。</li>
<li><strong>go get/mod</strong>：本地工具。</li>
</ul>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>go.mod 文件主要由三部分构成：</p>
<ul>
<li>依赖管理基本单元：标识了这个模块可以在哪里找到（被其他人引用）。</li>
<li>原生库：Go 的版本号。</li>
<li>单元依赖：描述依赖关系，主要两部分组成。<ul>
<li>包名（Module Path）</li>
<li>版本号</li>
</ul>
</li>
</ul>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/1655220918315.png" alt="1655220918315"></p>
<p>其中，可以看到单元依赖的一些配置：</p>
<ul>
<li>version：<ul>
<li><strong>语义化版本</strong>：<code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code>，<strong>MAJOR</strong> 是一个大版本，不同 MAJOR 可以<strong>不兼容</strong>。<strong>MINOR</strong> 做出了一些新增函数，同一个 MAJOR 下需要<strong>相互兼容</strong>。<strong>PATCH</strong> 做了一些 bug 修复。</li>
<li><strong>基于 commit 伪版本</strong>：<code>vx.0.0-yyyymmddhhmmss-abcdefgh1234</code>。</li>
</ul>
</li>
<li>indirect：对于没有直接依赖的 package，就用 indirect 标识出来。</li>
<li>incompatible：如果 MAJOR 版本大于 1 时，其<strong>版本号还需要体现在 Module 名字</strong>中（如 <code>xxx/xx/v2</code>）。但是如果 Module 名字未遵循这条规则，则会打上 incompatible 标记。</li>
</ul>
<hr>
<p>Go 在选择版本时，会选择<strong>最低的兼容版本</strong>：</p>
<p>如下图中，最终编译时所使用的 C 项目版本为 1.4 版本。</p>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/1655221776213.png" alt="1655221776213"></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><strong>Go Proxy 是一个服务站点</strong>，他会缓存源站中的软件内容，缓存的软件版本不会改变，源站软件删除后依然可用。</p>
<p><img src="/../images/GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-11-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/1655221901310.png" alt="1655221901310"></p>
<p><code>GOPROXY=&quot;https://proxy1.cn,https://proxy2.cn,direct&quot;</code>，含义是<strong>依次</strong>从 proxy1、proxy2、源站中获取 package。</p>
<h3 id="go-get-mod"><a href="#go-get-mod" class="headerlink" title="go get/mod"></a>go get/mod</h3><ul>
<li><p><strong>go get</strong>：<code>go get example.org/pkg</code>，参数如下：</p>
<ul>
<li><code>@update</code>：默认，获取最新版本。</li>
<li><code>@none</code>：删除依赖。</li>
<li><code>@v1.1.1</code>：语义化版本。</li>
<li><code>@45dfsf</code>：特定的 commit。</li>
<li><code>@master</code>：分支的最新 commit。</li>
</ul>
</li>
<li><p><strong>go mod</strong>：参数如下：</p>
<ul>
<li><code>init</code>：初始化，创建 go.mod 文件。</li>
<li><code>download</code>：下载模块到本地。</li>
<li><code>tidy</code>：增加需要的依赖，删除不需要的依赖。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/31/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-BERT%E5%8F%8A%E5%85%B6%E5%AE%B6%E6%97%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-BERT%E5%8F%8A%E5%85%B6%E5%AE%B6%E6%97%8F/" class="post-title-link" itemprop="url">NLP学习笔记 (3) BERT及其家族</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-31 16:51:03" itemprop="dateCreated datePublished" datetime="2022-05-31T16:51:03+08:00">2022-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">NLP学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BERT-介绍"><a href="#BERT-介绍" class="headerlink" title="BERT 介绍"></a>BERT 介绍</h1><p>我们将一些不带标注的文章，先<strong>预训练</strong>，得到一个 Model，这个 Model 可以看作是能够理解文字内容。</p>
<p>接着用一些带标注的特殊语料，进行 <strong>Fine-tune（微调）</strong>，训练出可以完成特殊任务的 Model。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-BERT%E5%8F%8A%E5%85%B6%E5%AE%B6%E6%97%8F/1654002682379.png" alt="1654002682379"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/31/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-BERT%E5%8F%8A%E5%85%B6%E5%AE%B6%E6%97%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/30/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">NLP学习笔记 (2) NLP任务概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-30 20:34:20" itemprop="dateCreated datePublished" datetime="2022-05-30T20:34:20+08:00">2022-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">NLP学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NLP-任务分类"><a href="#NLP-任务分类" class="headerlink" title="NLP 任务分类"></a>NLP 任务分类</h1><p>NLP 任务总的来说分为两类：</p>
<ul>
<li>输入文字，输出类别。</li>
<li>输入文字，输出另一段文字。</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653914138938.png" alt="1653914138938"></p>
<p>那么进一步的，可以根据输入和输出的不同，进行划分。</p>
<h2 id="输出的不同"><a href="#输出的不同" class="headerlink" title="输出的不同"></a>输出的不同</h2><ul>
<li>输出类别：<ul>
<li>为一段话，只输出一个类别。</li>
<li>为每一个 token 都输出一个类别。</li>
</ul>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653914425983.png" alt="1653914425983"></p>
<ul>
<li>输出另一段文字：<ul>
<li>使用 seq2seq 模型。</li>
</ul>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653914435623.png" alt="1653914435623"></p>
<h2 id="输入的不同"><a href="#输入的不同" class="headerlink" title="输入的不同"></a>输入的不同</h2><ul>
<li>一段文字。</li>
<li>多段文字：<ul>
<li>将多段文字拼接起来，中间用 <code>&lt;SEP&gt;</code> 连接。</li>
<li>分别放入 Model 中，再对输出进行整合。</li>
</ul>
</li>
</ul>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653914566952.png" alt="1653914566952"></p>
<h1 id="NLP-任务"><a href="#NLP-任务" class="headerlink" title="NLP 任务"></a>NLP 任务</h1><p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653916977054.png" alt="1653916977054"></p>
<h1 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h1><p>知识图谱中，最重要的就是<strong>实体（Entity）</strong>和<strong>关系（Relation）</strong>。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653917666204.png" alt="1653917666204"></p>
<h2 id="提取实体-NER"><a href="#提取实体-NER" class="headerlink" title="提取实体 - NER"></a>提取实体 - NER</h2><p><strong>NER，Name Entity Recognition</strong>，命名实体识别。用于提取一段文字中给定的实体信息。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653917699539.png" alt="1653917699539"></p>
<h2 id="提取关系"><a href="#提取关系" class="headerlink" title="提取关系"></a>提取关系</h2><p>提取关系，可以看成是一种<strong>分类</strong>问题。</p>
<p><img src="/../images/NLP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-NLP%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/1653917789907.png" alt="1653917789907"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/30/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-7-%E4%BD%BF%E7%94%A8Protobuf%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-7-%E4%BD%BF%E7%94%A8Protobuf%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">从零实现分布式缓存 (7) 使用Protobuf通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-30 15:09:13" itemprop="dateCreated datePublished" datetime="2022-05-30T15:09:13+08:00">2022-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节实现 protobuf 进行节点间的通信。最终代码结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dawncachepb/</span><br><span class="line">	|--dawncachepb.pb.go</span><br><span class="line">	|--dawncachepb.proto</span><br><span class="line">lru/</span><br><span class="line">	|--lru.go</span><br><span class="line">	|--lru_test.go</span><br><span class="line">singleflight/</span><br><span class="line">	|--singleflight.go</span><br><span class="line">byteview.go</span><br><span class="line">cache.go</span><br><span class="line">consistenthash.go</span><br><span class="line">dawncache.go</span><br><span class="line">dawncache_test.go</span><br><span class="line">go.mod</span><br><span class="line">http.go</span><br><span class="line">peers.go</span><br></pre></td></tr></table></figure>

<h1 id="使用-protobuf-通信"><a href="#使用-protobuf-通信" class="headerlink" title="使用 protobuf 通信"></a>使用 protobuf 通信</h1><h2 id="编写-proto-文件"><a href="#编写-proto-文件" class="headerlink" title="编写 proto 文件"></a>编写 proto 文件</h2><p><code>dawncachepb/dawncachepb.proto</code></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> dawncachepb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./;dawncachepb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="keyword">group</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> key = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bytes</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GroupCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Get(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成-pb-go-代码"><a href="#生成-pb-go-代码" class="headerlink" title="生成 pb.go 代码"></a>生成 pb.go 代码</h2><p>生成 <code>dawncachepb.pb.go</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. *.proto</span><br></pre></td></tr></table></figure>

<p><code>dawncachepb/dawncachepb.pb.go</code> 有如下数据类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	Group <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=group,proto3&quot; json:&quot;group,omitempty&quot;`</span></span><br><span class="line">	Key   <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=key,proto3&quot; json:&quot;key,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	Value []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改-PeerGetter-接口"><a href="#修改-PeerGetter-接口" class="headerlink" title="修改 PeerGetter 接口"></a>修改 PeerGetter 接口</h2><p>修改 <code>peers.go</code> 中的 <code>PeerGetter</code> 接口，参数使用 <code>geecachepb.pb.go</code> 中的数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerGetter 远程获取数据的接口</span></span><br><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Get 根据 groupName 和 key 获取源数据</span></span><br><span class="line">	Get(in *pb.Request, out *pb.Response) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改使用-PeerGetter-接口的代码"><a href="#修改使用-PeerGetter-接口的代码" class="headerlink" title="修改使用 PeerGetter 接口的代码"></a>修改使用 PeerGetter 接口的代码</h2><p><code>dawncache.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getFromPeer 从 peer 处获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(peer PeerGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	req := &amp;pb.Request&#123;</span><br><span class="line">		Group: g.name,</span><br><span class="line">		Key:   key,</span><br><span class="line">	&#125;</span><br><span class="line">	res := &amp;pb.Response&#123;&#125;</span><br><span class="line">	err := peer.Get(req, res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;b: res.Value&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>http.go</code></p>
<ul>
<li><code>ServeHTTP()</code> 中使用 <code>proto.Marshal()</code> 编码 HTTP 响应。</li>
<li><code>Get()</code> 中使用 <code>proto.Unmarshal()</code> 解码 HTTP 响应。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP 处理查询缓存的请求，实现了 http.Handler 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断是否有 basePath</span></span><br><span class="line">	<span class="keyword">if</span> !strings.HasPrefix(r.URL.Path, p.basePath) &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;HTTPPool serving unexpected path: &quot;</span>+r.URL.Path, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否有 groupName 和 key</span></span><br><span class="line">	parts := strings.SplitN(r.URL.Path[<span class="built_in">len</span>(p.basePath):], <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;bad request&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	groupName := parts[<span class="number">0</span>]</span><br><span class="line">	key := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 groupName 获取 group</span></span><br><span class="line">	group := GetGroup(groupName)</span><br><span class="line">	<span class="keyword">if</span> group == <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;no such group:&quot;</span>+groupName, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从缓存中获取数据</span></span><br><span class="line">	view, err := group.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 响应客户端</span></span><br><span class="line">	body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;) <span class="comment">// 编码</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">	w.Write(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 实现了 PeerGetter 接口，用于远程获取源数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HTTPGetter)</span> <span class="title">Get</span><span class="params">(in *pb.Request, out *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	url := fmt.Sprintf(<span class="string">&quot;%s%s/%s&quot;</span>, h.basePath, url.QueryEscape(in.GetGroup()), url.QueryEscape(in.GetKey()))</span><br><span class="line"></span><br><span class="line">	res, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 发送请求失败</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="comment">// 状态码不是 200</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;server status code: %v&quot;</span>, res.StatusCode)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 读取数据失败</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;read response body failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err = proto.Unmarshal(data, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decoding response body: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-6-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-6-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/" class="post-title-link" itemprop="url">从零实现分布式缓存 (6) 防止缓存击穿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-29 17:05:20" itemprop="dateCreated datePublished" datetime="2022-05-29T17:05:20+08:00">2022-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节实现实现了防止缓存击穿的措施，通过多个并发请求映射为一个请求来实现。最终代码结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lru/</span><br><span class="line">	|--lru.go</span><br><span class="line">	|--lru_test.go</span><br><span class="line">singleflight/</span><br><span class="line">	|--singleflight.go</span><br><span class="line">byteview.go</span><br><span class="line">cache.go</span><br><span class="line">consistenthash.go</span><br><span class="line">dawncache.go</span><br><span class="line">dawncache_test.go</span><br><span class="line">go.mod</span><br><span class="line">http.go</span><br><span class="line">peers.go</span><br></pre></td></tr></table></figure>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li><strong>缓存雪崩</strong>：缓存在<strong>同一时刻全部失效</strong>，造成瞬时 DB 请求量过大、压力骤增。缓存雪崩通常因为<strong>缓存服务器宕机</strong>、缓存的 key 设置了<strong>相同的过期时间</strong>等引起。</li>
<li><strong>缓存击穿</strong>：一个存在的 key，在<strong>缓存过期的一瞬间</strong>，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</li>
<li><strong>缓存穿透</strong>：查询一个<strong>不存在的数据</strong>，因为不存在则不会写到缓存中，所以每次都会去请求 DB。</li>
</ul>
<h1 id="singleflight-实现"><a href="#singleflight-实现" class="headerlink" title="singleflight 实现"></a>singleflight 实现</h1><p><code>singleflight/singleflight.go</code></p>
<p>dawncache 通过 singleflight 来实现防止缓存击穿。</p>
<h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>首先定义 <strong>call</strong>，代表一次请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call 代表一次查询请求</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Group</strong> 记录了待查询的 key 和一次请求之间的映射关系。</p>
<p>当 key 还在 hashMap 中时，视为一次请求即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex       <span class="comment">// 对 hashMap 的访问互斥</span></span><br><span class="line">	hashMap <span class="keyword">map</span>[<span class="keyword">string</span>]*call <span class="comment">// 保存 key 和请求的映射关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Do-方法"><a href="#实现-Do-方法" class="headerlink" title="实现 Do 方法"></a>实现 Do 方法</h2><p><strong>Do 方法</strong>实现了多次相同的查询，到一次请求的映射操作：</p>
<ul>
<li><strong>查询 hashMap</strong> 中是否已经记录了 key 对应的 call 操作，如果有，则等待这一次请求得到数据并返回结果。</li>
<li>如果不在 hashMap 中，则<strong>新建一个查询</strong>请求 call 并记录在 hashMap 中，待执行过查询操作之后再返回数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.hashMap == <span class="literal">nil</span> &#123; <span class="comment">// 延迟初始化</span></span><br><span class="line">		g.hashMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.hashMap[key]; ok &#123;</span><br><span class="line">		<span class="comment">// 已在 hashMap 中记录，等待结果即可</span></span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有在 hashMap 中记录</span></span><br><span class="line">	<span class="comment">// 新建 call 在 hashMap 中记录</span></span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.hashMap[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 远程请求数据</span></span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done() <span class="comment">// 得到数据</span></span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.hashMap, key)</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="修改主流程"><a href="#修改主流程" class="headerlink" title="修改主流程"></a>修改主流程</h1><p><code>dawncache.go</code></p>
<p>需要修改 <strong>Group 结构体</strong>，使之能够防止缓存穿透：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	loader    *singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGroup 新建一个 *Group 缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	g := &amp;Group&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		loader:    <span class="built_in">new</span>(singleflight.Group),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <strong>load 方法</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load 从别处加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	view, err := g.loader.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// peers 不为空，可以从远程获取数据</span></span><br><span class="line">			<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class="line">				<span class="comment">// 从远程获取数据</span></span><br><span class="line">				view, err := g.getFromPeer(peer, key)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Println(<span class="string">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> view, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 本地通过回调函数获取数据</span></span><br><span class="line">		<span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> view.(ByteView), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-5-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-5-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/" class="post-title-link" itemprop="url">从零实现分布式缓存 (5) 分布式节点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-28 22:13:44" itemprop="dateCreated datePublished" datetime="2022-05-28T22:13:44+08:00">2022-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节实现一致性哈希选择节点，并且实现了 HTTP 客户端。最终代码结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lru/</span><br><span class="line">	|--lru.go</span><br><span class="line">	|--lru_test.go</span><br><span class="line">byteview.go</span><br><span class="line">cache.go</span><br><span class="line">consistenthash.go</span><br><span class="line">dawncache.go</span><br><span class="line">dawncache_test.go</span><br><span class="line">go.mod</span><br><span class="line">http.go</span><br><span class="line">peers.go</span><br></pre></td></tr></table></figure>

<h1 id="PeerPicker"><a href="#PeerPicker" class="headerlink" title="PeerPicker"></a>PeerPicker</h1><p>分布式缓存获取数据的流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                            是</span><br><span class="line">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class="line">                |  否                         是</span><br><span class="line">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class="line">                            |  否</span><br><span class="line">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>

<p>之前已经实现了 (1) 和 (3) 现在需要实现流程 (2) 从远程获取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用一致性哈希选择节点        是                                    是</span><br><span class="line">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class="line">                    |  否                                    ↓  否</span><br><span class="line">                    |----------------------------&gt; 回退到本地节点处理。</span><br></pre></td></tr></table></figure>

<h2 id="抽象-PeerPicker"><a href="#抽象-PeerPicker" class="headerlink" title="抽象 PeerPicker"></a>抽象 PeerPicker</h2><p><code>peers.go</code></p>
<ul>
<li><p>现在需要定义一个 <strong>PeerPicker 接口</strong>，用于选择与哪一个节点进行通信。</p>
</li>
<li><p><strong>PeerGetter 接口</strong>用于具体的远程获取数据的操作。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerPicker 选取节点的接口</span></span><br><span class="line"><span class="keyword">type</span> PeerPicker <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// PickPeer 根据 key 选择相应的 PeerGetter 获取数据</span></span><br><span class="line">	PickPeer(key <span class="keyword">string</span>) (peer PeerGetter, ok <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PeerGetter 远程获取数据的接口</span></span><br><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Get 根据 groupName 和 key 获取源数据</span></span><br><span class="line">	Get(groupName <span class="keyword">string</span>, key <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="节点选择与-HTTP-客户端"><a href="#节点选择与-HTTP-客户端" class="headerlink" title="节点选择与 HTTP 客户端"></a>节点选择与 HTTP 客户端</h1><p><code>http.go</code></p>
<h2 id="实现-PeerGetter"><a href="#实现-PeerGetter" class="headerlink" title="实现 PeerGetter"></a>实现 PeerGetter</h2><p>首先定义一个 <strong>HTTPGetter 结构体</strong>，用于实现 <strong>PeerGetter</strong> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTPGetter 通过 HTTP 远程获取数据</span></span><br><span class="line"><span class="keyword">type</span> HTTPGetter <span class="keyword">struct</span> &#123;</span><br><span class="line">	basePath <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Get 方法，用于远程获取数据，它通过发送 HTTP GET 请求来从远程获取数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 实现了 PeerGetter 接口，用于远程获取源数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HTTPGetter)</span> <span class="title">Get</span><span class="params">(groupName <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	url := fmt.Sprintf(<span class="string">&quot;%s%s/%s&quot;</span>, h.basePath, groupName, key)</span><br><span class="line"></span><br><span class="line">	res, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 发送请求失败</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="comment">// 状态码不是 200</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;server status code: %v&quot;</span>, res.StatusCode)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 读取数据失败</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;read response body failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ PeerGetter = (*HTTPGetter)(<span class="literal">nil</span>) <span class="comment">// 检查实现 PeerGetter 接口</span></span><br></pre></td></tr></table></figure>

<h2 id="实现-PeerPicker"><a href="#实现-PeerPicker" class="headerlink" title="实现 PeerPicker"></a>实现 PeerPicker</h2><p>修改 <strong>HTTPPool 结构体</strong>，使之记录<strong>一致性哈希</strong>的结构体以及 <strong>HTTPGetter</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	self        <span class="keyword">string</span> <span class="comment">// 如 http://127.0.0.1:8080</span></span><br><span class="line">	basePath    <span class="keyword">string</span> <span class="comment">// 节点间通讯地址的前缀，如 http:// 127.0.1:8080/basePath/groupName/key 用于请求数据</span></span><br><span class="line">	mu          sync.Mutex</span><br><span class="line">	peers       *Map                   <span class="comment">// 一致性哈希，根据 key 来选择节点</span></span><br><span class="line">	httpGetters <span class="keyword">map</span>[<span class="keyword">string</span>]*HTTPGetter <span class="comment">// 根据 baseURL 选择 HTTPGetter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set 方法</strong>用于添加节点，即在一致性哈希的哈希环中添加节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set 添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">Set</span><span class="params">(peers ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	p.peers = New(defaultReplicas, <span class="literal">nil</span>)</span><br><span class="line">	p.peers.Add(peers...)</span><br><span class="line">	p.httpGetters = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*HTTPGetter)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		p.httpGetters[peer] = &amp;HTTPGetter&#123;basePath: peer + p.basePath&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PickPeer 方法</strong>用于根据 key 选择节点，实现 PeerPicker 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickPeer 实现 PeerPicker 接口，用于根据 key 选择节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">PickPeer</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(PeerGetter, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> peer := p.peers.Get(key); peer != <span class="string">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;</span><br><span class="line">		p.Log(<span class="string">&quot;Pick peer %s&quot;</span>, peer)</span><br><span class="line">		<span class="keyword">return</span> p.httpGetters[peer], <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现主流程"><a href="#实现主流程" class="headerlink" title="实现主流程"></a>实现主流程</h1><p><code>dawncache.go</code></p>
<p>修改 Group 结构体，<strong>添加 PeerPicker</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name      <span class="keyword">string</span> <span class="comment">// 一个组的命名空间，用于区分不同的缓存，如学生姓名、成绩可以放到不同的缓存中去</span></span><br><span class="line">	getter    Getter <span class="comment">// 当查找数据未命中时，调用该函数获取值</span></span><br><span class="line">	mainCache cache  <span class="comment">// 底层缓存</span></span><br><span class="line">	peers     PeerPicker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个方法用于<strong>注册 PeerPicker</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterPeers 注册 PeerPicker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">RegisterPeers</span><span class="params">(peers PeerPicker)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// RegisterPeers 不允许调用超过1次</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	g.peers = peers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <strong>load 方法</strong>，使之：</p>
<ul>
<li>既能够从<strong>远程</strong>获取数据。</li>
<li>又能够在<strong>本地通过回调函数</strong>获取数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load 从别处加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// peers 不为空，可以从远程获取数据</span></span><br><span class="line">		<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class="line">			<span class="comment">// 从远程获取数据</span></span><br><span class="line">			view, err := g.getFromPeer(peer, key)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> view, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 本地通过回调函数获取数据</span></span><br><span class="line">	<span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getFromPeer 从 peer 处获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(peer PeerGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	data, err := peer.Get(g.name, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;b: data&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">415</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
