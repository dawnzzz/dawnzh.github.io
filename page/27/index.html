<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/27/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/27/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/25/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-5-%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/25/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-5-%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">从零实现一个Web框架 (5) 中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-25 11:21:19" itemprop="dateCreated datePublished" datetime="2022-05-25T11:21:19+08:00">2022-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--logger.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--trie.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>实现中间件的添加以及 Logger 中间件（用于记录请求处理时间和响应码）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Logger 中间件</span></span><br><span class="line">	e.Use(dain.Logger())</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello, you are %v, URL path = %v&quot;</span>, name, c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分组路由</span></span><br><span class="line">	v1 := e.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.Get(<span class="string">&quot;/video/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">			videoName := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;Hello, this is v1 group, video name = %v, path = %v&quot;</span>, videoName, c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><code> dain/context</code></p>
<p>在上下文 Context 中需要保存中间件信息，以及需要保存执行到第几个中间件了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// HTTP 请求 响应</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// 请求信息</span></span><br><span class="line">	Path   <span class="keyword">string</span>            <span class="comment">// 请求路径</span></span><br><span class="line">	Method <span class="keyword">string</span>            <span class="comment">// 请求方法</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 路由参数，如 /hello/:user 匹配 /hello/dawn，则 Params[&quot;user&quot;]=dawn</span></span><br><span class="line">	<span class="comment">// 响应信息</span></span><br><span class="line">	StatusCode <span class="keyword">int</span> <span class="comment">// 响应码</span></span><br><span class="line">	<span class="comment">// 中间件</span></span><br><span class="line">	handlers []HandlerFunc <span class="comment">// 存储中间件</span></span><br><span class="line">	index    <span class="keyword">int</span>           <span class="comment">// 执行的中间件下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Writer: w,</span><br><span class="line">		Req:    r,</span><br><span class="line">		Path:   r.URL.Path,</span><br><span class="line">		Method: r.Method,</span><br><span class="line">		index:  <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>c.Next</code> 方法可以执行下一个中间件，实现在执行下一个中间件之后再进行一些额外的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next 执行下一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.index++</span><br><span class="line">	<span class="keyword">for</span> ; c.index &lt; <span class="built_in">len</span>(c.handlers); c.index++ &#123;</span><br><span class="line">		c.handlers[c.index](c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将中间件应用到-Group"><a href="#将中间件应用到-Group" class="headerlink" title="将中间件应用到 Group"></a>将中间件应用到 Group</h2><p><code>dain/dain.go</code></p>
<p>定义 <strong>Use</strong> 函数，用于将中间件<strong>添加</strong>到 Group 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use 为分组添加中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Use</span><span class="params">(middlewares ...HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.middleware = <span class="built_in">append</span>(group.middleware, middlewares...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，需要重写 <strong>ServeHTTP</strong> 函数，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断，将对应的中间件加入到 context 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 http.Handler 接口，自定义路由器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	c := NewContext(w, r)</span><br><span class="line">	<span class="keyword">for</span> _, group := <span class="keyword">range</span> e.groups &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(r.URL.Path, group.prefix) &#123;</span><br><span class="line">			c.handlers = <span class="built_in">append</span>(c.handlers, group.middleware...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	e.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改-router"><a href="#修改-router" class="headerlink" title="修改 router"></a>修改 router</h2><p><code>dain/router.go</code></p>
<p>需要修改 <strong>router.handle</strong> 方法，将最后的请求处理逻辑 <strong>Handler 添加在中间件的最后</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle 实现路由功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在前缀树种查找路由，获取路由参数</span></span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 匹配路由</span></span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		c.Params = params</span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, r.handlers[key])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">			c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Logger-中间件"><a href="#Logger-中间件" class="headerlink" title="Logger 中间件"></a>Logger 中间件</h1><p><code>dain/logger.go</code></p>
<p>预定义一个 <strong>Logger</strong> 中间件，用于记录每一个请求的<strong>处理时间、响应码</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span> <span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 开始时间</span></span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		<span class="comment">// 向后处理请求</span></span><br><span class="line">		c.Next()</span><br><span class="line">		<span class="comment">// 处理结束，输出日志</span></span><br><span class="line">		log.Printf(<span class="string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(startTime))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/23/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-4-%E5%88%86%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/23/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-4-%E5%88%86%E7%BB%84/" class="post-title-link" itemprop="url">从零实现一个Web框架 (4) 分组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-23 16:05:08" itemprop="dateCreated datePublished" datetime="2022-05-23T16:05:08+08:00">2022-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--trie.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>可以对路由进行分组，每一组内的路由都可以有相似用途，也对分组定义中间件。</p>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分组路由</span></span><br><span class="line">	v1 := e.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.Get(<span class="string">&quot;/video/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">			videoName := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;Hello, this is v1 group, video name = %v, path = %v&quot;</span>, videoName, c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分组控制"><a href="#分组控制" class="headerlink" title="分组控制"></a>分组控制</h1><p><code>dain/dain.go</code></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>我们需要通过<strong>前缀</strong>来区分分组路由，同时还需要记录当前分组的<strong>上一层</strong>、应用于当前分组的<strong>中间件</strong>以及最顶层的 <strong>Engine</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouterGroup 分组路由</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix     <span class="keyword">string</span>        <span class="comment">// 当前分组的公共前缀</span></span><br><span class="line">	parent     *RouterGroup  <span class="comment">// 记录当前分组的上一层</span></span><br><span class="line">	middleware []HandlerFunc <span class="comment">// 记录中间件</span></span><br><span class="line">	engine     *Engine       <span class="comment">// 记录所属的 Engine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以<strong>将 Engine 作为最顶层的分组</strong>，也就是说 Engine 具有 RouterGroup 的所有能力：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 路由器</span></span><br><span class="line">	router *router</span><br><span class="line">	<span class="comment">// 继承 RouterGroup，把根也看作是一个分组</span></span><br><span class="line">	*RouterGroup</span><br><span class="line">	<span class="comment">// 记录所有的路由分组</span></span><br><span class="line">	groups []*RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个 Engine 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	engine := &amp;Engine&#123;router: NewRouter()&#125;</span><br><span class="line">	engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">	engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加分组"><a href="#添加分组" class="headerlink" title="添加分组"></a>添加分组</h2><p>通过 <strong>Group</strong> 函数可以添加分组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Group</span><span class="params">(prefix <span class="keyword">string</span>)</span> *<span class="title">RouterGroup</span></span> &#123;</span><br><span class="line">	engine := group.engine</span><br><span class="line">	newGroup := &amp;RouterGroup&#123;</span><br><span class="line">		prefix: group.prefix + prefix,</span><br><span class="line">		parent: group,</span><br><span class="line">		engine: engine,</span><br><span class="line">	&#125;</span><br><span class="line">	engine.groups = <span class="built_in">append</span>(engine.groups, newGroup) <span class="comment">// 在 Engine 中保存新的分组</span></span><br><span class="line">	<span class="keyword">return</span> newGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p>因为<strong>分组也可以注册路由</strong>，所以将 Engine 的路由注册方法更改为 RouterGroup 的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	pattern = group.prefix + pattern</span><br><span class="line">	group.engine.router.addRouter(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 路由注册 GET 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.addRouter(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 路由注册 POST 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.addRouter(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/22/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-3-%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/22/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-3-%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">从零实现一个Web框架 (3) 前缀树路由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-22 22:04:16" itemprop="dateCreated datePublished" datetime="2022-05-22T22:04:16+08:00">2022-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--trie.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>利用前缀树（Trie 树）实现动态路由解析，并且支持 <code>:name</code> 和    <code>*filename</code> 两种模式。</p>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello, you are %v, URL path = %v&quot;</span>, name, c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/file/*filename&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		filename := c.Param(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">		c.JSON(http.StatusOK, dain.H&#123;</span><br><span class="line">			<span class="string">&quot;filename&quot;</span>: filename,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h1><p><code>dain/trie.go</code></p>
<p>在之前的版本种，使用了 map 来存储路由与处理函数的映射，但是这不能支持动态路由。</p>
<p>Trie 树（前缀树）可以实现动态路由，一个节点的所有子节点都有相同的前缀。</p>
<p><code>/:user/info</code>、<code>/:user/doc</code>、<code>/p/video</code>、<code>/p/book</code>、<code>/file/*filepath</code> 对应的前缀树如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                      /</span><br><span class="line">       _______________|______________</span><br><span class="line">      |               |              |</span><br><span class="line">    :user             p            file</span><br><span class="line">   ___|___         ___|___           |</span><br><span class="line">  |       |       |       |          |</span><br><span class="line">info     doc    video    book    *filepath		</span><br></pre></td></tr></table></figure>

<h2 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h2><p>首先需要知道前缀树的节点的结构。</p>
<p>其中，<code>matchChild</code> 匹配第一个节点，用于将剩余路由信息插入到匹配的节点之下。<code>matchChildren</code> 用于匹配所有的节点，用于查找请求的路径信息是否匹配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern  <span class="keyword">string</span>  <span class="comment">// 待匹配的路由，只在pattern定义的最后一个节点存储</span></span><br><span class="line">	part     <span class="keyword">string</span>  <span class="comment">// 路由中的一部分</span></span><br><span class="line">	children []*node <span class="comment">// 叶子节点</span></span><br><span class="line">	isWild   <span class="keyword">bool</span>    <span class="comment">// 若不是精确匹配则为 true；否则为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchChild 匹配第一个节点，用于插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChild</span><span class="params">(part <span class="keyword">string</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			<span class="keyword">return</span> child</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchChildren 匹配所有的节点，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChildren</span><span class="params">(part <span class="keyword">string</span>)</span> []*<span class="title">node</span></span> &#123;</span><br><span class="line">	children := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			children = <span class="built_in">append</span>(children, child)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入和搜索"><a href="#插入和搜索" class="headerlink" title="插入和搜索"></a>插入和搜索</h2><p>在<strong>添加路由</strong>时，需要在前缀树中<strong>插入</strong>节点。</p>
<p>在<strong>匹配路由</strong>时，需要<strong>查找</strong>当前请求的路径是否能匹配到节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insert</span><span class="params">(pattern <span class="keyword">string</span>, parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">		<span class="comment">// 到达叶子节点</span></span><br><span class="line">		<span class="comment">// 仅仅在pattern定义的最后一个节点存储</span></span><br><span class="line">		n.pattern = pattern</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	child := n.matchChild(part)</span><br><span class="line">	<span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 若当前层没有匹配，新建一个节点，并插入到孩子节点中</span></span><br><span class="line">		child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">		n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向下一层继续插入</span></span><br><span class="line">	child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search 查找节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">search</span><span class="params">(parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">// 到达叶子节点 或者 匹配到“*”</span></span><br><span class="line">		<span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">		<span class="comment">// 在下一层中继续查找</span></span><br><span class="line">		result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到节点</span></span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器 Router"></a>路由器 Router</h1><p><code>dain/router.go</code></p>
<h2 id="router-结构"><a href="#router-结构" class="headerlink" title="router 结构"></a>router 结构</h2><p>在 router 中记录前缀树的<strong>根节点 roots</strong>，用于记录和匹配路由；<strong>handlers</strong> 用于记录 pattern 和 HandlerFunc 的映射关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	roots    <span class="keyword">map</span>[<span class="keyword">string</span>]*node       <span class="comment">// 保存 trie 树的根，key为 Method，value为树根</span></span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc <span class="comment">// 保存 pattern 与 HandlerFunc 的映射关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*node),</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><p>因为增加了前缀树用来保存路由 pattern，所以需要在<strong>添加路由</strong>的同时在前缀树中<strong>插入</strong>节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parsePattern 解析 pattern，返回对应的 parts（路由中的一部分）</span></span><br><span class="line"><span class="comment">// 如 pattern 为 /hello/world，那么对应的 parts 为 []&#123;&quot;hello&quot;, &quot;world&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	parts := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(vs))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="comment">// 不为空，加入到 parts 中</span></span><br><span class="line">			parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line">			<span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="comment">// 遇到通配符直接退出</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Router %v - %v\n&quot;</span>, method, pattern)</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line"></span><br><span class="line">	_, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parts := parsePattern(pattern)</span><br><span class="line">	r.roots[method].insert(pattern, parts, <span class="number">0</span>) <span class="comment">// 插入到前缀树中</span></span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>添加一个函数 <strong>getRouter</strong> 用于查找对应的叶子节点和路由参数，并且重新实现 <strong>handle</strong> 路由功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getRoute 根据请求的 method 和 path，找到对应的前缀树叶子节点和路由参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">getRoute</span><span class="params">(method, path <span class="keyword">string</span>)</span> <span class="params">(*node, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	searchParts := parsePattern(path) <span class="comment">// 查找的 parts</span></span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	root, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 方法没有定义路由，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := root.search(searchParts, <span class="number">0</span>) <span class="comment">// 查找叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 可以找到</span></span><br><span class="line">		parts := parsePattern(n.pattern)</span><br><span class="line">		<span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> n, params</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle 实现路由功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在前缀树种查找路由，获取路由参数</span></span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 匹配路由</span></span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		c.Params = params</span><br><span class="line">		r.handlers[key](c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(c.Writer, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><code>dain/context.go</code></p>
<h2 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h2><p>为了访问到路由参数，所以需要修改 Context 结构体，向其中添加 <strong>Params</strong>，用来记录路由参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// HTTP 请求 响应</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// 请求信息</span></span><br><span class="line">	Path   <span class="keyword">string</span>            <span class="comment">// 请求路径</span></span><br><span class="line">	Method <span class="keyword">string</span>            <span class="comment">// 请求方法</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 路由参数，如 /hello/:user 匹配 /hello/dawn，则 Params[&quot;user&quot;]=dawn</span></span><br><span class="line">	<span class="comment">// 响应信息</span></span><br><span class="line">	StatusCode <span class="keyword">int</span> <span class="comment">// 响应码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取路由参数"><a href="#获取路由参数" class="headerlink" title="获取路由参数"></a>获取路由参数</h2><p>增加可以用过键值获取相应路由参数的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Param 获取路由参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Param</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	value, _ := c.Params[key]</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/21/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-2-%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-2-%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">从零实现一个Web框架 (2) 上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-21 21:45:27" itemprop="dateCreated datePublished" datetime="2022-05-21T21:45:27+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--context.go</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--router.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>最终实现得效果如下，此时更加接近于 GIN：</p>
<ul>
<li>Handler 得参数变为 <strong>dain.Context</strong>，同时提供了对表单和 URL 的查询 <code>PostForm/Query</code></li>
<li>dain.Context 同 GIN 一样，封装了 <code>HTML/String/JSON/Data</code> 函数，快速构建 HTTP 响应。</li>
</ul>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Dawn&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello World, URL path = %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Post(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *dain.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, dain.H&#123;</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">			<span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建上下文"><a href="#构建上下文" class="headerlink" title="构建上下文"></a>构建上下文</h1><p><code>dain/context.go</code></p>
<p>上下文 Context 即一个请求的上下文，它随着每一个请求的出现而产生，响应的结束而销毁。</p>
<h2 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h2><p>Context 可以对一些代码进行封装，使用起来更加简便。首先看 Context 的结构：</p>
<ul>
<li>dain.H 同 gin.H 的作用一样，是 <code>map[string]interface&#123;&#125;</code> 的简便写法。</li>
<li>在 Context 中，保存了一次HTTP的请求 <code>Req</code> 和响应 <code>Writer</code>，同时保存了一些请求和响应信息。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// HTTP 请求 响应</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// 请求信息</span></span><br><span class="line">	Path   <span class="keyword">string</span> <span class="comment">// 请求路径</span></span><br><span class="line">	Method <span class="keyword">string</span> <span class="comment">// 请求方法</span></span><br><span class="line">	<span class="comment">// 响应信息</span></span><br><span class="line">	StatusCode <span class="keyword">int</span> <span class="comment">// 响应码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Writer: w,</span><br><span class="line">		Req:    r,</span><br><span class="line">		Path:   r.URL.Path,</span><br><span class="line">		Method: r.Method,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h2><p>封装关于<strong>获取请求数据</strong>的函数 <code>PostForm/Query</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostForm 根据 key 获取第一个表单数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">PostForm</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query 根据 key 获取请求的 query 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Query</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改变-HTTP-响应头"><a href="#改变-HTTP-响应头" class="headerlink" title="改变 HTTP 响应头"></a>改变 HTTP 响应头</h2><p>封装<strong>改变 HTTP 响应</strong>的函数 <code>Status/SetHeader</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status 设置响应状态码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Status</span><span class="params">(code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c.StatusCode = code</span><br><span class="line">	c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetHeader 设置响应头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetHeader</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速响应"><a href="#快速响应" class="headerlink" title="快速响应"></a>快速响应</h2><p>封装<strong>快速响应</strong>的函数 <code>String/JSON/Data/HTML</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">String</span><span class="params">(code <span class="keyword">int</span>, format <span class="keyword">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write([]<span class="keyword">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	encoder := json.NewEncoder(c.Writer)</span><br><span class="line">	<span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Data</span><span class="params">(code <span class="keyword">int</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write(data)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">HTML</span><span class="params">(code <span class="keyword">int</span>, html <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	_, err := c.Writer.Write([]<span class="keyword">byte</span>(html))</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p><code>dain/router.go</code></p>
<h2 id="router-结构"><a href="#router-结构" class="headerlink" title="router 结构"></a>router 结构</h2><p>于此同时，将路由器从 <code>dain/dain.go</code> 中分离出来。路由器的结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>需要稍微更改路由注册和路由功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Router %v - %v\n&quot;</span>, method, pattern)</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle 实现路由功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	key := c.Method + <span class="string">&quot;-&quot;</span> + c.Path</span><br><span class="line">	<span class="keyword">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class="line">		handler(c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(c.Writer, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, c.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h1><p><code>dain/dain.go</code></p>
<p>与此同时，也要更改框架入口。</p>
<p>首先需要将 <strong>HandlerFunc</strong> 的参数改变为 Context：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc handler 函数类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span></span><br></pre></td></tr></table></figure>

<p>改变 Engine 的内部结构，使之内嵌 <strong>router 结构体</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 路由器</span></span><br><span class="line">	router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个 Engine 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;</span><br><span class="line">		router: NewRouter(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改<strong>路由注册</strong>的内部逻辑为，调用 router 的路由注册：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">addRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.router.addRouter(method, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，需要<strong>更改 http.Handler 接口函数 ServeHTTP</strong> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 http.Handler 接口，自定义路由器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	c := NewContext(w, r)</span><br><span class="line">	e.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/20/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-1-%E5%8E%9F%E5%9E%8B%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/20/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb%E6%A1%86%E6%9E%B6-1-%E5%8E%9F%E5%9E%8B%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">从零实现一个Web框架 (1) 原型框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-20 22:18:23" itemprop="dateCreated datePublished" datetime="2022-05-20T22:18:23+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">从零实现系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本系列参考于 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee.html">极客兔兔-7天用Go从零实现Web框架Gee教程</a>，将从零开始实现一个简易的仿 GIN 的框架，称为 Dawn’s Gin 简称 <strong>dain</strong>。</p>
<p>在本节，最终的代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dain/</span><br><span class="line">	|--dain.go</span><br><span class="line">	|--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure>

<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>我们最终的实现效果如下，可以看到自实现的框架与 GIN 十分相似：</p>
<ul>
<li>通过 <code>e.GET</code> 和 <code>e.POST</code> 注册路由</li>
<li>最后调用 <code>e.RUN</code> 运行 Web 服务器。</li>
</ul>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;DawnGin/dain&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := dain.New()</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello World, URL path = %v&quot;</span>, r.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Post(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">			fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	e.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p><code>dain/dain.go</code></p>
<p>在 GIN 中，添加路由等的操作都是通过引擎 Engine 完成的，所以自定义 Engine。</p>
<p>其中 <strong>Engine.router</strong> 是一个<strong>路由器</strong>，类型为 map。key 记录路由注册时的 pattern，value 则为相应的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc handler 函数类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 路由器</span></span><br><span class="line">	router <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个 Engine 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;</span><br><span class="line">		router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态路由注册"><a href="#静态路由注册" class="headerlink" title="静态路由注册"></a>静态路由注册</h2><p>我们需要实现通过 POST 和 GET 注册静态路由，首先编写同一的路由注册入口，将路由注册到 Engine.router 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddRouter 实现路由注册功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">AddRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	e.router[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加对外暴露的与 HTTP Method 相关的路由注册方法，共实现了 GET 和 POST 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 路由注册 GET 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.AddRouter(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 路由注册 POST 请求方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	e.AddRouter(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-http-Handler-接口"><a href="#实现-http-Handler-接口" class="headerlink" title="实现 http.Handler 接口"></a>实现 http.Handler 接口</h2><p>需要使得自定义的路由器工作，首先需要实现 <strong>http.Handler</strong> 接口，接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只需要实现 <strong>ServeHTTP</strong> 方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 http.Handler 接口，自定义路由器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	key := r.Method + <span class="string">&quot;-&quot;</span> + r.URL.Path</span><br><span class="line">	<span class="keyword">if</span> handler, ok := e.router[key]; ok &#123;</span><br><span class="line">		handler(w, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND FOR PATH: %v&quot;</span>, r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，包装一层执行函数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run 运行服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span> <span class="title">Run</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/20/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/20/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (8) 日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-20 12:49:08" itemprop="dateCreated datePublished" datetime="2022-05-20T12:49:08+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go 语言中可以使用第三方日志系统：<strong>logrus 和 seelog</strong>，它们实现了很强大的日志功能。</p>
<h1 id="logrus"><a href="#logrus" class="headerlink" title="logrus"></a>logrus</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>logrus 是用 Go 语言实现的一个日志系统，安装 logrus：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/sirupsen/logrus</span><br></pre></td></tr></table></figure>

<p>六个<strong>日志等级</strong>（从低到高）：</p>
<ul>
<li>Debug</li>
<li>Info</li>
<li>Warn</li>
<li>Error</li>
<li>Fatal，随后触发 <code>os.Exit(1)</code></li>
<li>Panic，随后触发 <code>panic()</code></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="设置-logrus-参数"><a href="#设置-logrus-参数" class="headerlink" title="设置 logrus 参数"></a>设置 logrus 参数</h3><p>可以设置 logrus 的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 日志格式化为 JSON，而不是默认的 ASCII</span></span><br><span class="line">	logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出 stdout 而不是默认的 stderr，也可以是一个文件</span></span><br><span class="line">	logrus.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只记录 Warn 以及以上的错误等级</span></span><br><span class="line">	logrus.SetLevel(logrus.WarnLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Feilds"><a href="#Feilds" class="headerlink" title="Feilds"></a>Feilds</h3><p>可以添加 Fields 来自定义输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span>:  <span class="number">23</span>,</span><br><span class="line">&#125;).Warn(<span class="string">&quot;This is a warn level log.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// &#123;&quot;age&quot;:23,&quot;level&quot;:&quot;warning&quot;,&quot;msg&quot;:&quot;This is a warn level log.&quot;,&quot;name&quot;:&quot;zh&quot;,&quot;time&quot;:&quot;2022-05-20T13:11:48+08:00&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>有时候我们需要固定的 Fields，只需要生成一个 <strong>log.Entry</strong> 就可以<strong>复用 Fields</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 log.Entry 复用 Feilds</span></span><br><span class="line">contextLogger := logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">	<span class="string">&quot;common&quot;</span>: <span class="string">&quot;this is a common field&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">contextLogger.Info(<span class="string">&quot;I&#x27;ll be logged with common and other field&quot;</span>)</span><br><span class="line">contextLogger.Info(<span class="string">&quot;Me too&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>如果想在一个应用里面向多个地方记录日志，可以创建 <strong>Logger</strong>实例，Logger 结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Out io.Writer</span><br><span class="line">    Hooks LevelHooks</span><br><span class="line">    Formatter Formatter</span><br><span class="line">    <span class="comment">//最小级别</span></span><br><span class="line">    Level Level</span><br><span class="line">    <span class="comment">//被用来同步写入，比如两个地方同时log.默认是被锁住的</span></span><br><span class="line">    mu MutexWrap</span><br><span class="line">    <span class="comment">// Reusable empty entry</span></span><br><span class="line">    entryPool sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以创建很多instance</span></span><br><span class="line"><span class="keyword">var</span> log = logrus.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;logrus.log&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Out = file</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Info(<span class="string">&quot;Failed to log to file, using default stderr&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  log.WithFields(logrus.Fields&#123;</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;123.txt&quot;</span>,</span><br><span class="line">  &#125;).Info(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="seelog"><a href="#seelog" class="headerlink" title="seelog"></a>seelog</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>seelog 主要有以下特性：</p>
<ul>
<li>XML 的<strong>动态配置</strong>，支持动态改变配置而不需要重新启动应用。</li>
<li>支持<strong>多输出流</strong>，能够同时把日志输出到多种流中、例如文件流、网络流等。</li>
<li>日志级别：trace、debug、info、warn、error、critical、off</li>
</ul>
<p>安装 seelog：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/cihub/seelog</span><br></pre></td></tr></table></figure>

<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    log <span class="string">&quot;github.com/cihub/seelog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> log.Flush()</span><br><span class="line">    log.Info(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>seelog 的配置文件通过 XML 进行配置，其说明如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1. type: 日志输出类型，有4中类型，分别是：sync，asyncloop(default)，asynctimer，adaptive</span></span><br><span class="line"><span class="comment">   type=“sync”：在同一个go中处理日志消息，仅当调用日志函数时才被执行。</span></span><br><span class="line"><span class="comment">   type=“asyncloop”：在单独的go中独自处理日志消息，循环从日志队列中读取日志并消费(输出到控制台或者文件)。</span></span><br><span class="line"><span class="comment">   type=&quot;asynctimer&quot;：在单独的go中独自处理日志消息，在指定时间间隔去读取日志队列消息，所以该类型还需要配置一个间隔时间(纳秒)。</span></span><br><span class="line"><span class="comment">   type=&quot;adaptive&quot;：在单独的go中独自处理日志消息，但是不是固定的每隔指定时间去读取日志消息，间隔时间与队列剩余的日志量有关，如果剩余日志量多，则间隔时间短，反之亦然</span></span><br><span class="line"><span class="comment">2. minlevel: 全局最低输出日志级别</span></span><br><span class="line"><span class="comment">3. maxlevel: 全局最高输出日志级别</span></span><br><span class="line"><span class="comment">4. exceptions: 日志的特殊处理情况，可根据指定文件或者函数进行日志输出</span></span><br><span class="line"><span class="comment">5. formatid: 输出格式标签，可以在formats中找到对应的标签</span></span><br><span class="line"><span class="comment">6. console: 将日志输出到控制台</span></span><br><span class="line"><span class="comment">7. splitter: 用于细分outputs日志格式，支持: file(文件), rollingfile(滚动文件), buffered(缓存到内存再输出到文件), smtp(发送日志邮件), con(网络转发)</span></span><br><span class="line"><span class="comment">8. rollingfile: 滚动文件，可基于日期(type=&quot;date&quot;)或者文件大小(type=&quot;size&quot;)进行日志切割，maxsize: 单个日志文件最大size，如果设置为100M，则maxsize=100*1024*1024，maxrolls: 最大文件数量，超出的日志文件数量会被滚动删除</span></span><br><span class="line"><span class="comment">9. buffered: 将日志先存在内存中，定期写入文件，适合日志并发量较大或 IO 比较紧张的场合，size:缓存大小, flushperiod:缓存时间</span></span><br><span class="line"><span class="comment">10. filter: 单独处理某级别的日志</span></span><br><span class="line"><span class="comment">11. formats: 日志输出格式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p>seelog 支持自定义日志处理，可以通过配置文件进行配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    seelog <span class="string">&quot;github.com/cihub/seelog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Logger seelog.LoggerInterface</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadAppConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    appConfig := <span class="string">`</span></span><br><span class="line"><span class="string">&lt;seelog minlevel=&quot;warn&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;outputs formatid=&quot;common&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rollingfile type=&quot;size&quot; filename=&quot;/data/logs/roll.log&quot; maxsize=&quot;100000&quot; maxrolls=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;filter levels=&quot;critical&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;file path=&quot;/data/logs/critical.log&quot; formatid=&quot;critical&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;smtp formatid=&quot;criticalemail&quot; senderaddress=&quot;astaxie@gmail.com&quot; sendername=&quot;ShortUrl API&quot; hostname=&quot;smtp.gmail.com&quot; hostport=&quot;587&quot; username=&quot;mailusername&quot; password=&quot;mailpassword&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;recipient address=&quot;xiemengjun@gmail.com&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;/smtp&gt;</span></span><br><span class="line"><span class="string">        &lt;/filter&gt;</span></span><br><span class="line"><span class="string">    &lt;/outputs&gt;</span></span><br><span class="line"><span class="string">    &lt;formats&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;common&quot; format=&quot;%Date/%Time [%LEV] %Msg%n&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;critical&quot; format=&quot;%File %FullPath %Func %Msg%n&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;format id=&quot;criticalemail&quot; format=&quot;Critical error on our server!\n    %Time %Date %RelFile %Func %Msg \nSent by Seelog&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/formats&gt;</span></span><br><span class="line"><span class="string">&lt;/seelog&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    logger, err := seelog.LoggerFromConfigAsBytes([]<span class="keyword">byte</span>(appConfig))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    UseLogger(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DisableLog()</span><br><span class="line">    loadAppConfig()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DisableLog disables all library log output</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DisableLog</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Logger = seelog.Disabled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseLogger uses a specified seelog.LoggerInterface to output library log.</span></span><br><span class="line"><span class="comment">// Use this func if you are using Seelog logging system in your app.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseLogger</span><span class="params">(newLogger seelog.LoggerInterface)</span></span> &#123;</span><br><span class="line">    Logger = newLogger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实现了三个函数：</p>
<ul>
<li><code>DisableLog</code> 函数：初始化全局变量 Logger 为 seelog 的禁用状态，主要为了<strong>防止 Logger 被多次初始化</strong>。</li>
<li><code>loadAppConfig</code> 函数：根据配置文件初始化 seelog 的配置信息，配置文件说明如下：<ul>
<li>seelog：minlevel 参数可选，如果被配置，高于或等于此级别的日志会被记录，同理 maxlevel。</li>
<li>outputs：输出信息的目的地，这里分成了两份数据，一份记录到 log rotate 文件里面。另一份设置了 filter，如果这个错误级别是 critical，那么将发送报警邮件。</li>
<li>formats：定义了日志的格式。</li>
</ul>
</li>
<li><code>UseLogger</code> 函数：设置当前的日志器为相应的日志处理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/19/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (7) 错误处理和测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 20:58:01" itemprop="dateCreated datePublished" datetime="2022-05-19T20:58:01+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在 Go 语言中，定义了 <strong>error 类型</strong>，来显示的表达错误，错误作为函数的返回值进行返回。</p>
<h2 id="Error-类型"><a href="#Error-类型" class="headerlink" title="Error 类型"></a>Error 类型</h2><p><strong>error 类型</strong>是一个接口类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <strong>errors.New</strong> 把一个字符串转化为 errorString，以得到一个 error 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-Error"><a href="#自定义-Error" class="headerlink" title="自定义 Error"></a>自定义 Error</h2><p>error 因为是一个接口，所以可以通过实现 error 接口，自定义错误类型。如 <strong>json.SyntaxError</strong> 类型，除了错误描述外，还定义了错误发生的位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="keyword">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="keyword">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p>再如 <strong>net.Error</strong> 类型，定义了更复杂的错误处理，判断是否超时、或者临时性错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    error</span><br><span class="line">    Timeout() <span class="keyword">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="keyword">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<strong>类型断言</strong>，获取自定义的错误类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serr, ok := err.(*json.SyntaxError)</span><br><span class="line"></span><br><span class="line">nerr, ok := err.(net.Error)</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Go 语言中，将<strong>异常与错误区分</strong>开来：</p>
<ul>
<li>错误指可以预期的错误，这时可以将错误当作函数返回值返回。</li>
<li>异常指无法预期、无法继续执行的严重程序错误，如数组地址越界。</li>
</ul>
<h2 id="异常恢复机制"><a href="#异常恢复机制" class="headerlink" title="异常恢复机制"></a>异常恢复机制</h2><p>Go 语言中可以使用 <code>recover</code> 机制来恢复异常：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发生了异常</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>测试文件必须遵循如下原则：</p>
<ul>
<li>文件名必须是 <code>_test.go</code> 结尾的。</li>
<li>必须 <code>import testing</code>。</li>
<li>所有的测试函数的格式为 <code>func TestXxx (t *testing.T)</code>。</li>
<li>通过调用 <code>testing.T</code> 的 <code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code> 方法，说明测试不通过，调用 <code>Log</code> 方法用来记录测试的信息。</li>
</ul>
<p>如编写 go 文件 <code>gotest.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;被除数不为0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写相应的测试文件 <code>gotest_test.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivide_1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i, e := Divide(<span class="number">6</span>, <span class="number">2</span>); i != <span class="number">3</span> || e != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;除法函数测试没通过&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(<span class="string">&quot;第一个测试通过&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivide_2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, e := Divide(<span class="number">6</span>, <span class="number">0</span>); e == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;除数为0测试未通过&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(<span class="string">&quot;第二个测试通过&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试文件可以得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestDivide_1</span><br><span class="line">    gotest_test.go:9: 第一个测试通过</span><br><span class="line">--- PASS: TestDivide_1 (0.00s)</span><br><span class="line">=== RUN   TestDivide_2</span><br><span class="line">    gotest_test.go:16: 第二个测试通过</span><br><span class="line">--- PASS: TestDivide_2 (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>

<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>压力测试用来测试函数的性能，需要注意：</p>
<ul>
<li>压力测试函数的格式为 <code> func BenchmarkXXX(b *testing.B)</code>。</li>
<li><code>go test</code> 不会默认执行压力测试的函数，如果要执行压力测试需要带上参数 <code>-test.bench</code>，语法: <code>-test.bench=&quot;test_name_regex&quot;</code>。</li>
</ul>
<p>对上述编写的除法函数进行压力测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDivide</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.StopTimer() <span class="comment">// 调用该函数停止压力测试的时间计数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做一些初始化的工作,例如读取文件数据,数据库连接之类的,</span></span><br><span class="line">	<span class="comment">// 这样这些时间不影响我们测试函数本身的性能</span></span><br><span class="line"></span><br><span class="line">	b.StartTimer() <span class="comment">// 重新开始时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Divide(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过调用 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code> 暂停和开始时间计数。执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-web-demo/ch11/gotest</span><br><span class="line">cpu: Intel(R) Pentium(R) CPU G4560 @ 3.50GHz</span><br><span class="line">BenchmarkDivide</span><br><span class="line">BenchmarkDivide-4       1000000000               0.4220 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/18/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (6) 安全和加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-18 09:52:22" itemprop="dateCreated datePublished" datetime="2022-05-18T09:52:22+08:00">2022-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h2><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，可以伪装为受害者的身份，向服务器发送各种请求。原理如下：</p>
<ul>
<li><strong>受害者登录受信任网站 A，并在本地生成 Cookie</strong>。</li>
<li><strong>在不退出 A 的情况下，访问危险网站 B</strong>。此时访问 B 时会发送请求给受信任网站 A 并且会附上 Cookie 信息。</li>
</ul>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/9.1.csrf.png" alt="img"></p>
<h2 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h2><p>在服务器端防御 CSRF，主要有两个方面：</p>
<ul>
<li>正确使用 GET、POST 请求。</li>
<li>在非 GET 请求中增验证。</li>
</ul>
<h3 id="正确使用-GET-POST-请求"><a href="#正确使用-GET-POST-请求" class="headerlink" title="正确使用 GET POST 请求"></a>正确使用 GET POST 请求</h3><p>使用 <strong>REST 方式</strong>可以限制请求的类型：</p>
<ul>
<li><p>GET 常用在查看，列举，展示等不需要改变资源属性的时候。</p>
</li>
<li><p>POST 常用在改变一个资源的属性或者状态。</p>
</li>
</ul>
<h3 id="增加验证"><a href="#增加验证" class="headerlink" title="增加验证"></a>增加验证</h3><p>在非 GET 请求中增加验证，可以有三个思路：</p>
<ul>
<li><p>为每个用户生成一个<strong>唯一的 token</strong>，所有表单都包含同一个伪随机值。这种方法最简单，因为攻击者（理论上）不能获取到第三方的 Cookie，所以表单中的数据也就构造失败，但是 XSS 可以窃取到第三方 Cookie，所以这个方案在没有 XSS 时是安全的。</p>
</li>
<li><p>为每一个请求使用<strong>验证码</strong>，用户体验很差。</p>
</li>
<li><p>每个用户生成的 <strong>token 随时更新</strong>，实现如下：</p>
<ul>
<li>生成随机 token：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h := md5.New()</span><br><span class="line">io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">io.WriteString(h, <span class="string">&quot;salt&quot;</span>)</span><br><span class="line">token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">t, _ := template.ParseFiles(<span class="string">&quot;xxx.gtpl&quot;</span>)</span><br><span class="line">t.Execute(w, token)</span><br></pre></td></tr></table></figure>

<ul>
<li>表单中的 token：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>验证 token：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r.ParseForm()</span><br><span class="line">token := r.Form.Get(<span class="string">&quot;token&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> token != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 验证 token 的合法性</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不存在 token 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>XSS（Cross-Site Scripting）<strong>跨站脚本攻击</strong>，原理是一段恶意的 JavaScript 代码在用户客户端上被执行，导致信息泄露（ Cookie 泄露）。XSS 主要用于攻击用户端的。</p>
<p>主要分为两类：</p>
<ul>
<li><strong>存储型 XSS</strong>：恶意 XSS 代码被服务器存储到了服务器中，应用程序从数据库中查询出来并在客户端中显示，造成 XSS 攻击。</li>
<li><strong>反射型 XSS</strong>：将恶意 XSS 代码加入到 URL 的请求参数中，请求参数在页面上直接输出。</li>
</ul>
<h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><p>XSS防御可以有如下方式：</p>
<ul>
<li><strong>过滤特殊字符</strong>：text/template 包下面的 <strong>HTMLEscapeString、JSEscapeString</strong> 等函数可以对敏感字符进行转义。</li>
<li><strong>输入内容长度控制</strong>：对于不受信任的输入，都应该限定一个合理的长度，这样可以增加攻击难度。</li>
<li><strong>HTTP-Only</strong>：禁止从客户端脚本中读取 Cookie 信息，使得攻击者无法窃取 Cookie。</li>
<li>等一系列防御手段。。。</li>
</ul>
<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><h2 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h2><p>SQL 注入的原理就是因为用户输入的数据被当作 SQL 语句执行。</p>
<h2 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h2><p>SQL 注入可以有如下防御方式：</p>
<ul>
<li><p>限制 Web 应用数据库的操作权限，给予用户最低的操作权限。</p>
</li>
<li><p>检查输入的数据，对进入数据库的字符进行转义、过滤。html/template 包的 HTMLEscapeString 函数可以对字符串进行转义处理。</p>
</li>
<li><p>所有的查询语句建议使用数据库提供的参数化查询接口，避免直接拼接 SQL 语句。</p>
</li>
</ul>
<h1 id="存储密码"><a href="#存储密码" class="headerlink" title="存储密码"></a>存储密码</h1><h2 id="普通方案：哈希"><a href="#普通方案：哈希" class="headerlink" title="普通方案：哈希"></a>普通方案：哈希</h2><p>目前利用最多的方案就是对明文密码进行哈希之后，进行存储。常用的单向哈希算法包括 <strong>SHA-256, SHA-1, MD5</strong> 等。</p>
<p><strong>缺点：</strong>考虑到多数人所使用的密码为常见的组合，攻击者可以将所有密码的常见组合进行单向哈希，得到一个摘要组合（<strong>彩虹表</strong>），然后与数据库中的摘要进行比对即可获得对应的密码。</p>
<h2 id="进阶方案：哈希-盐"><a href="#进阶方案：哈希-盐" class="headerlink" title="进阶方案：哈希+盐"></a>进阶方案：哈希+盐</h2><p>可以采用加盐的方式来存储密码，常用的方式：</p>
<ul>
<li>对用户的明文密码进行一次<strong>哈希运算</strong>。</li>
<li>将得到的摘要<strong>加上随机串（盐）</strong>，这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>再进行一次<strong>哈希运算</strong>后，放入数据库中存储起来。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户名 abc，密码 123456</span></span><br><span class="line">h := md5.New()</span><br><span class="line">io.WriteString(h, <span class="string">&quot;需要加密的密码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pwmd5 等于 e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line">pwmd5 :=fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定两个 salt： salt1 = @#$%   salt2 = ^&amp;*()</span></span><br><span class="line">salt1 := <span class="string">&quot;@#$%&quot;</span></span><br><span class="line">salt2 := <span class="string">&quot;^&amp;*()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// salt1 + 用户名 + salt2 + MD5 拼接</span></span><br><span class="line">io.WriteString(h, salt1)</span><br><span class="line">io.WriteString(h, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">io.WriteString(h, salt2)</span><br><span class="line">io.WriteString(h, pwmd5)</span><br><span class="line"></span><br><span class="line">last :=fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<h2 id="专家方案：Scrypt"><a href="#专家方案：Scrypt" class="headerlink" title="专家方案：Scrypt"></a>专家方案：Scrypt</h2><p>故意增加密码计算所需耗费的资源和时间，使得任何人都不可获得足够的资源建立所需的 <code>rainbow table</code>。</p>
<p><strong>Scrypt 算法</strong>使得并行计算多个摘要异常困难，因此利用rainbow table（彩虹表）进行暴力攻击的难度增加。</p>
<p>在 Go 的 golang.org/x/crypto/scrypt 包中支持 scrypt：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/crypto/scrypt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// DO NOT use this salt value; generate your own random salt. 8 bytes is</span></span><br><span class="line">	<span class="comment">// a good length.</span></span><br><span class="line">	salt := []<span class="keyword">byte</span>&#123;<span class="number">0xc8</span>, <span class="number">0x28</span>, <span class="number">0xf2</span>, <span class="number">0x58</span>, <span class="number">0xa7</span>, <span class="number">0x6a</span>, <span class="number">0xad</span>, <span class="number">0x7b</span>&#125;</span><br><span class="line"></span><br><span class="line">	dk, err := scrypt.Key([]<span class="keyword">byte</span>(<span class="string">&quot;some password&quot;</span>), salt, <span class="number">1</span>&lt;&lt;<span class="number">15</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(base64.StdEncoding.EncodeToString(dk))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="加密和解密数据"><a href="#加密和解密数据" class="headerlink" title="加密和解密数据"></a>加密和解密数据</h1><p>Go 语言中 crypto 及其子包提供了多种加密算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/17/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (5) Web服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 20:41:56" itemprop="dateCreated datePublished" datetime="2022-05-17T20:41:56+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h1><p>常用的 Socket 有两种类型：</p>
<ul>
<li><p><strong>流式 Socket（SOCK_STREAM）</strong>：一种<strong>面向连接</strong>的 Socket，针对于面向连接的 <strong>TCP</strong> 服务应用。</p>
</li>
<li><p><strong>数据包式 Socket （SOCK_DGRAM）</strong>：<strong>无连接</strong>的 Socket，对应于无连接的 <strong>UDP</strong> 服务应用。</p>
</li>
</ul>
<p>对于在网络上的应用程序来说，<strong>（协议类型，IP 地址，端口号）</strong>这个三元组可以唯一确定一个进程。</p>
<p>在 Go 的 net 包中，定义了 IP 地址类型，net 包的函数都可以接收 <strong>IPv4 和 IPv6</strong> 的 IP 地址作为输入。其中 <code>ParseIP(s string) IP</code> 函数会把一个 IPv4 或者 IPv6 的地址转化成 IP 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIP</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">IP</span></span></span><br></pre></td></tr></table></figure>

<h2 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h2><p>在 net 包中，有一个类型为 TCPConn，它用来作为客户端和服务器端交互的通道，主要有两个函数，分别可以读写数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>另外，还有一个 TCPAddr 类型，用于表示 TCP 的地址信息，通过 <code>ResolveTCPAddr</code> 函数可以获取一个 TCPAddr：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPAddr <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP IP</span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Zone <span class="keyword">string</span> <span class="comment">// IPv6 scoped addressing zone</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResolveTCPAddr</span><span class="params">(net, addr <span class="keyword">string</span>)</span> <span class="params">(*TCPAddr, os.Error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>net 参数<strong>是 “tcp4”、”tcp6”或”tcp” 中的任意一个</strong>，分别表示 TCP (IPv4-only), TCP (IPv6-only) 或者 TCP (IPv4, IPv6 的任意一个)。</li>
<li>addr 表示<strong>域名或者 IP 地址</strong>。</li>
</ul>
<h3 id="TCP-client"><a href="#TCP-client" class="headerlink" title="TCP client"></a>TCP client</h3><p>客户端通过 net 包中的 <code>DialTCP</code> 函数来建立一个 TCP 连接，并返回一个 <code>TCPConn</code> 类型的对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTCP</span><span class="params">(network <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>net 必须是**”tcp”、”tcp4”、”tcp6”**。</li>
<li>laddr 为<strong>本地地址</strong>，如果 laddr 不是 nil，将使用它作为本地地址，否则自动选择一个本地地址。<strong>通常为 nil</strong>。</li>
<li>raddr 为<strong>远程的服务器地址</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器远程地址</span></span><br><span class="line">serviceAddr = <span class="string">&quot;127.0.0.1:9617&quot;</span></span><br><span class="line">raddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, serviceAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与服务器建立连接</span></span><br><span class="line">conn, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>, <span class="literal">nil</span>, raddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务器端发送数据</span></span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">result, err := ioutil.ReadAll(conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP-server"><a href="#TCP-server" class="headerlink" title="TCP server"></a>TCP server</h3><p>服务器端需要：</p>
<ul>
<li>绑定服务到指定的非激活端口，并<strong>监听</strong>此端口。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenTCP</span><span class="params">(network <span class="keyword">string</span>, laddr *TCPAddr)</span> <span class="params">(*TCPListener, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当有客户端请求到达的时候可以<strong>接收</strong>到来自客户端连接的请求。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<p>当 Accept 之后，为<strong>每一个 conn 开启一个 goroutine</strong> 来处理与客户端的通信，这样可以支持多并发：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启协程，支持多并发</span></span><br><span class="line">    <span class="keyword">go</span> handleClient(conn)</span><br><span class="line">&#125;d</span><br></pre></td></tr></table></figure>

<h3 id="控制-TCP-连接"><a href="#控制-TCP-连接" class="headerlink" title="控制 TCP 连接"></a>控制 TCP 连接</h3><p>TCP 有很多连接控制函数，常用如下：</p>
<ul>
<li>设置<strong>建立连接的超时时间</strong>，当超过设置时间时，连接自动关闭。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(net, addr <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <strong>写入 / 读取 一个连接的超时时间</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetReadDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetWriteDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <strong>keepAlive 属性</strong>，操作系统在 TCP 上没有数据和 ACK 时，会间隔性的发送 keepalive 包，以此判断这个 TCP 连接是否已经断开。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlive</span><span class="params">(keepalive <span class="keyword">bool</span>)</span> <span class="title">os</span>.<span class="title">Error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h2><p>UDP Socket 在服务器端<strong>没有 Accept 函数</strong>，其他几乎一样。</p>
<h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><p>在 WebSocket 出现之前，为了实现即时通信，采用的技术都是 “”轮询”，即在特定的时间间隔内，由浏览器对服务器发出 HTTP Request，服务器在收到请求后，返回最新的数据给浏览器刷新，“轮询” 使得浏览器需要对服务器不断发出请求，这样会占用大量带宽。</p>
<p>Web Socket 采用了特殊的报头，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道。URI 以 ws 或者 wss（SSL） 开头。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Web Socket 协议本质上是一个基于 <strong>TCP</strong> 的协议。Web Socket 的大致流程如下：</p>
<ul>
<li><p><strong>握手过程：</strong>为了建立一个 Web Socket 连接，客户端浏览器首先要向服务器<strong>发起一个 HTTP 请求</strong>，这个请求和通常的 HTTP 请求不同，包含了一些<strong>附加头</strong>信息，其中附加头信息 <strong>Upgrade: WebSocket</strong> 表明这是一个<strong>申请协议升级</strong>的 HTTP 请求，服务器端解析这些附加的头信息然后<strong>产生应答信息返回给客户端</strong>，客户端和服务器端的 WebSocket 连接就建立起来了。</p>
</li>
<li><p><strong>数据传输：</strong>双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
</li>
</ul>
<p>Web Socket在<strong>第一次握手之后</strong>，连接便建立成功，其后的通讯数据都是以 <strong>\x00 开头</strong>，以 <strong>\xFF 结尾</strong>。在上层应用中，这是透明的，Web Socket 组件会自动的去掉头部和尾部。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Go 语言官方标准库中没有对于 Web Socket 的支持，但是可以通过以下命令获取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/net/websocket</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端示例如下，并且客户端绑定了4个事件：</p>
<ul>
<li><strong>onopen</strong> 建立连接后触发。</li>
<li><strong>onmessage</strong> 收到消息后触发。</li>
<li><strong>onerror</strong> 发生错误时触发。</li>
<li><strong>onclose</strong> 关闭连接时触发。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sock = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> wsuri = <span class="string">&quot;ws://127.0.0.1:9617&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;onload&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock = <span class="keyword">new</span> WebSocket(wsuri);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;connection closed (&quot;</span> + e.code + <span class="string">&quot;)&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        sock.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;message received: &quot;</span> + e.data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;message&#x27;</span>).value;</span></span><br><span class="line"><span class="javascript">        sock.send(msg);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket Echo Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Message: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send();&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	t, _ := template.ParseFiles(<span class="string">&quot;demo.html&quot;</span>)</span><br><span class="line">	t.Execute(w, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Echo</span><span class="params">(ws *websocket.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Can&#x27;t receive&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;Received back from client: &quot;</span> + reply)</span><br><span class="line"></span><br><span class="line">		msg := <span class="string">&quot;Received:  &quot;</span> + reply</span><br><span class="line">		fmt.Println(<span class="string">&quot;Sending to client: &quot;</span> + msg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = websocket.Message.Send(ws, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Can&#x27;t send&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, Index)</span><br><span class="line">	http.Handle(<span class="string">&quot;/ws&quot;</span>, websocket.Handler(Echo))</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:9617&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>REST ( REpresentatianal State Transfer ) 表现层状态转化。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>要理解什么是 REST，需要理解以下几个概念：</p>
<ul>
<li><strong>资源（Resource）</strong>：REST 是 表现层状态转化，实际上 表现层指的是 <strong>资源的表现层</strong>。平常上网访问的一张图片、一个文档、一个视频等就是资源。这些资源我们通过 URI 来定位，也就是一个 URI 表示一个资源。</li>
<li><strong>表现层（Representation）</strong>：把资源实体<strong>展现出来的方式</strong>，就是表现层。比如一段文本信息，可以输出为 HTML，JSON，XML 等。URI 确定一个资源，但是<strong>如何确定它的具体表现形式呢？</strong>应该在 HTTP 请求的头信息中用 <strong>Accept</strong> 和 <strong>Content-Type</strong> 字段指定，这两个字段才是对 “表现层” 的描述。</li>
<li><strong>状态转换（State Transfer）</strong>：在访问服务器的过程中，服务器与客户端进行交互，这就涉及到了数据和状态的变化。HTTP 中四个方法 <strong>GET、POST、PUT、DELETE</strong>，分别对应于<strong>四种基本操作</strong>：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</li>
</ul>
<h2 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h2><p>RESTful 架构就是：</p>
<ul>
<li>每一个 URI 代表一种<strong>资源</strong>。</li>
<li>客户端和服务器之间，传递这种资源的<strong>某种表现层</strong>。</li>
<li>客户端通过<strong>四个 HTTP 动词</strong>，对服务器端资源进行操作，实现 <strong>表现层状态转化</strong>。</li>
</ul>
<p>Web 应用要满足 REST 最重要的原则是：<strong>客户端和服务器之间的交互在请求之间是无状态的</strong>，即从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外此<strong>请求可以由任何可用服务器回答</strong>，这十分适合云计算之类的环境。因为是无状态的，所以客户端可以缓存数据以改进性能。</p>
<p>另一个重要的 REST 原则是：<strong>系统分层</strong>，这表示组件无法了解除了与它直接交互的层次以外的组件。</p>
<p>REST 架构图：</p>
<p><img src="/../images/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Web%E6%9C%8D%E5%8A%A1/8.3.rest2.png" alt="img"></p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>见文章 <a href="./GO%E8%AF%AD%E8%A8%80%E6%9D%82%E8%B0%88-2-RPC">GO语言杂谈 2 RPC</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-XML-JSON-%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">Go Web编程学习笔记 (4) 文本处理-XML JSON 模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-16 21:16:10" itemprop="dateCreated datePublished" datetime="2022-05-16T21:16:10+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-15 10:35:06" itemprop="dateModified" datetime="2023-12-15T10:35:06+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-Web%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go Web编程学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web 开发中需要对输入、输出进行处理。</p>
<h1 id="XML-处理"><a href="#XML-处理" class="headerlink" title="XML 处理"></a>XML 处理</h1><p>示例 XML 文件如下： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span> <span class="attr">version</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Shanghai_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverName</span>&gt;</span>Beijing_VPN<span class="tag">&lt;/<span class="name">serverName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverIP</span>&gt;</span>127.0.0.2<span class="tag">&lt;/<span class="name">serverIP</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="读取-XML"><a href="#读取-XML" class="headerlink" title="读取 XML"></a>读取 XML</h2><p>读取 XML 选择 <strong>xml.Unmarshal</strong> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>将 XML 写入结构体为例，上述 XML 文件 对应的结构体为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开 XML 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.xml&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 读取文件内容</span></span><br><span class="line">	data, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 XML 转为结构体</span></span><br><span class="line">	v := Servers&#123;&#125;</span><br><span class="line">	err = xml.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;] </span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">//    &lt;server&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span></span><br><span class="line"><span class="comment">//        &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/server&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="输出-XML"><a href="#输出-XML" class="headerlink" title="输出 XML"></a>输出 XML</h2><p>xml 包提供了两个函数 Marshal 和 MarshalIndent 来输出 XML，二者的区别在于 MarshalIndent 会增加前缀和缩进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>构建结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName     xml.Name <span class="string">`xml:&quot;servers&quot;`</span></span><br><span class="line">	Version     <span class="keyword">string</span>   <span class="string">`xml:&quot;version,attr&quot;`</span></span><br><span class="line">	Svs         []Server <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	Description <span class="keyword">string</span>   <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;server&quot;`</span></span><br><span class="line">	ServerName <span class="keyword">string</span>   <span class="string">`xml:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span>   <span class="string">`xml:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析结构体并输出 XML ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建结构体</span></span><br><span class="line">	v := Servers&#123;Version: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Shanghai_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class="line">	v.Svs = <span class="built_in">append</span>(v.Svs, Server&#123;ServerName: <span class="string">&quot;Beijing_VPN&quot;</span>, ServerIP: <span class="string">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 转为 XML 数据</span></span><br><span class="line">	data, err := xml.MarshalIndent(&amp;v, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Stdout.Write([]<span class="keyword">byte</span>(xml.Header))</span><br><span class="line">	os.Stdout.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>之所以会有 <code>os.Stdout.Write([]byte(xml.Header))</code> 这句代码的出现，是因为 <code>xml.MarshalIndent</code> 或者 <code>xml.Marshal</code> 输出的信息都是<strong>不带 XML 头</strong>的，为了生成正确的 xml 文件，我们使用了 xml 包预定义的 Header 变量。</p>
<h1 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h1><p>示例 JSON 格式数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;servers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Shanghai_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;serverName&quot;</span>: <span class="string">&quot;Beijing_VPN&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;serverIP&quot;</span>: <span class="string">&quot;127.0.0.2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析-JSON"><a href="#解析-JSON" class="headerlink" title="解析 JSON"></a>解析 JSON</h2><p>json 包中有如下函数可以解析 JSON 数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="解析到结构体"><a href="#解析到结构体" class="headerlink" title="解析到结构体"></a>解析到结构体</h3><p>上述 JSON 数据对应的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServerName <span class="keyword">string</span> <span class="string">`json:&quot;serverName&quot;`</span></span><br><span class="line">	ServerIP   <span class="keyword">string</span> <span class="string">`json:&quot;serverIP&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	Servers []Server <span class="string">`json:&quot;servers&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 JSON 数据到结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;servers.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取内容</span></span><br><span class="line">	data, _ := ioutil.ReadAll(file)</span><br><span class="line">	<span class="comment">// 解析 JSON</span></span><br><span class="line">	v := ServerSlice&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(data, &amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;open file err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析到-interface"><a href="#解析到-interface" class="headerlink" title="解析到 interface"></a>解析到 interface</h3><p>如果知道 JSON 数据的格式，可以解析到结构体中。如果<strong>不知道 JSON 数据格式</strong>，可以利用 <strong>map [string] interface {}</strong> 和 <strong>[] interface {}</strong> 结构来存储任意的 JSON 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure>

<p>此时，空接口 f 实际上是一个 map[string] interface{}，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;servers&quot;</span>:[]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Shanghai_VPN&quot;</span>&#125;, </span><br><span class="line">        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span> &#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;serverIP&quot;</span>:<span class="string">&quot;127.0.0.2&quot;</span>, </span><br><span class="line">            <span class="string">&quot;serverName&quot;</span>:<span class="string">&quot;Beijing_VPN&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过类型断言将**空接口转为 map[string] interface{}**，接着就可以利用 <strong>for range</strong> 对 map 进行遍历了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>目前，<code>simplejson</code> 包可以更加容易的处理未知结构的 JSON 数据，其 github 地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/bitly/go-simplejson">github.com/bitly/go-simplejson</a></p>
<hr>
<h2 id="生成-JSON"><a href="#生成-JSON" class="headerlink" title="生成 JSON"></a>生成 JSON</h2><p>json 包提供了生成 JSON 数据的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>这里不再举例说明具体操作。</p>
<h1 id="模板处理"><a href="#模板处理" class="headerlink" title="模板处理"></a>模板处理</h1><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><h3 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h3><p>html/template 包中有两个函数可以解析模板：</p>
<ul>
<li><strong>ParseFiles 函数</strong>创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ParseGlob 函数</strong>创建一个模板并解析匹配 pattern 的文件里的模板定义。返回的模板的名字是第一个匹配的文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseGlob</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(*Template, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="模板执行"><a href="#模板执行" class="headerlink" title="模板执行"></a>模板执行</h3><p>html/template 包中有两个函数可以执行模板：</p>
<ul>
<li><strong>Execute 方法</strong>将解析好的模板应用到 data 上，并将输出写入 wr。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">Execute</span><span class="params">(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ExecuteTemplate 方法</strong>类似 Execute，但是使用名为 nam e的 t 关联的模板产生输出。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">ExecuteTemplate</span><span class="params">(wr io.Writer, name <span class="keyword">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="模板中插入数据"><a href="#模板中插入数据" class="headerlink" title="模板中插入数据"></a>模板中插入数据</h2><ul>
<li><p><strong>字段操作</strong>：<code>&#123;&#123;.&#125;&#125;</code> 代表<strong>当前对象</strong>，可以通过 <code>&#123;&#123;.FieldName&#125;&#125;</code> 访问当前对象的<strong>字段</strong>。</p>
</li>
<li><p><strong>输出嵌套字段</strong>：</p>
<ul>
<li><code>&#123;&#123;with …&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 可以指定当前对象的值，如子结构体。</li>
<li><code>&#123;&#123;range …&#125;&#125;&#123;&#123;end&#125;&#125;</code> 可以循环操作数据。</li>
</ul>
</li>
<li><p><strong>条件判断</strong>：<code>&#123;&#123;if …&#125;&#125;…&#123;&#123;else if …&#125;&#125;…&#123;&#123;else&#125;&#125;…&#123;&#123;end&#125;&#125;</code> 语句可以进行条件判断。</p>
</li>
<li><p><strong>pipelines</strong>：在 <code>&#123;&#123;&#125;&#125;</code> 中的都是 pipeline，如 <code>&#123;&#123;. | html&#125;&#125;</code> 可以将当前对象进行 HTML 转义，变为 HTML 实体。</p>
</li>
<li><p><strong>模板变量</strong>：可以通过 <code>$variable := pipeline</code> 方式声明模板局部变量。</p>
</li>
<li><p><strong>模板嵌套</strong>：</p>
<ul>
<li>声明：<code>&#123;&#123;define "子模板名称"&#125;&#125;内容&#123;&#123;end&#125;&#125;</code></li>
<li>调用：<code>&#123;&#123;template "子模板名称"&#125;&#125;</code></li>
</ul>
</li>
<li><p><strong>模板函数</strong>：</p>
<ul>
<li>每一个模板函数都有一个唯一的名字，可以与一个 Go 函数相关联。<strong>FuncMap</strong> 类型定义了函数名字符串到函数的映射，每个函数都必须<strong>有 1 到 2 个返回值</strong>，如果有 2 个则<strong>后一个必须是 error 接口类型</strong>；如果有 2 个返回值的方法返回的 error 非 nil ，模板执行会中断并返回给调用者该错误。：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>t.Funcs</code> 函数在模板中注册函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = t.Funcs(template.FuncMap&#123;<span class="string">&quot;TmplFuncName&quot;</span>: FuncName&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在模板包内部已经有内置的实现函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builtins = FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;and&quot;</span>:      and,</span><br><span class="line">    <span class="string">&quot;call&quot;</span>:     call,</span><br><span class="line">    <span class="string">&quot;html&quot;</span>:     HTMLEscaper,</span><br><span class="line">    <span class="string">&quot;index&quot;</span>:    index,</span><br><span class="line">    <span class="string">&quot;js&quot;</span>:       JSEscaper,</span><br><span class="line">    <span class="string">&quot;len&quot;</span>:      length,</span><br><span class="line">    <span class="string">&quot;not&quot;</span>:      not,</span><br><span class="line">    <span class="string">&quot;or&quot;</span>:       or,</span><br><span class="line">    <span class="string">&quot;print&quot;</span>:    fmt.Sprint,</span><br><span class="line">    <span class="string">&quot;printf&quot;</span>:   fmt.Sprintf,</span><br><span class="line">    <span class="string">&quot;println&quot;</span>:  fmt.Sprintln,</span><br><span class="line">    <span class="string">&quot;urlquery&quot;</span>: URLQueryEscaper,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Must-操作"><a href="#Must-操作" class="headerlink" title="Must 操作"></a>Must 操作</h2><p>Must 函数用来检查模板是否正确：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Must</span><span class="params">(t *Template, err error)</span> *<span class="title">Template</span></span></span><br></pre></td></tr></table></figure>

<p>一般用于变量初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;html&quot;</span>))</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">388</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
