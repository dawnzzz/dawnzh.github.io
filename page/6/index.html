<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawnzzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人博客站点">
<meta property="og:type" content="website">
<meta property="og:title" content="Dawn&#39;s Blogs">
<meta property="og:url" content="http://dawnzzz.github.io/page/6/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blogs">
<meta property="og:description" content="个人博客站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DawnZH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dawnzzz.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dawn's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术 记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Pulsar消息队列(1)简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-22 13:06:00" itemprop="dateCreated datePublished" datetime="2024-02-22T13:06:00+08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Pulsar消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Apache Pulsar是一个支持<strong>多租户的、高性能的、分布式</strong>的<strong>多租户</strong>消息系统，最初由雅虎开发，现在是Apache软件基金会的顶级项目。 Pulsar提供非常低的消息发布和端到端的延迟、保障消息可靠传递零丢失。</p>
<h1 id="分布式消息系统"><a href="#分布式消息系统" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h1><blockquote>
<p>Pulsar 是<strong>基于段</strong>的分布式消息队列。</p>
</blockquote>
<p>一般的消息系统在逻辑上都可分为<strong>服务层</strong>和存储层两层:</p>
<ul>
<li><strong>服务层：</strong>直接与消息的<strong>生产者和消费者交互</strong>，接收传入的消息并将消息路由到一个或多个目的地。服务层通过支持的消息协议进行通讯，例如AMQP。服务层在消息协议转换上依赖CPU，在通信上依赖网络带宽。</li>
<li><strong>存储层：</strong>负责消息的<strong>存储</strong>。存储层与服务层交互提供服务层请求的消息，存储层保持消息的正确顺序。存储层严重依赖硬盘来存储消息。</li>
</ul>
<blockquote>
<p>分布式消息系统与传统单点消息系统在架构上的主要<strong>差别</strong>在于<strong>存储层的设计方式</strong>。在<strong>分布式</strong>消息传递系统中，数据分布在集群中的多台机器上，允许在单个主题中保留超过单个机器存储容量的消息。分布式消息系统存储层的<strong>关键架构抽象是 write-ahead-log</strong>，它将<strong>存储的消息看成是单个仅追加的数据结构</strong>。 对于分布式消息系统，当新消息发布到主题时，从逻辑的角度来看，消息将被追加到日志的末尾；从物理的角度来看，消息可能写入集群中的任何服务器。</p>
</blockquote>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/partion-based-msg.png" alt="partion-based-msg.png"></p>
<p>分布式消息系统的好处是<strong>将负载分散到多台机器上</strong>，可以提高消息的生产和消费的吞吐量，每台服务器都有自己硬盘和写入路径，将提供更好的写入速率。 在分布式消息系统集群中分布消息数据时，有两种不同的方法: <strong>基于分区（Partion-based）和基于段（Segment-based）</strong>。</p>
<h2 id="基于分区"><a href="#基于分区" class="headerlink" title="基于分区"></a>基于分区</h2><blockquote>
<p> Kafka 采用的是基于分区的消息存储架构。</p>
</blockquote>
<p>在基于分区的消息存储结构中，<strong>Topic 被划分为固定数量的分区</strong>，发布到 Topic 中的数据均匀的分布在分区中，同时为了确保数据冗余，<strong>每个分区会被复制到不同的节点</strong>。</p>
<p>Topic 中消息的总存储量为 Topic 的分区数乘以分区的大小，如果达到这个限制，需要向集群添加更多的节点同时增加 Topic 的分区数量才能继续向分区中添加数据，增加分区的数量还需要执行重新平衡，这是一个十分复杂和耗时的过程。</p>
<p>在基于分区的消息存储结构的分布式消息系统中，一般在创建 Topic 的时候需要预先确定分区数量，但这样做有一些缺点，因为单个分区只会存储在集群中单个集群节点上，因此单个分区的大小就受限于该节点上的硬盘空间大小，由于 Topic 中的数据均匀分布在所有分区中，所以如果集群节点的硬盘容量不一样的话，<strong>那么 Topic 的每个分区的大小将限制为最小硬盘容量的节点</strong>。当 Topic 达到容量限制后，<strong>唯一能做的就是增加 Topic 的分区数量</strong>，但这个扩容的过程包括<strong>重新平衡整个 Topic</strong>，Topic 中的数据将被重新分布到该 Topic 的所有分区中，平衡数据的过程<strong>十分消耗网络带宽和磁盘 I/O</strong>。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/kafka-partitions.png" alt="kafka-partitions"></p>
<h2 id="基于段"><a href="#基于段" class="headerlink" title="基于段"></a>基于段</h2><blockquote>
<p>Pulsar 采用的是基于段的消息存储结构。</p>
<p>Pulsar 中服务层合存储层都是<strong>无状态</strong>的，可以任意的进行<strong>水平</strong>扩容。<strong>引入 Zookeeper 集群</strong>，用于集群级别的配置和协调，Zookeeper 中存储 Pulsar 集群的所有元数据（例如 Topic 元数据、Broker 负载数据等等)</p>
</blockquote>
<p><strong>Pulsar 依赖 Apache BookKeeper 项目来实现消息的持久存储</strong>，BookKeeper 的逻辑存储模型是基于无限流记录作为顺序日志存储的概念。</p>
<p>在BookKeeper中，<strong>每个日志被分解成更小的数据块</strong>，称为段（Segament），这些数据块又由多个日志条目组成。然后，为了实现冗余和扩展，这些段会在存储层中被称为 bookies 的多个节点上写入。可以<strong>将段放在集群节点具有足够硬盘容量的任何位置</strong>，当没有足够的空间用于存储新的段时，可以方便地添加节点并立即存储数据。基于段的存储架构的优点在于<strong>可以实现真正的水平伸缩</strong>，段可以被无限创建并存储在任何位置。</p>
<p><img src="/../images/Pulsar%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1-%E7%AE%80%E4%BB%8B/pulsar-segaments.png" alt="pulsar-segaments"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/02/04/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-Resource-Manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-Resource-Manager/" class="post-title-link" itemprop="url">Kuma学习笔记 (7) Resource Manager</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-04 17:00:10" itemprop="dateCreated datePublished" datetime="2024-02-04T17:00:10+08:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma 将使用的对象抽象为各种资源（Resource），如 Zone，Ingress，Dataplain，RateLimit 等，<strong>由资源管理器（Resource Manager）对资源存储（Resource Store）进行增删改查等操作</strong>。</p>
<p><strong>Resource Store 向上屏蔽了底层存储的差异</strong>，在 Kuma 中使用两种存储模式，kubernetes API Server 和 PostgreSQL 数据库。而 <strong>Resource Manager 屏蔽了对于各个资源操作的差异</strong>。</p>
<h1 id="Resource-Store"><a href="#Resource-Store" class="headerlink" title="Resource Store"></a>Resource Store</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>ResourceStore 接口用于定义资源的底层存储，ResourceStore 需要实现 Create、Update、Delete、Get、List 操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(context.Context, model.Resource, ...CreateOptionsFunc) error</span><br><span class="line">    Update(context.Context, model.Resource, ...UpdateOptionsFunc) error</span><br><span class="line">    Delete(context.Context, model.Resource, ...DeleteOptionsFunc) error</span><br><span class="line">    Get(context.Context, model.Resource, ...GetOptionsFunc) error</span><br><span class="line">    List(context.Context, model.ResourceList, ...ListOptionsFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>在 Kuma 中，ResourceStore 接口由 k8s、memory、postgres、remote 实现。其中：</p>
<ul>
<li><strong>K8s：</strong>在 Kubernetes 模式下，以 Kubernetes API Server 存储资源。</li>
<li><strong>Postgres：</strong>在 Universal 模式下，以 PostgreSQL 作为底层数据库存储数据。</li>
<li>Memory：内存数据库，用于测试。</li>
<li>Remote：为 kuma-ctl 做资源存储，负责以 HTTP Restful API 的方式操作 kuma-cp。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── k8s</span><br><span class="line">├── memory</span><br><span class="line">├── postgres</span><br><span class="line">└── remote</span><br></pre></td></tr></table></figure>

<h2 id="CustomizableResourceStore"><a href="#CustomizableResourceStore" class="headerlink" title="CustomizableResourceStore"></a>CustomizableResourceStore</h2><p>Customizable Resource Store 为<strong>某一种具体的资源</strong>提供<strong>定制化</strong>的 Resource Store：</p>
<ul>
<li><strong>Customize 方法：</strong>为 model.ReourceType 类型的资源<strong>指定</strong>资源存储器。</li>
<li><strong>ResourceStore 方法：</strong>返回 model.ResourceType 类型的资源存储器，如果没有该类型，则会返回默认的资源存储器。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceStoreWrapper is a function that takes a ResourceStore and returns a wrapped ResourceStore.</span></span><br><span class="line"><span class="comment">// The wrapped ResourceStore can be used to modify or augment the behavior of the original ResourceStore.</span></span><br><span class="line"><span class="keyword">type</span> ResourceStoreWrapper = <span class="function"><span class="keyword">func</span><span class="params">(delegate ResourceStore)</span> <span class="title">ResourceStore</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomizableResourceStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    ResourceStore</span><br><span class="line">    ResourceStore(typ model.ResourceType) ResourceStore</span><br><span class="line">    DefaultResourceStore() ResourceStore</span><br><span class="line">    Customize(typ model.ResourceType, store ResourceStore)</span><br><span class="line">    WrapAll(wrapper ResourceStoreWrapper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Resource-Manager"><a href="#Resource-Manager" class="headerlink" title="Resource Manager"></a>Resource Manager</h1><h2 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h2><p>Resource Manager 用于对资源（Zone、Dataplain 等）进行操作，定义的方法与 Resource Store 差不多，都是增删改查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadOnlyResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(context.Context, model.Resource, ...store.GetOptionsFunc) error</span><br><span class="line">    List(context.Context, model.ResourceList, ...store.ListOptionsFunc) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadOnlyResourceManager</span><br><span class="line">    Create(context.Context, model.Resource, ...store.CreateOptionsFunc) error</span><br><span class="line">    Update(context.Context, model.Resource, ...store.UpdateOptionsFunc) error</span><br><span class="line">    Delete(context.Context, model.Resource, ...store.DeleteOptionsFunc) error</span><br><span class="line">    DeleteAll(context.Context, model.ResourceList, ...store.DeleteAllOptionsFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CustomizableResourceManager"><a href="#CustomizableResourceManager" class="headerlink" title="CustomizableResourceManager"></a>CustomizableResourceManager</h2><p>Customizable Resource Manager 为<strong>某一种具体的资源</strong>提供<strong>定制化</strong>的 Resource Manager：</p>
<ul>
<li><strong>Customize 方法：</strong>为 model.ReourceType 类型的资源<strong>指定</strong>资源管理器。</li>
<li><strong>ResourceManager 方法：</strong>返回 model.ResourceType 类型的资源管理器，如果没有该类型，则会返回默认的资源管理器。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceManagerWrapper = <span class="function"><span class="keyword">func</span><span class="params">(delegate ResourceManager)</span> <span class="title">ResourceManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomizableResourceManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    ResourceManager</span><br><span class="line">    Customize(model.ResourceType, ResourceManager)</span><br><span class="line">    ResourceManager(model.ResourceType) ResourceManager</span><br><span class="line">    WrapAll(ResourceManagerWrapper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 kuma-cp 初始化 Resource Manager 时，会为<strong>每一种资源指定一种资源管理器</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeResourceManager</span><span class="params">(cfg kuma_cp.Config, builder *core_runtime.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    defaultManager := core_manager.NewResourceManager(builder.ResourceStore())</span><br><span class="line">    customizableManager := core_manager.NewCustomizableResourceManager(defaultManager, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.MeshType,</span><br><span class="line">       mesh_managers.NewMeshManager(</span><br><span class="line">          builder.ResourceStore(),</span><br><span class="line">          customizableManager,</span><br><span class="line">          builder.CaManagers(),</span><br><span class="line">          registry.Global(),</span><br><span class="line">          builder.ResourceValidators().Mesh,</span><br><span class="line">          cfg.Store.UnsafeDelete,</span><br><span class="line">          builder.Extensions(),</span><br><span class="line">       ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    rateLimitValidator := ratelimit_managers.RateLimitValidator&#123;</span><br><span class="line">       Store: builder.ResourceStore(),</span><br><span class="line">    &#125;</span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.RateLimitType,</span><br><span class="line">       ratelimit_managers.NewRateLimitManager(builder.ResourceStore(), rateLimitValidator),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    externalServiceValidator := externalservice_managers.ExternalServiceValidator&#123;</span><br><span class="line">       Store: builder.ResourceStore(),</span><br><span class="line">    &#125;</span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ExternalServiceType,</span><br><span class="line">       externalservice_managers.NewExternalServiceManager(builder.ResourceStore(), externalServiceValidator),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.DataplaneType,</span><br><span class="line">       dataplane.NewDataplaneManager(builder.ResourceStore(), builder.Config().Multizone.Zone.Name, builder.ResourceValidators().Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.DataplaneInsightType,</span><br><span class="line">       dataplaneinsight.NewDataplaneInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.ZoneType,</span><br><span class="line">       zone.NewZoneManager(builder.ResourceStore(), zone.Validator&#123;Store: builder.ResourceStore()&#125;, builder.Config().Store.UnsafeDelete),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.ZoneInsightType,</span><br><span class="line">       zoneinsight.NewZoneInsightManager(builder.ResourceStore(), builder.Config().Metrics.Zone),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ZoneIngressInsightType,</span><br><span class="line">       zoneingressinsight.NewZoneIngressInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       mesh.ZoneEgressInsightType,</span><br><span class="line">       zoneegressinsight.NewZoneEgressInsightManager(builder.ResourceStore(), builder.Config().Metrics.Dataplane),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cipher secret_cipher.Cipher</span><br><span class="line">    <span class="keyword">switch</span> cfg.Store.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> store.KubernetesStore:</span><br><span class="line">       cipher = secret_cipher.None() <span class="comment">// deliberately turn encryption off on Kubernetes</span></span><br><span class="line">    <span class="keyword">case</span> store.MemoryStore, store.PostgresStore:</span><br><span class="line">       cipher = secret_cipher.TODO() <span class="comment">// get back to encryption in universal case</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;unknown store type %s&quot;</span>, cfg.Store.Type)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> secretValidator secret_manager.SecretValidator</span><br><span class="line">    <span class="keyword">if</span> cfg.IsFederatedZoneCP() &#123;</span><br><span class="line">       secretValidator = secret_manager.ValidateDelete(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, secretName <span class="keyword">string</span>, secretMesh <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       secretValidator = secret_manager.NewSecretValidator(builder.CaManagers(), builder.ResourceStore())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.SecretType,</span><br><span class="line">       secret_manager.NewSecretManager(builder.SecretStore(), cipher, secretValidator, cfg.Store.UnsafeDelete),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    customizableManager.Customize(</span><br><span class="line">       system.GlobalSecretType,</span><br><span class="line">       secret_manager.NewGlobalSecretManager(builder.SecretStore(), cipher),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    builder.WithResourceManager(customizableManager)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> builder.Config().Store.Cache.Enabled &#123;</span><br><span class="line">       cachedManager, err := core_manager.NewCachedManager(</span><br><span class="line">          customizableManager,</span><br><span class="line">          builder.Config().Store.Cache.ExpirationTime.Duration,</span><br><span class="line">          builder.Metrics(),</span><br><span class="line">          builder.Tenants(),</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       builder.WithReadOnlyResourceManager(cachedManager)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       builder.WithReadOnlyResourceManager(customizableManager)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cached-Manager"><a href="#Cached-Manager" class="headerlink" title="Cached Manager"></a>Cached Manager</h2><p>Cached Manager 实现了只读资源管理器 Read Only Resource Manager，为对资源的 Get 和 List 操作进行<strong>缓存</strong>（有过期时间）。</p>
<ul>
<li>delegate：底层 ReadOnlyResourceManager，若缓存未命中则会从底层只读资源管理器中读取数据，并记录在缓存中。</li>
<li><strong>cache：</strong>cached manager 的核心数据结构，用于缓存查询结果。key 为 <code>&lt;op&gt;:&lt;resource_type&gt;:&lt;ops.hashcode(resource_name+resource_mesh)&gt;:tenantID</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheKey := fmt.Sprintf(<span class="string">&quot;GET:%s:%s:%s&quot;</span>, res.Descriptor().Name, opts.HashCode(), tenantID)</span><br></pre></td></tr></table></figure>

<ul>
<li>mutexes：为每一个 key 单独加锁，保证每一个 k-v 都互斥访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cached version of the ReadOnlyResourceManager designed to be used only for use cases of eventual consistency.</span></span><br><span class="line"><span class="comment">// This cache is NOT consistent across instances of the control plane.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When retrieving elements from cache, they point to the same instances of the resources.</span></span><br><span class="line"><span class="comment">// We cannot do deep copies because it would consume lots of memory, therefore you need to be extra careful to NOT modify the resources.</span></span><br><span class="line"><span class="keyword">type</span> cachedManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    delegate ReadOnlyResourceManager</span><br><span class="line">    cache    *cache.Cache</span><br><span class="line">    metrics  *prometheus.CounterVec</span><br><span class="line"></span><br><span class="line">    mutexes  <span class="keyword">map</span>[<span class="keyword">string</span>]*sync.Mutex</span><br><span class="line">    mapMutex sync.Mutex <span class="comment">// guards &quot;mutexes&quot; field</span></span><br><span class="line">    tenants  multitenant.Tenants</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/" class="post-title-link" itemprop="url">Kuma学习笔记 (6) Inter CP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-30 16:40:46" itemprop="dateCreated datePublished" datetime="2024-01-30T16:40:46+08:00">2024-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma-cp 的 Intercp（Control Plane Intercommunication）组件用于 kuma 控制面之间的通信，旨在实现 kuma-cp 的<strong>水平扩展。</strong></p>
<p>kuma 的水平扩展包含三个方面：</p>
<ul>
<li><strong>Leader 选举机制：</strong>在 kuma 中，leader 选举机制非常简单，就是<strong>选择最新加入的 kuma-cp 节点作为 Leader</strong>。作为 Leader，会接收成员的心跳，并且定期监测超时的 kuma-cp 成员。</li>
<li><strong>心跳机制：</strong>作为成员，会定期向 Leader 发送心跳，表明自己还存活。</li>
<li><strong>EnvoyAdminServer：</strong>对于 Global Cp 的水平扩展多实例部署，会将 EnvoyAdmin 请求<strong>转发</strong>给 Leader Global Kuma-cp 执行。对于 Zone Cp 的水平扩展多实例部署，会在本实例执行对 envoy 发起 Admin 请求获取响应。</li>
</ul>
<blockquote>
<p>下文中的实例，表示 kuma-cp 水平扩展中的某一实例。</p>
</blockquote>
<blockquote>
<p>可以发现，kuma-cp 在水平扩展时，如果 leader 下线了<strong>没有自动故障切换机制</strong>，除非原来的 leader 再次上线或者有新的 kuma-cp 实例上线，leader 才会正常工作。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/30/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Inter-CP/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/29/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">Triple协议 (7) 应用级别的服务发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 19:52:09" itemprop="dateCreated datePublished" datetime="2024-01-29T19:52:09+08:00">2024-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/triple%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">triple协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在微服务架构中，如何感知后端服务实例的动态上下线，就是<strong>服务发现（Service Discovery）</strong>。业界比较有代表性的微服务框架如 SpringCloud、Dubbo 等都抽象了强大的动态地址发现能力，并且为了满足微服务业务场景的需求，绝大多数框架的地址发现都是基于自己设计的一套机制来实现。在 SpringCloud 中使用 Eureka 作为注册中心，Dubbo 通常采用 zookeeper 和 nacos 作为注册中心。注册中心不仅仅记录了 IP+Port，还包括微服务的元信息，如序列化类型，实例方法列表，各个方法级的定制化配置等。</p>
<p>服务发现包含三种角色：<strong>服务提供者（Provider）、服务消费者（Consumer）和注册中心（Registry）</strong>。不同框架之间的区别在于如何组织注册中心中的数据。</p>
<blockquote>
<p>dubbo中应用，服务和实例的概念区分：</p>
<p><strong>应用</strong>是一个独立的逻辑单元，一个应用可以包含多个<strong>服务</strong>，每个服务可以包含多个<strong>实例</strong>。</p>
</blockquote>
<h1 id="业界服务发现方式"><a href="#业界服务发现方式" class="headerlink" title="业界服务发现方式"></a>业界服务发现方式</h1><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 通过注册中心<strong>只同步了应用与实例地址</strong>，消费方可以基于实例地址与服务提供方建立链接，但是消费方对于如何发起 HTTP 调用（SpringCloud 基于 rest 通信）一无所知，比如对方有哪些 HTTP endpoint，需要传入哪些参数等。</p>
<p>RPC 服务这部分信息目前都是通过线下约定或离线的管理系统来协商的。这种架构的优缺点总结如下。</p>
<ul>
<li><strong>优势</strong>： 部署结构清晰、地址推送量小。</li>
<li><strong>缺点</strong>： 地址订阅需要指定应用名， provider 应用变更（拆分）需消费端感知；RPC 调用无法全自动同步。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/d6b81ecf9bf5b3d630cab1fb0059756f.png" alt="img"></p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo 通过注册中心<strong>同时同步了实例地址和 RPC 方法</strong>，因此其能实现 RPC 过程的自动同步，面向 RPC 编程、面向 RPC 治理，对后端应用的拆分消费端无感知，其缺点则是<strong>地址推送数量变大</strong>，和 RPC 方法成正比。</p>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/d4863add6a9031faa9dda73f23ff0fab.png" alt="img"></p>
<h2 id="Dubbo-Kubernetes"><a href="#Dubbo-Kubernetes" class="headerlink" title="Dubbo + Kubernetes"></a>Dubbo + Kubernetes</h2><p>Kubernetes Service 作为一个抽象概念，怎么映射到 Dubbo 是一个值得讨论的点。</p>
<ol>
<li><strong>Service Name - &gt; Application Name：</strong>Dubbo 应用和 Kubernetes 服务一一对应，对于微服务运维和建设环节透明，与开发阶段解耦（对应于应用服务发现）。</li>
<li><strong>Service Name - &gt; Dubbo RPC Service：</strong>维护的 Service 数量变多，一个 Dubbo 应用可以运行多个接口，即一个 Dubbo 应用可以创建多个 Kubernetes Service（如 dubbo-app-service-1，dubbo-app- service-2 等）。</li>
</ol>
<h1 id="Dubbo-3-服务发现"><a href="#Dubbo-3-服务发现" class="headerlink" title="Dubbo 3 服务发现"></a>Dubbo 3 服务发现</h1><h2 id="服务自省"><a href="#服务自省" class="headerlink" title="服务自省"></a>服务自省</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>以 Dubbo 之前的地址发现数据格式为例，它是“RPC 服务粒度”的，它是以 RPC 服务作为 key，以实例列表作为 value 来组织数据的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;RPC Service1&quot;</span>: [  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance1&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">1000</span>&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance2&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">2000</span>&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance3&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;<span class="attr">&quot;timeout&quot;</span>:<span class="number">3000</span>&#125;&#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;RPC Service2&quot;</span>: [Instance list of RPC Service2],</span><br><span class="line"><span class="string">&quot;RPC ServiceN&quot;</span>: [Instance list of RPC ServiceN]</span><br></pre></td></tr></table></figure>

<p>而 Dubbo 3 中的服务发现，<strong>是“应用粒度的服务发现”</strong>，它以<strong>应用名（Application）作为 key</strong>，以<strong>这个应用部署的一组实例（Instance）列表作为 value</strong>。这带来两点不同：</p>
<ol>
<li>数据映射关系变了，从 RPC Service -&gt; Instance 变为 Application -&gt; Instance。</li>
<li><strong>数据变少了</strong>，注册中心没有了 RPC Service 及其相关配置信息。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;application1&quot;</span>: [</span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance1&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instance2&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;,  </span><br><span class="line">  &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;instanceN&quot;</span>, <span class="attr">&quot;ip&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Dubbo 之前的服务发现粒度更细，在注册中心产生的数据条目也会更多（与 RPC 服务成正比），同时也存在一定的<strong>数据冗余</strong>。</p>
<p>接着解释<strong>它为什么会被叫做“服务自省”？</strong>其实这还是得从它的工作原理说起，上面提到，应用粒度服务发现的数据模型有几个以下明显变化：数据中心的数据量少了，RPC 服务相关的数据在注册中心没有了，现在只有 application - instance 这两个层级的数据。</p>
<p><strong>为了保证这部分缺少的 RPC 服务数据仍然能被 Consumer 端正确的感知</strong>，我们在 Consumer 和 Provider 间建立了一条单独的通信通道：Consumer 和 Provider 两两之间<strong>通过特定端口交换信息</strong>，我们把这种 Provider 自己<strong>主动暴露自身信息的行为</strong>认为是一种内省机制，因此整个机制命名为：服务自省。</p>
<h3 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h3><p>为什么需要服务自省，这会带来以下优势：</p>
<ol>
<li><strong>与业界主流微服务模型对齐</strong>，比如 SpringCloud、Kubernetes Service 等。</li>
<li><strong>提升性能与可伸缩性</strong>。<ul>
<li>注册中心的数据减少了，<strong>大幅度的减轻注册中心的存储、推送压力</strong>，进而减少 Dubbo Consumer 侧的地址计算压力。</li>
<li><strong>服务发现的数据规模，以及集群规模</strong>也开始变得<strong>可预测、可评估</strong>（与 RPC 接口数量无关，只与实例部署规模相关）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>根据统计，平均情况下 Consumer 订阅的 3 个接口来自同一个 Provider 应用，如此计算下来，如果以应用粒度为地址通知和选址基本单位，则平均地址推送和计算量将下降 60% 还要多。而在极端情况下，也就是当 Consumer 端消费的接口更多的来自同一个应用时，这个地址推送与内存消耗的占用将会进一步得到降低，甚至可以超过 80% 以上。</p>
<p>典型的例子是 API 网关，可能一个 API 网关有几十个甚至上百个定义的服务。</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>以下是服务自省的一个完整工作流程图，详细描述了服务注册、服务发现、MetadataService、RPC 调用间的协作流程。</p>
<ul>
<li>服务提供者启动，首先解析应用<strong>定义的“普通服务”并依次注册为 RPC 服务</strong>，紧接着<strong>注册内建的 MetadataService 服务</strong>，最后打开 TCP 监听端口。</li>
<li>启动完成后，<strong>将实例信息注册到注册中心（仅限 ip、port 等实例相关数据）</strong>，提供者启动完成。</li>
<li>服务消费者启动，首先依据其要<strong>“消费的 provider 应用名”</strong>到注册中心查询地址列表，并完成<strong>订阅</strong>（以实现后续地址变更自动通知）。</li>
<li>消费端拿到地址列表后，紧接着<strong>对 MetadataService 发起调用</strong>，返回结果中包含了<strong>所有应用定义的“普通服务”及其相关配置信息</strong>。</li>
<li>至此，消费者可以接收外部流量，并对提供者<strong>发起 Dubbo RPC 调用</strong>。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/bf45f69f7a9fcb04e085be062481bba9.png" alt="img"></p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>接口级服务发现的好处是数据量小，但是<strong>接口粒度的服务治理能力还是要继续保留</strong>。这就需要两点设计原则：</p>
<ol>
<li>新的服务发现模型要实现对原有 Dubbo 消费端开发者的<strong>无感知迁移</strong>，即 Dubbo 继续面向 RPC 服务编程、面向 RPC 服务治理，做到对用户侧完全无感知。</li>
<li>建立 Consumer 与 Provider 间的<strong>自动化 RPC 服务元数据协调机制</strong>，解决传统微服务模型无法同步 RPC 级接口配置的缺点。</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><strong>注册中心的数据组织方式：</strong>以应用名为 key，实例列表为 value 组织数据。元数据只包含实例级别的元数据，不包含接口级别的元数据。注册中心的一个实例条目如下，仅仅包含实例地址，端口，实例级别的元数据信息等基本信息。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;provider-app-name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;192.168.0.102:20880&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.0.102&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;port&quot;</span>: <span class="number">20880</span>,</span><br><span class="line">  <span class="attr">&quot;sslPort&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;payload&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;provider-app-name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;metadataService&quot;</span>: <span class="string">&quot;&#123;\&quot;dubbo\&quot;:&#123;\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;dubbo\&quot;:\&quot;2.0.2\&quot;,\&quot;release\&quot;:\&quot;2.7.5\&quot;,\&quot;port\&quot;:\&quot;20881\&quot;&#125;&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;endpoints&quot;</span>: <span class="string">&quot;[&#123;\&quot;port\&quot;:20880,\&quot;protocol\&quot;:\&quot;dubbo\&quot;&#125;]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage-type&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;revision&quot;</span>: <span class="string">&quot;6785535733750099598&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registrationTimeUTC&quot;</span>: <span class="number">1583461240877</span>,</span><br><span class="line">  <span class="attr">&quot;serviceType&quot;</span>: <span class="string">&quot;DYNAMIC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;uriSpec&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>服务调用者和提供者自行协商 RPC 方法信息。</strong>在注册中心不再同步 RPC 服务信息后，服务自省在服务消费端和提供端之间建立了一条内置的 RPC 服务信息协商机制。<strong>服务端实例会暴露一个预定义的 MetadataService RPC 服务</strong>，消费端通过调用 MetadataService 获取每个实例 RPC 方法相关的配置信息。当前 MetadataService 返回的数据格式如下：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span>, </span><br><span class="line"> <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.HelloService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dubbo://192.168.0.102:20880/org.apache.dubbo.demo.WorldService?anyhost=true&amp;application=demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=9585&amp;release=2.7.5&amp;side=provider&amp;timestamp=1583469714314&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h2><h3 id="元数据同步机制"><a href="#元数据同步机制" class="headerlink" title="元数据同步机制"></a>元数据同步机制</h3><p>Client 与 Server 间在收到地址推送后的配置同步是服务自省的关键环节，目前针对元数据同步有两种具体的可选方案，分别是：</p>
<ul>
<li><strong>内建的 MetadataService 服务</strong>。</li>
<li><strong>独立的元数据中心</strong>，通过中心化的元数据集群协调数据。Provider 实例启动后，会尝试将内部的 RPC 服务组织成元数据的格式到元数据中心，而 consumer 则在每次收到注册中心推送更新后，主动查询元数据中心。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/cef0a9b33a8f710d00e048fc7868925a.png" alt="img"></p>
<h3 id="RPC-服务与应用之间的映射关系"><a href="#RPC-服务与应用之间的映射关系" class="headerlink" title="RPC 服务与应用之间的映射关系"></a>RPC 服务与应用之间的映射关系</h3><p><strong>从服务粒度到应用粒度</strong>，要想用户完全无感知必须<strong>知道 RPC 服务与应用名之间的映射关系</strong>。所以为了使整个开发流程对老的 Dubbo 用户更透明，同时避免指定 provider 对可扩展性带来的影响，设计了一套 RPC 服务到应用名的映射关系，以尝试在 consumer 自动完成 RPC 服务到 provider 应用名的转换。</p>
<ul>
<li>consumer 通过配置中心<strong>以服务名查询应用名</strong>。</li>
<li>consumer 得到应用名，就可以检索注册中心，进行应用级别的服务发现了。</li>
</ul>
<p><img src="/../images/Triple%E5%8D%8F%E8%AE%AE-7-%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/3ab172dd6153a031b4f65e034d9a03f0.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">用户增长 Marketing-API重构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-29 13:57:27" itemprop="dateCreated datePublished" datetime="2024-01-29T13:57:27+08:00">2024-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">用户增长体系</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          这是一篇加密文章，需要密码才能继续阅读
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/29/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF-Marketing-API%E9%87%8D%E6%9E%84%E8%AE%BE%E8%AE%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Kuma学习笔记 (5) 网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-25 12:53:28" itemprop="dateCreated datePublished" datetime="2024-01-25T12:53:28+08:00">2024-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>本节介绍 kuma 如何处理 service mesh 中的服务发现问题，包括数据平面代理和控制平面之间的通信，控制平面代理间的通信。</p>
<h2 id="数据平面代理和控制平面之间的通信"><a href="#数据平面代理和控制平面之间的通信" class="headerlink" title="数据平面代理和控制平面之间的通信"></a>数据平面代理和控制平面之间的通信</h2><p>当数据平面代理连接到控制平面时，它会<strong>启动到控制平面的 gRPC 流连接（xDS）</strong>。它从控制平面<strong>检索最新的策略配置</strong>并向控制平面发送诊断信息。</p>
<ul>
<li>在<strong>独立部署</strong>下，kuma-dp 直接连接到 kuma-cp 实例。</li>
<li>在<strong>多区域部署</strong>下，<strong>kuma-dp 连接到 zone kuma-cp，zone kuma-cp 将通过 KDS 的 xDS API 扩展连接到 global kuma-cp</strong>。在多区域模式下，数据平面代理永远不会连接到全局控制平面，而仅连接到区域控制平面。</li>
</ul>
<blockquote>
<p><strong>数据平面和控制平面之间的连接不在服务请求的执行路径上</strong>，这意味着如果数据平面暂时失去与控制平面的连接，服务流量不会受到影响。</p>
</blockquote>
<h2 id="数据平面代理间的通信"><a href="#数据平面代理间的通信" class="headerlink" title="数据平面代理间的通信"></a>数据平面代理间的通信</h2><p>数据平面会<strong>通报每一个服务的 IP 地址：</strong></p>
<ul>
<li>在 Kubernetes 环境中，IP 地址<strong>为 Pod 的地址</strong>。</li>
<li>在 Universal 环境中，IP地址会<strong>检索 inbound listeners</strong>（用于配置控制平面代理的入站监听地址）。</li>
</ul>
<p>数据平面会通报 IP 地址到控制平面，这意味着在任何时间 kuma-cp 都知道每一个服务的每个副本关联的所有 IP 地址是什么。</p>
<p>Kuma 数据平面代理间的通信，在独立部署和多区域部署使用自己的 DNS：</p>
<ul>
<li>在<strong>独立部署</strong>模式下，直接<strong>使用 IP 地址</strong>进行通信。</li>
<li>在<strong>多区域部署</strong>模式下，Kuma 将自动<strong>解析域名</strong>，可以连接到在同一区域中运行的数据平面代理，或者通过 Egress（如果存在）和 另一个区域中的 Ingress 的地址 来实现跨区域连接。这意味着多区域部署模式下，<strong>服务之间可以跨集群</strong>（不管是 Kubernetes 还是 VM）连接。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>对于每一份服务，都会生成一个以 <code>.mesh</code> 结尾的域名：</p>
<ul>
<li><p>对于一个 Kubernetes Service 和关联的 Pod，Kuma 控制面会自动的生成一个注解 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc_&lt;port&gt;</code>，其中 name 和 namespace 还有 port 均来自 Service 信息。</p>
</li>
<li><p>某些情况下 Pods 不属于任何的 Service，仅仅是单纯的一个 Pod（或者在 Universal 下）。在这种情况下，Kuma 会自动生成的注解为 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc</code> ，其中 name 和 namespace 来自于 Pod 资源。</p>
</li>
</ul>
<p>服务的域名被定义为 <code>&lt;kuma.io/service的值&gt;.mesh</code>，默认端口为 80。</p>
<h1 id="非-mesh-流量"><a href="#非-mesh-流量" class="headerlink" title="非 mesh 流量"></a>非 mesh 流量</h1><h2 id="传入流量"><a href="#传入流量" class="headerlink" title="传入流量"></a>传入流量</h2><p>启用 mTLS 后，来自网格外部的客户端无法访问网格内部的应用程序。如果想允许外部客户端使用服务网格，可以使用 Permissive mTLS 模式（宽松的 mTLS，即允许 mTLS，也允许明文请求）。</p>
<p>所有域名查找均由数据平面代理在本地处理，而不是由控制平面处理。这种方法允许更稳健地处理名称解析，例如，当控制平面关闭时，数据平面代理仍然可以解析 DNS。</p>
<p>数据平面代理 DNS 包括：</p>
<ul>
<li>Envoy DNS 过滤器提供来自网格的 DNS 记录响应。</li>
<li>CoreDNS 用于 Envoy DNS 过滤器和原始主机 DNS 之间发送请求</li>
<li>iptable 规则将原始 DNS 流量重定向到本地 CoreDNS 实例。</li>
</ul>
<h2 id="穿出流量"><a href="#穿出流量" class="headerlink" title="穿出流量"></a>穿出流量</h2><p>在默认设置中，Kuma 允许任何非网状流量通过 Envoy，而无需应用任何策略。当 <code>networking.outbound.passthrough</code> 为 <code>false</code> 时，任何非网格资源的流量都不能离开网格。</p>
<p>使用 ProxyTemplate，可以设置非 mesh 流量的配置。如断路器，超时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/" class="post-title-link" itemprop="url">Kuma学习笔记 (4) KDS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-25 12:53:19" itemprop="dateCreated datePublished" datetime="2024-01-25T12:53:19+08:00">2024-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma 通过 KDS（Kuma Discovery Service）进行 Global kuma-cp 和 Zone kuma-cp 的资源交换，以实现跨集群的通信。</p>
<p>在第一节首先会简要说明 KDS 中需要同步的资源，第二节说明 KDS 的实现。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>KDS 同步的资源按照资源的流向，可以分为两种类型：</p>
<ul>
<li>ZoneToGlobal：区域 cp 到全局 cp 同步的信息。</li>
<li>GlobalToZone：全局 cp 到区域 cp 同步的信息。</li>
</ul>
<h2 id="ZoneToGlobal"><a href="#ZoneToGlobal" class="headerlink" title="ZoneToGlobal"></a>ZoneToGlobal</h2><h3 id="Dataplane"><a href="#Dataplane" class="headerlink" title="Dataplane"></a>Dataplane</h3><p><strong>Dataplane：</strong>允许 Zone kuma-cp -&gt; Global kuma-cp，Dataplane 定义了一个数据面 sidecar 代理的配置，spec 包括：</p>
<ul>
<li><strong>Network：网络</strong>，描述数据面代理的入站和出站地址。</li>
<li>Metrics： 定义数据面收集的指标。</li>
<li>Probes：暴露健康检查端口，健康检查配置。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dataplane defines a configuration of a side-car proxy.</span></span><br><span class="line"><span class="keyword">type</span> Dataplane <span class="keyword">struct</span> &#123;</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Networking describes inbound and outbound interfaces of the data plane</span></span><br><span class="line">    <span class="comment">// proxy.</span></span><br><span class="line">    Networking *Dataplane_Networking <span class="string">`protobuf:&quot;bytes,1,opt,name=networking,proto3&quot; json:&quot;networking,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Configuration for metrics that should be collected and exposed by the</span></span><br><span class="line">    <span class="comment">// data plane proxy.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Settings defined here will override their respective defaults</span></span><br><span class="line">    <span class="comment">// defined at a Mesh level.</span></span><br><span class="line">    Metrics *MetricsBackend <span class="string">`protobuf:&quot;bytes,2,opt,name=metrics,proto3&quot; json:&quot;metrics,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Probes describe a list of endpoints that will be exposed without mTLS.</span></span><br><span class="line">    <span class="comment">// This is useful to expose the health endpoints of the application so the</span></span><br><span class="line">    <span class="comment">// orchestration system (e.g. Kubernetes) can still health check the</span></span><br><span class="line">    <span class="comment">// application.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See</span></span><br><span class="line">    <span class="comment">// https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes</span></span><br><span class="line">    <span class="comment">// for more information.</span></span><br><span class="line">    Probes *Dataplane_Probes <span class="string">`protobuf:&quot;bytes,3,opt,name=probes,proto3&quot; json:&quot;probes,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DataplaneInsight：</strong>表示了数据平面的运行时状态，包括：</p>
<ul>
<li>Subscriptions：描述了由数据平面向控制平面创建的 ADS 订阅。</li>
<li>MTLS：数据平面代理的 mTLS 状态，如证书过期时间，上次证书的生成时间等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataplaneInsight defines the observed state of a Dataplane.</span></span><br><span class="line"><span class="keyword">type</span> DataplaneInsight <span class="keyword">struct</span> &#123;</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of ADS subscriptions created by a given Dataplane.</span></span><br><span class="line">    Subscriptions []*DiscoverySubscription <span class="string">`protobuf:&quot;bytes,1,rep,name=subscriptions,proto3&quot; json:&quot;subscriptions,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Insights about mTLS for Dataplane.</span></span><br><span class="line">    MTLS *DataplaneInsight_MTLS <span class="string">`protobuf:&quot;bytes,2,opt,name=mTLS,proto3&quot; json:&quot;mTLS,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Egress"><a href="#Egress" class="headerlink" title="Egress"></a>Egress</h3><p><strong>Egress：</strong>用于定义 Zone Egress。</p>
<ul>
<li>Zone：所属的 Zone 名称。</li>
<li>Network：描述了 Egress 监听的地址和端口。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneEgress allows us to configure dataplane in the Egress mode.</span></span><br><span class="line"><span class="keyword">type</span> ZoneEgress <span class="keyword">struct</span> &#123;</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zone field contains Zone name where egress is serving, field will be</span></span><br><span class="line">    <span class="comment">// automatically set by Global Kuma CP</span></span><br><span class="line">    Zone <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=zone,proto3&quot; json:&quot;zone,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Networking defines the address and port of the Egress to listen on.</span></span><br><span class="line">    Networking *ZoneEgress_Networking <span class="string">`protobuf:&quot;bytes,2,opt,name=networking,proto3&quot; json:&quot;networking,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>EgressInsight：</strong>定义了 Zone Egress 的运行时状态，包括：</p>
<ul>
<li>DiscoverySubscription：定义了由 Zone kuma-cp 创建的 ADS 订阅。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneEgressInsight defines the observed state of a Zone Egress.</span></span><br><span class="line"><span class="keyword">type</span> ZoneEgressInsight <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of ADS subscriptions created by a given Zone Kuma CP.</span></span><br><span class="line">	Subscriptions []*DiscoverySubscription <span class="string">`protobuf:&quot;bytes,1,rep,name=subscriptions,proto3&quot; json:&quot;subscriptions,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p><strong>Ingress：</strong>定义了 Zone Ingress。允许 Zone kuma-cp -&gt; Global kuma-cp，和 Global kuma-cp -&gt; Zone kuma-cp，<strong>Global kuma-cp 接收 Zone kuma-cp 的 Ingress 资源，并向其他 Zone kuma-cp 同步 Ingress 信息</strong>。</p>
<ul>
<li>Zone：标识 Ingress 服务于哪个区域。</li>
<li><strong>Networking：</strong>定义了 Zone Ingress 的监听地址和端口，以及公开的地址端口。</li>
<li><strong>AvailableServices：</strong>定义了可以通过该 Zone Ingress 访问的服务，是 Kuma 跨集群通信的基础。<ul>
<li>Tags：服务 tag。</li>
<li>Instances：给定标签可用的服务实例数量。</li>
<li>Mesh：给定标签可用的服务实例所属的服务网格名称。</li>
<li>ExternalService：表明该服务是否为外部服务。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneIngress allows us to configure dataplane in the Ingress mode. In this</span></span><br><span class="line"><span class="comment">// mode, dataplane has only inbound interfaces. Every inbound interface matches</span></span><br><span class="line"><span class="comment">// with services that reside in that cluster.</span></span><br><span class="line"><span class="keyword">type</span> ZoneIngress <span class="keyword">struct</span> &#123;</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zone field contains Zone name where ingress is serving, field will be</span></span><br><span class="line">    <span class="comment">// automatically set by Global Kuma CP</span></span><br><span class="line">    Zone <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=zone,proto3&quot; json:&quot;zone,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Networking defines the address and port of the Ingress to listen on.</span></span><br><span class="line">    <span class="comment">// Additionally publicly advertised address and port could be specified.</span></span><br><span class="line">    Networking *ZoneIngress_Networking <span class="string">`protobuf:&quot;bytes,2,opt,name=networking,proto3&quot; json:&quot;networking,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// AvailableService contains tags that represent unique subset of</span></span><br><span class="line">    <span class="comment">// endpoints</span></span><br><span class="line">    AvailableServices []*ZoneIngress_AvailableService <span class="string">`protobuf:&quot;bytes,3,rep,name=availableServices,proto3&quot; json:&quot;availableServices,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZoneIngress_AvailableService <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tags of the service</span></span><br><span class="line">	Tags <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,rep,name=tags,proto3&quot; json:&quot;tags,omitempty&quot; protobuf_key:&quot;bytes,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span></span><br><span class="line">	<span class="comment">// number of instances available for given tags</span></span><br><span class="line">	Instances <span class="keyword">uint32</span> <span class="string">`protobuf:&quot;varint,2,opt,name=instances,proto3&quot; json:&quot;instances,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// mesh of the instances available for given tags</span></span><br><span class="line">	Mesh <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,3,opt,name=mesh,proto3&quot; json:&quot;mesh,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// instance of external service available from the zone</span></span><br><span class="line">	ExternalService <span class="keyword">bool</span> <span class="string">`protobuf:&quot;varint,4,opt,name=externalService,proto3&quot; json:&quot;externalService,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IngressInsight：</strong>定义了 ZoneIngress 的运行时状态。允许 Zone kuma-cp -&gt; Global kuma-cp，和 Global kuma-cp -&gt; Zone kuma-cp，Global kuma-cp 接收 Zone kuma-cp 的 IngressInsight 资源，并向其他 Zone kuma-cp 同步 IngressInsight 信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneIngressInsight defines the observed state of a Zone Ingress.</span></span><br><span class="line"><span class="keyword">type</span> ZoneIngressInsight <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of ADS subscriptions created by a given Zone Kuma CP.</span></span><br><span class="line">	Subscriptions []*DiscoverySubscription <span class="string">`protobuf:&quot;bytes,1,rep,name=subscriptions,proto3&quot; json:&quot;subscriptions,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GlobalToZone"><a href="#GlobalToZone" class="headerlink" title="GlobalToZone"></a>GlobalToZone</h2><p>Global kuma-cp 到 zone kuma-cp 的资源，除了 Ingress 外剩下的均是来<strong>自于 Global kuma-cp 策略的更新</strong>。</p>
<p>如 CircuitBreaker，FaultInjection，HealthCheck，Retry 等，这里不再详细说明。</p>
<h1 id="KDS"><a href="#KDS" class="headerlink" title="KDS"></a>KDS</h1><p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/kds.svg" alt="kds"></p>
<h2 id="KDS-v1"><a href="#KDS-v1" class="headerlink" title="KDS v1"></a>KDS v1</h2><h3 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h3><p>在 KDS v1 中，global 和 zone 之间在<strong>一个双向 gRPC 流</strong>中进行资源同步，KDS 服务定义如下：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">MultiplexService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> StreamMessage(stream Message) <span class="keyword">returns</span> (stream Message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> value &#123;</span><br><span class="line">    envoy.api.v2.DiscoveryRequest legacy_request = <span class="number">1</span>;</span><br><span class="line">    envoy.api.v2.DiscoveryResponse legacy_response = <span class="number">2</span>;</span><br><span class="line">    envoy.service.discovery.v3.DiscoveryRequest request = <span class="number">3</span>;</span><br><span class="line">    envoy.service.discovery.v3.DiscoveryResponse response = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在 zone kuma-cp 和 global kuma-cp 建立连接后：</p>
<ul>
<li><p>会<strong>创建 Session 对象</strong>，并启动两个协程用于<strong>读写 gRPC streaming</strong>。Session 底层抽象分离了 serverStream 和 clientStream 并实现了基于 buffer 的 streaming，用于表示 global 到 zone 和 zone 到 global 的连接。</p>
</li>
<li><p>接着<strong>调用 OnSessionStarted 回调函数</strong>，开启两个协程用于表示 server（global kuma-cp）和 client（global kuma-cp）。</p>
<ul>
<li><p>server 实现了 xDS 服务器，用于响应客户端的 xDS 请求。</p>
</li>
<li><p>client 在建立时：</p>
<ul>
<li>首先对所有需要从 zone 到 global（ZoneToGlobal）的资源发起 DiscoveryRequest。</li>
<li>接收 xDS 响应，并同步资源到缓存中。</li>
</ul>
</li>
<li><p>server 和 client 所有读写的数据，均从 serverStream 和 clientStream 中读取/发送。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/image-20240128202501932.png" alt="image-20240128202501932"></p>
<h2 id="KDS-v2"><a href="#KDS-v2" class="headerlink" title="KDS v2"></a>KDS v2</h2><h3 id="为什么引入-KDS-v2"><a href="#为什么引入-KDS-v2" class="headerlink" title="为什么引入 KDS v2"></a>为什么引入 KDS v2</h3><p>为什么要重新设计 KDS v2，因为 KDS v1 实现非常复杂并且可能存在一些 bug（如 <a target="_blank" rel="noopener" href="https://github.com/kumahq/kuma/pull/5373">issues #5373</a>）。KDS v2 主要的变化如下：</p>
<ul>
<li>分离 kds 中 zone 和 global 之间流的共用（这引入了复杂性和 bug）。</li>
<li>当数据从 zone 同步到 global 时，使用<strong>增量更新</strong>而不是全量更新。</li>
</ul>
<p>KDS v1 使用<strong>一个</strong>双向流从同步 zone 和 global 之间的资源。KDS v2 引入 2 个<strong>独立</strong>的 RPC 来同步资源来简化逻辑，将简化逻辑和可读性，并且使用<strong>增量更新 Delta xDS</strong>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">KDSSyncService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GlobalToZoneSync(stream envoy.service.discovery.v3.DeltaDiscoveryRequest)</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ZoneToGlobalSync(stream envoy.service.discovery.v3.DeltaDiscoveryResponse)</span></span><br><span class="line"><span class="function">      <span class="keyword">returns</span> (stream envoy.service.discovery.v3.DeltaDiscoveryRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KDS v1 zone 向 global 发送 DiscoveryRequest 并等待资源的更新通知。global 将状态存储在缓存中，并在发生变化时发送响应。在 global 到 zone 同步的情况下效果很好，但在<strong>大型部署中更多的流量来自从 zone 到 global 的同步</strong>。每当有变化时，zone 控制平面需要将所有数据平面资源发送到 global。所以，KDS v2 使用 delta xDS，可以用<strong>更高效的方式同步资源</strong>。</p>
<h3 id="服务定义-1"><a href="#服务定义-1" class="headerlink" title="服务定义"></a>服务定义</h3><p>KDS v2 分离出了两个接口，GlobalToZoneSync 和 ZoneToGlobalSync，用于 global 和 zone 之间的资源同步，使用 delta xDS。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KDSSyncService is a service exposed by the control-plane for the</span></span><br><span class="line"><span class="comment">// synchronization of the resources between zone and global control-plane.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">KDSSyncService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// GlobalToZoneSync is logically a service exposed by global control-plane</span></span><br><span class="line">  <span class="comment">// that allows zone control plane to connect and synchronize resources from</span></span><br><span class="line">  <span class="comment">// the global control-plane to the zone control-plane. It uses delta xDS from</span></span><br><span class="line">  <span class="comment">// go-control-plane and responds only with the changes to the resources.</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GlobalToZoneSync(stream envoy.service.discovery.v3.DeltaDiscoveryRequest)</span></span><br><span class="line"><span class="function">      <span class="keyword">returns</span> (stream envoy.service.discovery.v3.DeltaDiscoveryResponse)</span>;</span><br><span class="line">  <span class="comment">// ZoneToGlobalSync is logically a service exposed by global control-plane</span></span><br><span class="line">  <span class="comment">// that allows zone control plane to connect and synchronize resources to</span></span><br><span class="line">  <span class="comment">// the global control-plane. It uses delta xDS from go-control-plane and</span></span><br><span class="line">  <span class="comment">// responds only with the changes to the resources.</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ZoneToGlobalSync(stream envoy.service.discovery.v3.DeltaDiscoveryResponse)</span></span><br><span class="line"><span class="function">      <span class="keyword">returns</span> (stream envoy.service.discovery.v3.DeltaDiscoveryRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>GlobalToZoneSync 和 ZoneToGobalSync 在连接开始时，都从 EventBus 订阅了 ZoneWentOffline 事件，接着向 EventBus 发送 ZoneOpenStream 事件（用于通知 HealthCheck 对新的 zone 和 的健康检查），<strong>用于结束与 zone 之间的连接</strong>（如正常结束，发生错误，健康检查超时）。</p>
<ul>
<li><p>在 GlobalToZoneSync 方法中，接着调用 OnGlobalToZoneSyncConnect 回调函数：</p>
<ul>
<li><strong>开启 delta xDS 服务器</strong>，用于响应 zone 到 global 对 GlobalToZone 资源的 xDS 请求。</li>
</ul>
</li>
<li><p>ZoneToGobalSync 方法中，调用 OnGlobalToZoneSyncConnect 回调函数：</p>
<ul>
<li><strong>对所有 ZoneToGlobal 资源</strong>发起 DeltaDiscoveryRequest 请求。</li>
<li>接收 xDS 响应，并<strong>同步</strong>资源到缓存中。</li>
</ul>
</li>
</ul>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/image-20240128201819505.png" alt="image-20240128201819505"></p>
<h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><h4 id="ZoneWatch"><a href="#ZoneWatch" class="headerlink" title="ZoneWatch"></a>ZoneWatch</h4><p>ZoneWatch 订阅 ZoneOpenStream 事件，用于添加活跃的 zone 列表，并通知 zone kuma-cp 下线。</p>
<ul>
<li>每次都会轮询所有的 zone，检查上一次发送 HealthCheck 请求的时间是否超时。</li>
<li>如果超时，则会发送 ZoneWentOffline 事件，通知 KDS 服务器终止与 zone kuma-cp 的连接。</li>
</ul>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/image-20240128210831447.png" alt="image-20240128210831447"></p>
<h4 id="GlobalKDSService"><a href="#GlobalKDSService" class="headerlink" title="GlobalKDSService"></a>GlobalKDSService</h4><p><strong>Kuma 提供在在 Global Zone 上获取 zone xDS 配置、状态等信息的 API</strong>，所以需要通过 GlobalKDSService 收集 zone 的信息，并暴露方法以进行健康检查。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-KDS/image-20240128210844323.png" alt="image-20240128210844323"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%A4%9A%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%A4%9A%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">Kuma学习笔记 (3) 多集群部署方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-25 12:53:03" itemprop="dateCreated datePublished" datetime="2024-01-25T12:53:03+08:00">2024-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多集群部署方案"><a href="#多集群部署方案" class="headerlink" title="多集群部署方案"></a>多集群部署方案</h1><p>Kuma 支持多区域部署，甚至是 Kubernetes 集群和 Universal 集群的混合部署。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%A4%9A%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/kuma_multizone-20240122105251305.svg" alt="Kuma 服务网格多区域部署，无区域出口"></p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在 Kuma 中将服务标记以 <code>kuma.io/service</code> 标签标记，这意味着<strong>运行在任何地方</strong>的数据平面代理可以通过 <code>kuma.io/service</code> 标签值找到该服务。<strong>不同区域上的同一服务</strong>用相同的 <code>kuma.io/service</code> 标记，可以在特定区域发生故障时自动进行<strong>服务故障转移</strong>。</p>
<p>如果一个新的后端服务 serviceA 部署在区域 zone-b，下面看这两个问题。</p>
<ol>
<li>这个新的后端服务如何被通告到 zone-a 区域（区域间的同步）。</li>
<li>一个来自于 zone-a 区域的请求如何被路由到 zone-b 区域（区域间的请求路由）。</li>
</ol>
<h3 id="区域间的信息同步"><a href="#区域间的信息同步" class="headerlink" title="区域间的信息同步"></a>区域间的信息同步</h3><p>当 zone-b 区域中加入了一个新的服务 serviceA 后，区域间的信息同步如下：</p>
<ul>
<li><strong>zone-b 的控制面</strong>将该服务<strong>加入到 zone-b Ingress 资源的 availableServices（可用服务列表）</strong>中，Ingress 持有可用服务列表，以便可以路由区域外的请求。</li>
<li><strong>zone-b 的控制平面</strong>也会将<strong>该区域的 Ingress 资源信息</strong>（Ingress 的地址等），<strong>同步到 Global 全局控制平面</strong>。</li>
<li><strong>全局控制平面</strong>将通过 Kuma 发现服务（<strong>KDS</strong>，基于 xDS 的协议）<strong>将区域入口 Ingress 资源和所有策略传播到所有其他区域</strong>。</li>
</ul>
<h3 id="区域间的请求路由"><a href="#区域间的请求路由" class="headerlink" title="区域间的请求路由"></a>区域间的请求路由</h3><p>当 zone-a 中有请求想请求 serviceA 服务时：</p>
<ul>
<li>首先会进行本地服务和远程服务之间的<strong>负载均衡</strong>，决定发往本区域服务还是远程区域服务。</li>
<li>如果存在区域 Egress，流量会先通过本地区域 zone-a 出口进行路由，然后再<strong>发送到远程区域 zone-b 入口</strong>。</li>
<li>远程区域 zone-b 入口收到请求后，<strong>路由</strong>到本地服务 ServiceA。</li>
</ul>
<blockquote>
<p>对于负载平衡，是<strong>根据其后面运行的实例数量进行加权</strong>。因此，具有 2 个实例的区域接收的流量是具有 1 个实例的区域的两倍。可以配置<strong>位置感知的负载均衡</strong>，来支持本地服务实例。</p>
</blockquote>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>多区域部署包括：</p>
<ul>
<li><strong>全局控制平面（Global kuma-cp）：</strong><ul>
<li>仅接受来自<strong>区域控制平面的连接</strong>。</li>
<li>接受对将应用于数据平面代理的<strong>策略的创建和更改</strong>。</li>
<li><strong>将策略发送到区域控制平面</strong>。</li>
<li><strong>将区域入口向下发送到区域控制平面</strong>。</li>
<li>保留所有区域中运行的所有数据平面代理的清单（这样做只是为了可观察性，但对于操作不是必需的）。</li>
<li><strong>拒绝</strong>来自数据平面代理的连接。</li>
</ul>
</li>
<li><strong>区域控制平面（Zone kuma-cp）：</strong><ul>
<li>接受来自该<strong>区域内启动的数据平面代理的连接</strong>。</li>
<li><strong>从全局控制平面接收策略更新</strong>。</li>
<li>将数据平面代理和区域入口的<strong>更改发送到全局控制平面</strong>。</li>
<li>使用 XDS 计算配置并<strong>将其发送到本地数据平面代理</strong>。</li>
<li>更新区域入口中区域中存在的服务列表。</li>
<li><strong>拒绝</strong>非来自全球的政策变化。</li>
</ul>
</li>
<li><strong>数据平面代理（Envoy）：</strong><ul>
<li>连接到本地区域控制平面。</li>
<li>使用 XDS 从<strong>本地区域控制平面接收配置</strong>。</li>
<li>连接到其他本地数据平面代理。</li>
<li><strong>连接到区域入口以发送跨区域流量。</strong></li>
<li><strong>从本地数据平面代理和本地区域入口接收流量。</strong></li>
</ul>
</li>
<li><strong>区域入口（Ingress）：</strong><ul>
<li><strong>从本地区域控制平面接收 XDS 配置。</strong></li>
<li><strong>从其他区域数据平面代理到本地数据平面代理的代理流量。</strong></li>
</ul>
</li>
<li><strong>（可选）区域出口（Egress）：</strong><ul>
<li><strong>从本地区域控制平面接收 XDS 配置。</strong></li>
<li><strong>来自本地数据平面代理的代理流量：</strong><ul>
<li>来自其他区域的区域入口代理；</li>
<li>从本地区域到外部服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="跨区域服务发现和连接"><a href="#跨区域服务发现和连接" class="headerlink" title="跨区域服务发现和连接"></a>跨区域服务发现和连接</h1><h2 id="KDS"><a href="#KDS" class="headerlink" title="KDS"></a>KDS</h2><p>在多区域部署中，Kuma 提供了几个重要功能：</p>
<ul>
<li>有<strong>两种</strong>控制平面，global 和 zone 控制面。</li>
<li>一种<strong>新的 DNS</strong>，用于跨集群通信。</li>
<li>一种<strong>新的 Ingress 数据平面代理</strong>，可以在 Kuma service mesh 实现区域之间的连接。</li>
</ul>
<p>在分布式部署中，global 控制平面将负责接受 Kuma 资源，通过原生 Kubernetes CRD 或基于 VM 的部署中的 YAML 来确定服务网格的行为。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Global 将负责将这些资源传播到 zone 控制平面。<strong>zone 控制平面和 global 控制平面通过 KDS</strong>（Kuma Discovery Service）以 gRPC（H2）的方式进行<strong>资源的同步</strong>。Zone 控制面还会接收来自于数据面的请求，zone 控制面和其下的所有控制平面代理属于同一区域。</p>
<p>Zone 控制平面还嵌入<strong>一个 DNS 服务发现</strong>，可用于跨不同区域的服务。</p>
<h3 id="分层的好处"><a href="#分层的好处" class="headerlink" title="分层的好处"></a>分层的好处</h3><p>global 和 zone 架构有几个好处：</p>
<ul>
<li>可以通过拓展 zone 控制平面来独立拓展每个区域，并且在某个区域出现问题的时候<strong>实现 HA 故障转移</strong>。</li>
<li><strong>没有单点故障</strong>。即使 global 控制平面发生故障，仍然可以在 zone 控制平面上创建和销毁数据平面代理，并且每个服务的最新地址仍然可以传播到 sidecar 中。</li>
<li>global 控制平面自动传播每个区域的状态，<strong>同时确保“远程”控制平面了解每个区域的Kuma Ingress，以实现跨区域连接</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/22/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%83%A8%E7%BD%B2%E6%8B%93%E6%89%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%83%A8%E7%BD%B2%E6%8B%93%E6%89%91/" class="post-title-link" itemprop="url">Kuma学习笔记 (2) 部署拓扑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 10:40:35" itemprop="dateCreated datePublished" datetime="2024-01-22T10:40:35+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kuma 提供的部署模式在 service mesh 领域非常独特，有两种部署模式：</p>
<ul>
<li><strong>独立式：</strong>Kuma 的默认部署模型具有一个控制平面（可以水平扩展）和许多直接与其连接的数据平面。</li>
<li><strong>多区域：</strong>Kuma 的高级部署模型<strong>支持多个 Kubernetes 或基于 VM 的区域</strong>，或在 Kubernetes 和 VM 上运行的<strong>混合</strong>服务网格。</li>
</ul>
<h1 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h1><p>这是 Kuma 最简单的部署模式，也是默认的部署模式。</p>
<ul>
<li><strong>控制平面</strong>：有一种可以水平扩展的控制平面部署。</li>
<li><strong>数据平面代理</strong>：数据平面代理连接到控制平面，无论部署在何处。</li>
<li><strong>服务连接性</strong>：每个数据平面代理都必须能够连接到每个其他数据平面代理，无论它们部署在何处。</li>
</ul>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%83%A8%E7%BD%B2%E6%8B%93%E6%89%91/flat-diagram.png" alt="img"></p>
<p>独立部署模式下，有一定的<strong>局限性：</strong></p>
<ul>
<li><strong>要求</strong>所有的数据平面代理与<strong>其他所有</strong>的数据平面代理<strong>都能进行通信</strong>。</li>
<li>独立部署只能<strong>连接到一个集群</strong>。</li>
<li>无法混合 Universal 和 Kubernetes 集群工作负载。</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>独立部署包括：</p>
<ul>
<li>控制平面（kuma-cp）：<ul>
<li>接受来自数据平面代理的连接。</li>
<li>接受对将应用于数据平面代理的策略的创建和更改。</li>
<li>保存所有正在运行的数据平面代理的清单。</li>
<li>使用 XDS 将配置发送到数据平面代理。</li>
</ul>
</li>
<li>数据平面代理（envoy）：<ul>
<li>连接到区域控制平面。</li>
<li>使用 XDS 从控制平面接收配置。</li>
<li>连接到其他数据平面代理。</li>
</ul>
</li>
</ul>
<h2 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h2><p><strong>控制平面离线：</strong></p>
<ul>
<li><strong>新的数据平面代理将无法加入网格</strong>。这包括通过自动部署机制（例如滚动更新过程）新创建的新实例（Pod/VM），这意味着控制平面连接故障可能会阻止应用程序的更新和创建新实例的事件。</li>
<li>在启用 mTLS 的网格上，数据平面代理可能<strong>无法</strong>在到期（默认为 24 小时）之前<strong>刷新其客户端证书</strong>，从而导致来自/流向该数据平面的流量失败。</li>
<li>数据平面代理<strong>配置将不会更新</strong>。</li>
<li>数据平面代理之间的<strong>通信仍然有效</strong>。</li>
</ul>
<h1 id="多区域部署"><a href="#多区域部署" class="headerlink" title="多区域部署"></a>多区域部署</h1><p>Kuma 支持多区域部署，甚至是 Kubernetes 集群和 Universal 集群的混合部署。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%83%A8%E7%BD%B2%E6%8B%93%E6%89%91/kuma_multizone-20240122105251305.svg" alt="Kuma 服务网格多区域部署，无区域出口"></p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在 Kuma 中将服务标记以 <code>kuma.io/service</code> 标签标记，这意味着<strong>运行在任何地方</strong>的数据平面代理可以通过 <code>kuma.io/service</code> 标签值找到该服务。<strong>不同区域上的同一服务</strong>用相同的 <code>kuma.io/service</code> 标记，可以在特定区域发生故障时自动进行<strong>服务故障转移</strong>。</p>
<p>如果一个新的后端服务 serviceA 部署在区域 zone-b，下面看这两个问题。</p>
<ol>
<li>这个新的后端服务如何被通告到 zone-a 区域（区域间的同步）。</li>
<li>一个来自于 zone-a 区域的请求如何被路由到 zone-b 区域（区域间的请求路由）。</li>
</ol>
<h3 id="区域间的信息同步"><a href="#区域间的信息同步" class="headerlink" title="区域间的信息同步"></a>区域间的信息同步</h3><p>当 zone-b 区域中加入了一个新的服务 serviceA 后，区域间的信息同步如下：</p>
<ul>
<li><strong>zone-b 的控制面</strong>将该服务<strong>加入到 zone-b Ingress 资源的 availableServices（可用服务列表）</strong>中，Ingress 持有可用服务列表，以便可以路由区域外的请求。</li>
<li><strong>zone-b 的控制平面</strong>也会将<strong>该区域的 Ingress 资源信息</strong>（Ingress 的地址等），<strong>同步到 Global 全局控制平面</strong>。</li>
<li><strong>全局控制平面</strong>将通过 Kuma 发现服务（<strong>KDS</strong>，基于 xDS 的协议）<strong>将区域入口 Ingress 资源和所有策略传播到所有其他区域</strong>。</li>
</ul>
<h3 id="区域间的请求路由"><a href="#区域间的请求路由" class="headerlink" title="区域间的请求路由"></a>区域间的请求路由</h3><p>当 zone-a 中有请求想请求 serviceA 服务时：</p>
<ul>
<li>首先会进行本地服务和远程服务之间的<strong>负载均衡</strong>，决定发往本区域服务还是远程区域服务。</li>
<li>如果存在区域 Egress，流量会先通过本地区域 zone-a 出口进行路由，然后再<strong>发送到远程区域 zone-b 入口</strong>。</li>
<li>远程区域 zone-b 入口收到请求后，<strong>路由</strong>到本地服务 ServiceA。</li>
</ul>
<blockquote>
<p>对于负载平衡，是<strong>根据其后面运行的实例数量进行加权</strong>。因此，具有 2 个实例的区域接收的流量是具有 1 个实例的区域的两倍。可以配置<strong>位置感知的负载均衡</strong>，来支持本地服务实例。</p>
</blockquote>
<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><p>多区域部署包括：</p>
<ul>
<li><strong>全局控制平面（Global kuma-cp）：</strong><ul>
<li>仅接受来自<strong>区域控制平面的连接</strong>。</li>
<li>接受对将应用于数据平面代理的<strong>策略的创建和更改</strong>。</li>
<li><strong>将策略发送到区域控制平面</strong>。</li>
<li><strong>将区域入口向下发送到区域控制平面</strong>。</li>
<li>保留所有区域中运行的所有数据平面代理的清单（这样做只是为了可观察性，但对于操作不是必需的）。</li>
<li><strong>拒绝</strong>来自数据平面代理的连接。</li>
</ul>
</li>
<li><strong>区域控制平面（Zone kuma-cp）：</strong><ul>
<li>接受来自该<strong>区域内启动的数据平面代理的连接</strong>。</li>
<li><strong>从全局控制平面接收策略更新</strong>。</li>
<li>将数据平面代理和区域入口的<strong>更改发送到全局控制平面</strong>。</li>
<li>使用 XDS 计算配置并<strong>将其发送到本地数据平面代理</strong>。</li>
<li>更新区域入口中区域中存在的服务列表。</li>
<li><strong>拒绝</strong>非来自全球的政策变化。</li>
</ul>
</li>
<li><strong>数据平面代理（Envoy）：</strong><ul>
<li>连接到本地区域控制平面。</li>
<li>使用 XDS 从<strong>本地区域控制平面接收配置</strong>。</li>
<li>连接到其他本地数据平面代理。</li>
<li><strong>连接到区域入口以发送跨区域流量。</strong></li>
<li><strong>从本地数据平面代理和本地区域入口接收流量。</strong></li>
</ul>
</li>
<li><strong>区域入口（Ingress）：</strong><ul>
<li><strong>从本地区域控制平面接收 XDS 配置。</strong></li>
<li><strong>从其他区域数据平面代理到本地数据平面代理的代理流量。</strong></li>
</ul>
</li>
<li><strong>（可选）区域出口（Egress）：</strong><ul>
<li><strong>从本地区域控制平面接收 XDS 配置。</strong></li>
<li><strong>来自本地数据平面代理的代理流量：</strong><ul>
<li>来自其他区域的区域入口代理；</li>
<li>从本地区域到外部服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="失效模式-1"><a href="#失效模式-1" class="headerlink" title="失效模式"></a>失效模式</h2><h3 id="全局控制平面离线"><a href="#全局控制平面离线" class="headerlink" title="全局控制平面离线"></a>全局控制平面离线</h3><ul>
<li><strong>政策更新将不可能</strong>。</li>
<li><strong>区域之间服务列表的更改不会传播：</strong><ul>
<li>在其他区域中将无法发现新服务。</li>
<li>从区域中删除的服务在其他区域中仍将显示为可用。</li>
</ul>
</li>
<li><strong>无法禁用或删除区域</strong>。</li>
</ul>
<blockquote>
<p><strong>本地和跨区域</strong>应用程序流量均不会受到此故障情况的影响；数据平面代理更改将在其区域内传播。</p>
</blockquote>
<h3 id="区域控制平面离线"><a href="#区域控制平面离线" class="headerlink" title="区域控制平面离线"></a>区域控制平面离线</h3><ul>
<li><strong>新的数据平面代理将无法加入网格</strong>。这包括通过自动部署机制（例如滚动更新过程）新创建的新实例（Pod/VM），这意味着控制平面连接故障可能会阻止应用程序的更新和创建新实例的事件。</li>
<li>在启用 mTLS 的网格上，数据平面代理可能无法在到期（默认为 24 小时）之前刷新其客户端证书，从而导致来自/流向该数据平面的流量失败。</li>
<li>数据平面代理配置将不会更新。</li>
<li>数据平面代理之间的通信仍然有效。</li>
<li>跨区域通信仍然有效。</li>
<li>其他区域不受影响。</li>
</ul>
<blockquote>
<p>这种故障案例，<strong>与独立部署的控制平面离线故障一致</strong>。</p>
</blockquote>
<h3 id="全局和区域控制平面之间的通信失效"><a href="#全局和区域控制平面之间的通信失效" class="headerlink" title="全局和区域控制平面之间的通信失效"></a>全局和区域控制平面之间的通信失效</h3><p>控制平面之间的配置错误或网络连接问题可能会发生这种情况：</p>
<ul>
<li><p><strong>区域内</strong>的操作是<strong>正常</strong>的（数据平面代理可以加入、离开，所有配置都将正确更新和发送）。</p>
</li>
<li><p>策略更改<strong>不会传播到区域控制平面</strong>。</p>
</li>
<li><p><strong>区域 Ingress，区域 Egress 和数据平面的变更不会传播到全局控制平面：</strong></p>
<ul>
<li>数据平面代理的全局清单视图将过时（这只会影响可观察性）。</li>
<li>其他区域不会看到该区域内注册的新服务。</li>
<li>其他区域不会看到该区域不再运行某服务。</li>
<li>其他区域不会看到本地区域中运行的每个服务的实例数量发生变化。</li>
</ul>
</li>
<li><p><strong>全局控制平面不会将其他区域入口的更改发送到该区域：</strong></p>
<ul>
<li>本地数据平面代理不会看到在其他区域注册的新服务。</li>
<li>本地数据平面代理将看不到其他区域不再运行某服务。</li>
<li>本地数据平面代理不会看到在其他区域中运行的每个服务的实例数量的变化。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>本地和跨区域</strong>应用程序流量均不会受到此故障情况的影响。</p>
</blockquote>
<h3 id="两个区域之间的通信失效"><a href="#两个区域之间的通信失效" class="headerlink" title="两个区域之间的通信失效"></a>两个区域之间的通信失效</h3><p>如果存在区域之间的网络连接问题，可能是以下原因：</p>
<ul>
<li>在控制平面和来自其他区域的区域入口之间。</li>
<li>在控制平面和区域出口之间（如果存在）。</li>
<li>在区域出口（如果存在）和其他区域的区域入口之间。</li>
<li>区域的所有区域出口实例（如果存在）均已关闭。</li>
<li>区域的所有区域入口实例均已关闭。</li>
</ul>
<p>当它发生时：</p>
<ul>
<li>每个区域<strong>内</strong>的通信和操作<strong>不受影响</strong>。</li>
<li>每个区域<strong>之间</strong>的通信将<strong>失败</strong>。</li>
</ul>
<blockquote>
<p>通过<strong>配置正确的弹性设置</strong>（重试、探针、局部感知负载均衡、断路器），可以<strong>快速切断故障区域</strong>并将流量重新路由到另一个区域。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dawnzzz.github.io/2024/01/21/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DawnZH">
      <meta itemprop="description" content="个人博客站点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Kuma学习笔记 (1) 概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-21 19:42:41" itemprop="dateCreated datePublished" datetime="2024-01-21T19:42:41+08:00">2024-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-26 16:20:16" itemprop="dateModified" datetime="2024-02-26T16:20:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Kuma学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a target="_blank" rel="noopener" href="https://kuma.io/">Kuma</a> 是一个与平台无关的开源控制平面，用于 service mesh 和微服务的管理，支持 Kubernetes，VM 和 裸机环境。Kuma 有以下特性：</p>
<ul>
<li><strong>兼容通用环境和 Kubernetes 环境：</strong>与平台无关，可以在任何地方运行和操作。</li>
<li><strong>独立和多区域：</strong>可以独立部署，也支持多区域、多集群。</li>
<li><strong>多服务网格：</strong>可以通过一个控制平面管理多个单独的服务网格，降低整个组织的运维成本。</li>
<li><strong>基于属性的策略：</strong>允许通过 tag 细粒度的选择 source 和 destination 策略。</li>
<li><strong>基于 Envoy：</strong>采用 Envoy 作为数据平面。</li>
<li><strong>水平扩展</strong>。</li>
</ul>
<p>Kuma 多集群部署示例图如下：</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/kuma_multizone.svg" alt="Kuma 服务网格多区域部署"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h3><p>在编写网络应用程序时，会遇到可观测性、流量管理、安全性等共性问题。可以当然可以采用 sdk 的形式去将这些问题集成在框架中，但这是和语言相关的，必须为每一种编程语言提供这样的 sdk，并且需要考虑不同语言之间的兼容性问题。</p>
<p>一个想法是<strong>采用 sidecar 代理</strong>：将所有网络连接中可观测性、流量管理等问题，<strong>委托给进程外的 sidecar 完成</strong>，sidecar 接管所有传入和穿出的请求和响应。开发人员可以专注于应用程序本身，而不是处理复杂的网络问题上去。</p>
<p>由于一个系统具有多个服务，每一个服务有许多实例，这要求具有相同数量的代理。因此，sidecar 代理模型<strong>需要</strong>一个<strong>控制平面</strong>，允许<strong>动态配置代理</strong>的行为，而无需手动配置它们。代理与控制平面的连接以接收新配置，控制平面也为代理提供最新的配置。</p>
<blockquote>
<p>服务网格包括数据平面和控制平面，通常服务网格出现在 Kubernetes 环境中，但是任何环境（VM 和裸机）上都可以构建服务网格）。</p>
</blockquote>
<h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><p>kuma-cp 是 Kuma 控制面的可执行文件，<strong>支持通用环境和 Kubernetes 环境</strong>：</p>
<ul>
<li><strong>在 Kubernetes 上运行：</strong>不需要外部依赖，<strong>利用 K8s API 服务器存储配置</strong>。</li>
<li><strong>在通用环境上运行：</strong>Kuma 需要 PostgreSQL 数据库作为依赖项，用于存储配置。</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Kuma 网络由数据平面和控制平面两个部分组成：</p>
<ul>
<li><strong>数据平面：</strong>由一个个<strong>应用服务+Sidecar 代理</strong>组成，在数据平面中代理接管网络流量，<strong>Kuma 采用 Envoy 作为数据平面代理</strong>。</li>
<li><strong>控制平面：</strong>用于<strong>配置数据平面</strong>，独立于数据平面运行。用户可以在控制平面配置策略，控制平面生成数据平面配置并分发到数据平面。Kuma 实现了<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">Envoy <strong>xDS</strong> API</a> ，以便数据平面代理可以从控制平面检索其配置。</li>
</ul>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/diagram-06.jpg" alt="img"></p>
<p>Kuma 按照运行环境的不同，分为 Kubernetes 和通用（universal）两种运行模式。</p>
<h2 id="Kubernetes-模式"><a href="#Kubernetes-模式" class="headerlink" title="Kubernetes 模式"></a>Kubernetes 模式</h2><p>当在 <strong>Kubernetes</strong> 模式下运行时，Kuma 将其所有状态和配置存储在<strong>底层 Kubernetes API 服务器上</strong>。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/diagram-08.jpg" alt="img"></p>
<p>将 Kubernetes 中的服务加入服务网格进行管理的唯一步骤就是<strong>开启 Sidecar 注入</strong>，<code>kuma.io/sidecar-injection: enabled</code> 标签用于将 sidecar 注入到 pod 中。</p>
<h3 id="Services-和-Pods"><a href="#Services-和-Pods" class="headerlink" title="Services 和 Pods"></a>Services 和 Pods</h3><ul>
<li><p>对于一个 Kubernetes Service 和关联的 Pod，Kuma 控制面会自动的生成一个注解 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc_&lt;port&gt;</code>，其中 name 和 namespace 还有 port 均来自 Service 信息。</p>
</li>
<li><p>某些情况下 Pods 不属于任何的 Service，仅仅是单纯的一个 Pod。在这种情况下，Kuma 会自动生成的注解为 <code>kuma.io/service: &lt;name&gt;_&lt;namespace&gt;_svc</code> ，其中 name 和 namespace 来自于 Pod 资源。</p>
</li>
</ul>
<h2 id="Universal-模式"><a href="#Universal-模式" class="headerlink" title="Universal 模式"></a>Universal 模式</h2><p>在通用模式下运行时，<strong>Kuma 需要 PostgreSQL 数据库来存储其状态</strong>。</p>
<p><img src="/../images/Kuma%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0/diagram-09.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DawnZH</p>
  <div class="site-description" itemprop="description">个人博客站点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">415</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DawnZH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
